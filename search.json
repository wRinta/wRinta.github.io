[{"title":"Dos命令","url":"/2024/03/30/Dos%E5%91%BD%E4%BB%A4/","content":"文件dir显示当前目录\n\ndir /p分页展示\n\ndir /b只显示文件名称\n\n盘符:切换盘符\n\ncd dir切换到当前盘的某个目录下，tab键可以帮助补全\n\nmd创建文件夹，rd删除文件夹\n\n\n复制文件要进入到被粘贴文件的路径，将1.txt复制到demo1目录下，copy 1.txt demo1\\1.txt\n\n复制文件到当前路径下并重命名，copy 1.txt 2.txt\n\n重命名文件名，ren oldfilename newfilename\n\n将命令的结果保存到文件，&gt; filename\n\n\ncls清屏命令\ndel删除文件\n\n批处理文件\n\n\n\n命令管道符command1|command2|command3，后一个命令是对前一个命令结果进行处理\n\n查看文件夹的目录及tree，详细显示tree /f\n\n非文件查看时间time\n\n查看日期date\n\n退出Dos：exit\n查看Dos命令：help\n","tags":["Dos"]},{"title":"C program language","url":"/2021/07/17/C-program-language/","content":"\n  52b957e64bf07e3f6f387f83f112f606a00cbcea95df80b68037ad6e34ae86b2d71d3c81abcbc1175f2502d364c86477724137c24bc6337b2efafea60055572eaf49b76785aa4e0152bc0668da97f4b374a505e4926c0c47f4e7561600d714405ed3ea923de8946130422aa8d4193a8f0e09ce84fba5ab603392e109f447c14ca87fce276bfb4830484f7934a6521592e1131eab2430a46fdd6d37f7610544d5dee4bad730e8d6c16d3018f178ebe3dc22185d97a44f273cc47c3264bbe2f312a4e18cce55b86973a06113a4814978c8fcaea5d2f32551fbe06a0d36c9882105e7fda1c3ce0c4fdc158b29a84466fe19e6f2f667465d917b1dfea961de4de39b9edef8ede2018cecfe93ffc359208b57bcf3ae205927987a957c0b04e29d6f3fad2a7a5c4103552150d79f7045f33e3aed581b38618f5eb8706b165a1e1c3bc1aae70de2459b1d816815aee98db1817da50134a5eb0c305a02cc71b650d2c945e23eccc38251b83a5550d0c4e89aa1d00c39edb71720ded59e85930094388e63c4a48dcf6ab65fc29b1d5ecc710029ef01f4780500f2bbda5da1494aa8108a6bbe604c7cb3a4340de5cf2ccda5e925858108903544a316738141f3ccbf2bf560bfe2ef95ba03e912f2ec3de0a2befa3c401bd269de3fb590293e27433393aaf9aa195d83271d1eb3bba2272418c4d73dd012e39aa5ed3bc65f8f8c8f15656b85dc5c248eca217aadaa28c8e9576cbba80b525c14b2909f68cf4260231905314657c3899df5cd2bbc97f60b6699068b9883c5b6d23d425e4f7b8827f2b9da46453eeecfcef45fa92db069d988aa1997ff8a4da560c4c84220bb975828d87dfdd50b9b26bc5243086ae1541a43f60c569bc4074d5d906b3e0e38608ef600214e0245caffc0a45105fec70d245954fb646484f93946307ee90d8464c147826e976f3e6f57ba4b9d8dd5063f69f1ab33c2ce644363656ff79c56259b9c94cdcd7f37b4647c18f11547e998b85067d641579e2acbf82123f39e410497d0131e9747cd0aacd2bef1390ac94e0d8cef4cf254eb42b89b35e5b2f258bc3982811bce8f053844fe549de4b4a29c1934742d6534f211268503ae79051ce7e233ef863d8eec6f8bfd6ebfd92f668e697d87fc42c9110d5369943883f371afce164b45b0c0c266d87b5931a4746e069012bd128c32fab42cf540bb93e8507156246a59ee1b12cf91f4fe0d0fa927ae9a36466354304ad317724c85d69e25b6db7e06bd09772956913584721909039eaced79e67d5d600d4105c53f8651bcd82318575d220b143044c90b061a06eb178a021962545d37b918967ce6beaad684df9548107cdff0d7afed2994c8085e069512af0e2225f02bfb04009794a0b465b6af135064ebc1699e07b54a234c0b13888197a73c2a4bd663ec2d456a6d9857c432f862392c1c2a35f39f4c58e7a7a9096e64997554fea70a5e432524ec2cc2f50570871ffde35c580bfc9772c08a3f3b8615b06cab95cfa8d39e14a52a0ee1266ac5472957aa5e6877b60532553b8a0c5e94b66ad7fa8f98493a2891af96bdc86141a8490762f5c14e5940725941cba79b7e2e490b3d53e2ffa8ba9a25b830da10ba1e2e00137416fa5c6693e5319dce0dde17945723596495661616ef3e5f5427427dc19ba84f28a80521cfbfaf58d1380dbf4af7b2077d67dbbc59426b6f13e41c63d9af8b9236daccd566134cf416d13cc00a29da0a648fa07e71e124a2b023cdd14fed87be67f4445193fdfba97094b6018c72daec606337e23254d56b133aa559ad44cfbb222e551df47763b4842ae36452c4e9478c30f24325baf16598925bd5d8b08bcd7874de2d2d9c82f053cf29cd04109ee3845053bea962207a174e471734c40d148edba5492eea3c22e1d1402a0d267d7c4e24ceff0c73405afa7ed6649a2f288d519fafbc15067dea8e3c0150ea4a9c183a29e9ee61f502c5249bbc28f758624b18dd08f8c37c3f77bdf0d2bb9fb528d172f140af6a1f638fcdb3c7723679badf2e0ce35f51fd5aaf030c6f44ae31862ada8f3f492e6c854add8f1b50d8886984aa68182cfe9abbc0e6ef1c002c1289f3b886a05544b6fbe52b81304330b72ff5ec2b0928309b30ebc9157e41394c06d74627edf1c90f65fdd566f4b88375fd8479fef40a685b4f755f5e677dc72c974ed422eef1a92dd5cf83834192657337fea23b152af1225fd74bd1e21c6e77e010f00412ffeb8f5fd31366d8245872de92ac188586e21878380891b2aac929623856cb2438a882d46c4fc3c1b7a6012f34696127fa4236c794ee48c940131558292fe5e7cded196f571f68e58ecf377c97bb1603b2f4b0b529027e868f311f5ebb1f1cb549087f09a73cce10b392c328f19eb918539fbabb58f73a7262266e227d213801c63609ab33f079ac870c2c7bf327d777f0122bd8f8863e902ec9891ad0bfe5a78dfdbbd1f4ceeaf33b1d8ffdd9c67d320c0f33d35e577640de3b377f6518983607eff1bdbb696d227df39c5491f4b68e461e8ef335c938ad4f0372d3fabb7898284942477aa5d45beec09e498915324369d6cc334a741a8046a0a114c93dd2918f66cd07a45928b6d6de2cb1b08e497096b32ee6cf84e91b67c8a9593fe7cbf3cd434742b9fda629423ec438f755945561024e4c07f3b91f4085d110173c24be266a0abd06500acec0a7143c9a793590b8c9da738c1faccf52a0b2ea5d58f2aafc4eff521586d7ee11bc83efb9093048caed6ca3af638bb40958e23c38fe472dda9ec0ec0626893a79ae91b6f0d68a143e7b2f18f75eb0d9b203d2ce34cfdcd9704a279507e7209268bfa52e3d0fd04ed5c24ec46f09ec0fd5e38d3ae1ff5f4aeafd8fb8dd98f05f6542805f5549fd2a0c649109d8fe3161661ad4a48245ee1f6290f64129d9e06ca0b03e11a4d6dfaf1dbef88a42732477bd25ff9185eec0a7e86c0c77418e9213ed1e742135ef1a98229315c30393765b1c82a598f864e54854d4725caa0bd71ef607517299623c0ff9c15bdf3b1019969e2851a1440ec8950e6c63b903c18f34ef41a19739d47d02fa470b94210ed7ce1f888c8df9fe289ecbfed137e41270fd144cc0de18936fb6c7690f4e2e6349ada5cdd1f5e57ed21e0a0ff2b634c6fd3911c3fb1b8ab47f3d16526658678b635c6c1c3b51f58c62b3f3b2397b5c4144f4feb98c80d7cff1a5905e9b0e04dfff9cd26941fdd3b5946bcfaa7a8c5437e29ad223a29cba5d493eb14151b8e0eb9c0533c5ae80b30027d2c7c81435dd5d6790c66d15e88a07e6109eca447396078a50264d65d884076efa7a78576dd36e3df66bcf81e6848a14e293770eaeeb36f4b9f124a982d8b62392c4d0e45f11c728cba594131a4f9223554effe44dfacb37b4822f7623fd1eb73377b6b2237713ad199c750f1db9f2204ac9c1db36e9d144ee708c19abd566395640ffcab22d5d0deb971c8f3b217f4b1002735b589e4dc59891ba81fcfbdd43370b46f50b12d2e1d4bc5ddb2af131ff5d784dcb7b9d2c7ffdb377aa77b78c2204ec0d769920729420ac736e3e2f945affa069954f3268aa5137224e1958d9604267be7a93849a9c6aaa285e9eb2b05a2e9e63c059753c58d30906d3b32315656e3932685190a51a75fc9cb9c7b44a5139cba8a51ce51df3f941c19a60e9dd5b24a54e1d024aaf5ecfa0d4fdda6577bd52df8c86a56cf9768091056a1448ea65e04b75114173be6b005ac9ef79e22ddadd224b6b7e96137f4d1c14e87e4124ea66f42cdfcf79c848bc87373907a49f56efb9072b34677f62fdb39740b120d55413c8a88cb5e91706ca0f4b0dec68074cb50291fc952237d6a8bd1fa9061b272f036606ff3c02c1464f42923829bb58844a945d9569de94c928a1d2fae5f91bcccbb7a71ab476072fc3c94f7b3eb83a28d89f53cdd9d29c2c30f4e80238ce6833599f14328142c047fd7ef95dd6a27ea6fbaca051379df160c94cff6ca203a0d530152d70c7ea4bc017140ed311\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["reviews"],"tags":["C"]},{"title":"JQuery对列表的增删改以及遍历","url":"/2021/07/16/JQuery%E5%AF%B9%E5%88%97%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E4%BB%A5%E5%8F%8A%E9%81%8D%E5%8E%86/","content":"问题描述使用JQuery对html中的ul进行li的增删改以及遍历查看\n代码html部分&lt;div&gt;        &lt;ul&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;button id=&quot;addItem&quot;&gt;添加元素&lt;/button&gt;    &lt;button id=&quot;deleteItem&quot;&gt;删除元素&lt;/button&gt;    &lt;button id=&quot;traversal&quot;&gt;显示列表&lt;/button&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;输入修改第几项&quot; id=&quot;index&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;修改的值&quot; id=&quot;value&quot;&gt;    &lt;button id=&quot;modifyItem&quot;&gt;改变列表项&lt;/button&gt;    &lt;br&gt;遍历结果：    &lt;p id=&quot;res&quot;&gt;&lt;/p&gt;\n\nscript部分list增加元素：$(&quot;#addItem&quot;).click(function() &#123;                let newItem = &quot;&quot;;                newItem = &quot;&lt;li&gt;&quot; + i + &quot;&lt;/li&gt;&quot;;                i += 1;                $(&quot;ul&quot;).append(newItem);            &#125;);\n\nlist删除元素：$(&quot;#deleteItem&quot;).click(function() &#123;                let tmp = $(&quot;ul&quot;).html().toString();                let location = tmp.lastIndexOf(&#x27;&lt;li&gt;&#x27;);                $(&#x27;ul&#x27;).html(tmp.slice(0, location));                i -= 1;            &#125;);\n\nlist修改特定项的元素：$(&quot;#modifyItem&quot;).click(function() &#123;                let index = $(&quot;#index&quot;).val();                let value = $(&quot;#value&quot;).val();                $(&quot;li&quot;).eq(index - 1).text(value);            &#125;);\n\nlist遍历：$(&quot;#traversal&quot;).click(function() &#123;                let res = [];                for (j = 0; j &lt; $(&quot;li&quot;).length; j++) &#123;                    res.push($(&quot;li&quot;).eq(j).text())                &#125;                $(&quot;#res&quot;).text(res);            &#125;);\n\n全部代码&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        $(document).ready(function() &#123;            let n = 6,                i = 1;            let text = &quot;&quot;;            for (i; i &lt; n; i++) &#123;                text += &quot;&lt;li&gt;&quot; + i + &quot;&lt;/li&gt;&quot;;            &#125;            $(&quot;ul&quot;).append(text);            $(&quot;#addItem&quot;).click(function() &#123;                let newItem = &quot;&quot;;                newItem = &quot;&lt;li&gt;&quot; + i + &quot;&lt;/li&gt;&quot;;                i += 1;                $(&quot;ul&quot;).append(newItem);            &#125;);            $(&quot;#deleteItem&quot;).click(function() &#123;                let tmp = $(&quot;ul&quot;).html().toString();                let location = tmp.lastIndexOf(&#x27;&lt;li&gt;&#x27;);                $(&#x27;ul&#x27;).html(tmp.slice(0, location));                i -= 1;            &#125;);            $(&quot;#traversal&quot;).click(function() &#123;                let res = [];                for (j = 0; j &lt; $(&quot;li&quot;).length; j++) &#123;                    res.push($(&quot;li&quot;).eq(j).text())                &#125;                $(&quot;#res&quot;).text(res);            &#125;);            $(&quot;#modifyItem&quot;).click(function() &#123;                let index = $(&quot;#index&quot;).val();                let value = $(&quot;#value&quot;).val();                $(&quot;li&quot;).eq(index - 1).text(value);            &#125;)        &#125;)    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;July 16th&lt;/p&gt;    &lt;div&gt;        &lt;ul&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;button id=&quot;addItem&quot;&gt;添加元素&lt;/button&gt;    &lt;button id=&quot;deleteItem&quot;&gt;删除元素&lt;/button&gt;    &lt;button id=&quot;traversal&quot;&gt;显示列表&lt;/button&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;输入修改第几项&quot; id=&quot;index&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;修改的值&quot; id=&quot;value&quot;&gt;    &lt;button id=&quot;modifyItem&quot;&gt;改变列表项&lt;/button&gt;    &lt;br&gt;遍历结果：    &lt;p id=&quot;res&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n","categories":["HTML"],"tags":["JQuery"]},{"title":"Java入门(二)","url":"/2022/04/02/Java%E5%85%A5%E9%97%A8-%E4%BA%8C/","content":"继承在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。\n利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（sub class）。\n接口在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。\n接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。\nJava对象和类\n对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n类：类是一个模板，它描述一类对象的行为和状态。、\n局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。\n\n\n\n创建对象对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：\n\n声明：声明一个对象，包括对象名称和对象类型。\n实例化：使用关键字 new 来创建一个对象。\n初始化：使用 new 创建对象时，会调用构造方法初始化对象\n\npublic class Puppy&#123;   public Puppy(String name)&#123;      //这个构造器仅有一个参数：name      System.out.println(&quot;小狗的名字是 : &quot; + name );    &#125;   public static void main(String[] args)&#123;      // 下面的语句将创建一个Puppy对象      Puppy myPuppy = new Puppy( &quot;tommy&quot; );   &#125;&#125;\n\n访问实例变量和方法/* 实例化对象 */Object referenceVariable = new Constructor();/* 访问类中的变量 */referenceVariable.variableName;/* 访问类中的方法 */referenceVariable.methodName();\n\n源文件声明规则\n一个源文件中只能有一个 public 类\n一个源文件可以有多个非 public 类\n源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。\n如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。\n如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。\nimport 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\n\n","categories":["Java Learning"],"tags":["Java"]},{"title":"Java入门(一)","url":"/2022/03/26/Java%E5%85%A5%E9%97%A8-%E4%B8%80/","content":"JDK、JRE、JVMJDK：Java Development Kit，包含了JRE和JVM，扩充了开发工具\nJRE：Java Runtime Environment，运行环境\nJVM：Java Virtual Machine，可以用软件或硬件来实现，模拟了一个小巧的CPU处理JAVA。跨平台的核心，屏蔽底层系统的差别。\nHello World\n新建一个Java文件，文件的后缀名为.java，如Helloworld.java\n\n输入代码\npublic class Helloworld&#123;\tpublic static void main(String[] args)&#123; // 程序通过mai方法执行\t\tSystem.out.print(&quot;Hello,world!&quot;);\t&#125;&#125;\n\n在控制台输入命令进行编译\njavac Helloworld.java #编译成功控制台不输出消息，会在文件夹里生成一个Helloworld类\n\n\n\n在控制台输入命令运行类\njava Helloworld #输出结果会在控制台中显示\n\n\n\n\n\n注意：\n\nJava是大小写敏感的。\n\n所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。\n\n类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass\n\n源文件名和代码里的类名必须保持一致，且首字母大写\n\n主方法入口：所有的 Java 程序由 public static void main(String[] args) 方法开始执行。\n\n\nJava基础语法对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n类：类是一个模板，它描述一类对象的行为和状态。\n方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。\n实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。\nJava程序运行机制Java既有编译型(Complie)的特点，又有解释型(Interpret)的特点。.java的源文件经过Java编译器成为.class文件。.class文件放入虚拟机的类装载器中，类加载进JVM。字节码校验器会检查代码是否出错，最后解释器会将代码解释给操作系统平台。先编译，再解释。\n注释注释并不会被执行\n\n单行注释：\n// 这是单行注释\n\n多行注释：\n/*这是多行注释*/\n\nJavaDoc文档注释：\n/*** @Description Helloworld* @Author Rinta*/\n\n标识符Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。\nJava中的关键字：\n\n\n注意：\n\n所有的标识符应该以字母（A-Z或a-z），美元符（$），或下划线（_）开始\n首字母之后可以是字母（A-Z或a-z），美元符（$），下划线（_）或数字的随意组合\n不能使用关键字作为变量名或方法名\n标识符大小写敏感\n可以使用中文命名，不建议\n\nJava修饰符Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：\n\n访问控制修饰符 : default, public , protected, private\n非访问控制修饰符 : final, abstract, static, synchronized\n\n数据类型Java是强类型语言，要求变量的使用严格符合规定，所有变量必须先定义后才能使用，\n基本类型（primitive type）\n数值类型\n\n整数类型\n\nbyte 一个字节范围：-128 - 127\n\nshort 两个字节范围：-32768 - 32767\n\nint 四个字节范围：-2147483648 - 2147483647\n\nlong 八个字节范围：-9223372036854775808 - 9223372036854775807 \n在数字后面加L，如：long num1 &#x3D; 12344321L;\n\n\n\n浮点类型\n\nfloat 占4个字节\n在数字后面要加F，如：float num2 &#x3D; 22.3f;\n\ndouble 占8个字节\n\n\n\n字符类型 \n\nchar 占2个字节\n\n\n\n\nboolean类型：占1位，值只有true和false\n\n\n类型转换转换的从低到高为：byte,short,char—&gt; int —&gt;long—&gt;float—&gt;double，低（范围）向高转换是自动转换，高到低要强制转换\n注意：\n\n不能对布尔值进行转换\n不能把对象类型转换成不相干的类型\n高到低要用到强制转换\n转换的时候可能存在内存溢出，或者精度问题\n\n引用类型（reference type）\n类\n接口\n数组\n\n拓展\n整数拓展\n\n二进制：0b，八进制：0，十六进制：0x\n\n\n浮点数拓展\n\neg. 银行业务怎么表示？BigDecimal 数学工具类\n\n\n\n最好完全避免用浮点数进行比较\n\n字符类拓展\n\n所有的字符本质上是数字，Unicode编码，从U0000到UFFFF\n\\u 转义字符表示\n\n\n布尔值拓展\n\nboolean flag = true;\nif(falg)&#123;&#125;\n# 变量每个变量必须声明其类型，Java变量是程序中最基本的存储单元，要素包括变量名，变量类型和作用域。Java 中主要有如下几种类型的变量- 局部变量- 类变量（静态变量）- 成员变量（非静态变量）**注意：**- 每个变量都有类型，可以是基本类型，也可以是引用类型- 变量名必须是合法的标识符- 变量声明是一条完整的语句，分号结束## 变量作用域```javapublic class Variable(\tstatic int allClicks = 0;   // 类变量\tString str = &quot;hello world&quot;;  //  实例变量    public void method()&#123;        int i = 0;  //  局部变量    &#125;)\n\n\n\n\n类变量\n关键词：static，从属于类\n\n类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n静态变量除了被声明为常量外很少使用，静态变量是指声明为 public&#x2F;private，final 和 static 类型的变量。静态变量初始化后不可改变。\n静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。\n静态变量在第一次被访问时创建，在程序结束时销毁。\n与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n静态变量可以通过：ClassName.VariableName的方式访问。\n类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。\n\n\n实例变量\n独立于方法之外的变量，类的里面，从属于对象 \n\n实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n\n当一个对象被实例化之后，每个实例变量的值就跟着确定；\n\n实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n\n实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n\n实例变量可以声明在使用前或者使用后；\n\n访问修饰符可以修饰实例变量；\n\n实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n\n实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n\n实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n\n\n局部变量\n类的方法中的变量，必须声明和初始化值。\n\n局部变量声明在方法、构造方法或者语句块中；\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；\n访问修饰符不能用于局部变量；\n局部变量只在声明它的方法、构造方法或者语句块中可见；\n局部变量是在栈上分配的。\n局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\n\n\n\nJava数组数组是储存在堆上的对象，可以保存多个同类型变量。\nJava枚举Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。\n常量初始化后不能再改变值\n// final 常量名=值;final double PI=3.14\n\n\n\nJava运算符关系运算符\n\n\n操作符\n描述\n例子（A&#x3D;10,B&#x3D;20）\n\n\n\n+\n加法 - 相加运算符两侧的值\nA + B 等于 30\n\n\n-\n减法 - 左操作数减去右操作数\nA – B 等于 -10\n\n\n*\n乘法 - 相乘操作符两侧的值\nA * B等于200\n\n\n&#x2F;\n除法 - 左操作数除以右操作数\nB &#x2F; A等于2\n\n\n％\n取余 - 左操作数除以右操作数的余数\nB%A等于0\n\n\n++\n自增: 操作数的值增加1\nB++ 或 ++B 等于 21\n\n\n–\n自减: 操作数的值减少1\nB– 或 –B 等于 19\n\n\n\n前缀自增自减法（++a，–a）：先进行自增或自减运算，再进行表达式运算。\n后缀自增自减法（a++，a–）：先进性表达式运算，再进行自增或自减运算。\n\n关系运算符\n\n\n运算符\n描述\n例子（A&#x3D;10,B&#x3D;20）\n\n\n\n&#x3D;&#x3D;\n检查如果两个操作数的值是否相等，如果相等则条件为真。\n（A &#x3D;&#x3D; B）为假。\n\n\n!&#x3D;\n检查如果两个操作数的值是否相等，如果值不相等则条件为真。\n(A !&#x3D; B) 为真。\n\n\n&gt;\n检查左操作数的值是否大于右操作数的值，如果是那么条件为真。\n（A&gt; B）为假。\n\n\n&lt;\n检查左操作数的值是否小于右操作数的值，如果是那么条件为真。\n（A &lt;B）为真。\n\n\n&gt;&#x3D;\n检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。\n（A&gt; &#x3D; B）为假。\n\n\n&lt;&#x3D;\n检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。\n（A &lt;&#x3D; B）为真。\n\n\n位运算符位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。\n\nA = 0011 1100B = 0000 1101-----------------A&amp;B = 0000 1100A | B = 0011 1101A ^ B = 0011 0001~A= 1100 0011\n\n\n\n\n操作符\n描述\n例子（A&#x3D;60，B&#x3D;13）\n\n\n\n＆\n如果相对应位都是1，则结果为1，否则为0\n（A＆B），得到12，即0000 1100\n\n\n|\n如果相对应位都是 0，则结果为 0，否则为 1\n（A | B）得到61，即 0011 1101\n\n\n^\n如果相对应位值相同，则结果为0，否则为1\n（A ^ B）得到49，即 0011 0001\n\n\n〜\n按位取反运算符翻转操作数的每一位，即0变成1，1变成0。\n（〜A）得到-61，即1100 0011\n\n\n&lt;&lt;\n按位左移运算符。左操作数按位左移右操作数指定的位数。\nA &lt;&lt; 2得到240，即 1111 0000\n\n\n&gt;&gt;\n按位右移运算符。左操作数按位右移右操作数指定的位数。\nA &gt;&gt; 2得到15即 1111\n\n\n&gt;&gt;&gt;\n按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。\nA&gt;&gt;&gt;2得到15即0000 1111\n\n\n当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。\n赋值运算符\n\n\n操作符\n描述\n例子\n\n\n\n&#x3D;\n简单的赋值运算符，将右操作数的值赋给左侧操作数\nC &#x3D; A + B将把A + B得到的值赋给C\n\n\n+ &#x3D;\n加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数\nC + &#x3D; A等价于C &#x3D; C + A\n\n\n- &#x3D;\n减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数\nC - &#x3D; A等价于C &#x3D; C - A\n\n\n* &#x3D;\n乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数\nC * &#x3D; A等价于C &#x3D; C * A\n\n\n&#x2F; &#x3D;\n除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数\nC &#x2F; &#x3D; A，C 与 A 同类型时等价于 C &#x3D; C &#x2F; A\n\n\n（％）&#x3D;\n取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数\nC％&#x3D; A等价于C &#x3D; C％A\n\n\n&lt;&lt; &#x3D;\n左移位赋值运算符\nC &lt;&lt; &#x3D; 2等价于C &#x3D; C &lt;&lt; 2\n\n\n&gt;&gt; &#x3D;\n右移位赋值运算符\nC &gt;&gt; &#x3D; 2等价于C &#x3D; C &gt;&gt; 2\n\n\n＆&#x3D;\n按位与赋值运算符\nC＆&#x3D; 2等价于C &#x3D; C＆2\n\n\n^ &#x3D;\n按位异或赋值操作符\nC ^ &#x3D; 2等价于C &#x3D; C ^ 2\n\n\n| &#x3D;\n按位或赋值操作符\nC | &#x3D; 2等价于C &#x3D; C | 2\n\n\n条件运算符（?:）条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。\nvariable x = (expression) ? value if true : value if false\n\nintanceof运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\n( Object reference variable ) instanceof  (class/interface type)\n\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真。\nString name = &quot;James&quot;;boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n\n如果被比较的对象兼容于右侧类型,该运算符仍然返回true。\nclass Vehicle &#123;&#125; public class Car extends Vehicle &#123;   public static void main(String[] args)&#123;      Vehicle a = new Car();      boolean result =  a instanceof Car;      System.out.println(result);   &#125;&#125;\n\nJava运算符优先级\n\n\n类别\n操作符\n关联性\n\n\n\n后缀\n() [] . (点操作符)\n左到右\n\n\n一元\nexpr++ expr–\n从左到右\n\n\n一元\n++expr –expr + - ～ ！\n从右到左\n\n\n乘性\n* &#x2F;％\n左到右\n\n\n加性\n+ -\n左到右\n\n\n移位\n&gt;&gt; &gt;&gt;&gt;  &lt;&lt;\n左到右\n\n\n关系\n&gt; &gt;&#x3D; &lt; &lt;&#x3D;\n左到右\n\n\n相等\n&#x3D;&#x3D; !&#x3D;\n左到右\n\n\n按位与\n＆\n左到右\n\n\n按位异或\n^\n左到右\n\n\n按位或\n|\n左到右\n\n\n逻辑与\n&amp;&amp;\n左到右\n\n\n逻辑或\n| |\n左到右\n\n\n条件\n？：\n从右到左\n\n\n赋值\n&#x3D; + &#x3D; - &#x3D; * &#x3D; &#x2F; &#x3D;％&#x3D; &gt;&gt; &#x3D; &lt;&lt; &#x3D;＆&#x3D; ^ &#x3D; | &#x3D;\n从右到左\n\n\n逗号\n，\n左到右\n\n\n包机制\n为了更好地组织类，Java提供了包机制，用于区别类的命名空间。\n\n语法格式：\npackage pkg1[. pkg2[. pkg3...]];\n\n一般利用公司域名倒置作为包名\n\n为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包。使用import语句可完成此功能。\nimport package1[.package2...].(classname|*)\n\n*是通配符，会导入这个包下所有的类\n\n\nJavaDoc\njavadoc命令是用来生成自己API文档的，可以将一种自定的注释信息生成帮助文档\n\n参数信息\n\n@author    作者名\n@version    版本号\n@since    指明需要最早使用的jdk版本\n@param    参数名\n@return    返回值情况\n@throws    异常抛出情况\n\n\n可以加在类或方法上面\n\n可以在命令行输入代码生成doc文件\njavadoc -encoding UTF-8 -charset UTF-8 Doc.java\n\n","categories":["Java Learning"],"tags":["Java"]},{"title":"Linux基础","url":"/2024/04/05/Linux%E5%9F%BA%E7%A1%80/","content":"Linux系统目录结构\n目录说明\n&#x2F;bin 存放常用命令，命令就是一个可执行程序，cd、ls等都是命令\n&#x2F;lib 存放库文件例如，printf是一个库函数，它的实现在c库中。c库就存放在lib下。\n&#x2F;home 所有普通用户的家目录\n&#x2F;root 管理员用户的家目录管理员的家目录并不在&#x2F;home下面，而是在&#x2F;root。\n&#x2F;boot 系统内核及启动有关的文件\n&#x2F;etc 存放系统的配置文件\n&#x2F;proc 虚拟文件系统目录，以进程为单位存储内存的映射\n&#x2F;usr 存放系统应用程序及文档\n&#x2F;dev 存放设备文件\n&#x2F;mnt 临时挂载点\n&#x2F;tmp 存放各种临时文件，是所有用户均可访问的地点\n&#x2F;var 存放系统运行中常改变的文件，如系统日志\n\n家目录在&#x2F;home文件夹下创建stu1和stu2两个文件夹，把stu1创建的所有文件都存放到stu1文件夹下，这个文件夹中的内容只能stu1可以看到或操作，把stu2创建的文件都存放到stu2文件夹下，这个文件夹中的内容只能stu2可以看到或操作。每一个普通用户都会在&#x2F;home下面创建属于自己的文件夹，这个文件夹以该用户的名字来命名。后续，用户也可以在各自的文件夹下再创建其他的文件夹来存放其他的文件。每个用户都不能访问别的用户的目录以及目录下的子文件。起到了一个保护作用。如果是用户stu1，那么它的家目录是&#x2F;home&#x2F;stu1；如果是用户stu2，那么它的家目录是&#x2F;home&#x2F;stu2。用户不同，家目录也不同。\ncd命令cd /home #切换至home目录，/为根目录cd /home/rinta #第一个/为根目录cd rinta #进入当前文件夹的下一级rinta文件夹pwd 显示当前所在目录# 路径以根目录开头为绝对路径cd .. #回到上一级目录cd #会直接切换到当前用户的家目录cd ~ #回到用户的home目录cd - #返回到上次执行cd命令的目录，即切换之前所在的目录\n\n\nls命令ls #显示当前目录下有哪些目录ls -a #显示当前目录下所有的目录,会显示隐形目录ls -l #显示文件的详细信息ls -lh #更人性化的方式显示ls -lah #所有的文件人性化的显示出来ll #相当于ls -lll -h #人性化的显示ll -a#显示所有文件\n\n\n\nls命令权限介绍*匹配任意字符，#匹配一个字符，[]匹配范围！\n*匹配任意字符，#匹配一个字符，[]匹配范围！\n*匹配任意字符，#匹配一个字符，[]匹配范围！\n*匹配任意字符，#匹配一个字符，[]匹配范围！\ndrwxrwx-x #d代表文件夹，-代表文件rwx rwx r-x #三组，r：可读，w：可写，x：可执行，-：表示非# 文件拥有者的权限 文件拥有组的权限 其他用户对该文件的权限ls dir2 #查看dir2目录下的内容ls / #查看根目录下的内容ls -la / #查看根目录下所有的内容ls ../.. #查看上级目录的上级目录ls a* # *匹配任意字符，查看以a开头的内容ls a? # ?代表一个任意字符ls [abc]d #d前面的字母匹配abc中其中一个ls [a-x]d #d前面的字母匹配a-x中其中一个ls \\*x #查看*x，\\为转义字符ls *txt #查看当前目录下所有以txt结尾的文件\n\n\nmkdir命令mkdir pic #在当前目录下创建文件夹picmkdir /home/admin/video #绝对路径创建，要保证路径存在mkdir -p #创建的目录父目录不存在，直接创建(递归创建)mkdir dir1 dir2 #在当前目录创建dir1、dir2两个文件夹mkdir 当前目录的文件夹/dir3 #在目标路径下创建dir3mkdir admin/demo1/dir4 dir5 #dir4在demo1下，dir5在当前目录下mkdir demo2/dir6 demo2/dir7 #在demo2下创建dir6、dir7mkdir demo3/&#123;dir8,dir9&#125; #在demo3下创建dir8、dir9mkdir .dir10 #创建隐藏文件夹dir10# .代表当前目录，..代表上一级目录\n\n\n\n\ntouch命令touch file1.txt #创建单个文件touch file2 file3 file 4 #创建多个文件touch dir1/file1.txt 在规定路径下创建文件#touch要求在存在的目录下创建文件touch .abc #创建隐藏文件abcgedit file1.txt #记事本修改文件gedit file5.txt #不存在则新建file5并编辑\n\n\ngedit打开记事本\n\nrm命令rm file1 #删除file1rm dir1 -r #删除目录dir1rm * -r #将目录里的所有目录、文件删掉（隐藏文件除外）,如果目录里面有文件夹但是没有-r会报错rm .abc #删除隐藏文件abcrmdir #删除文件夹\n\n\n\n命令格式ctrl+c #结束命令（命令敲错了常用）command [-options] [parameter] #命令格式command --help #不知道命令怎么使用，窗口自带的命令不能使用，如pwdman pwd #查看命令说明文档\n\n\ncp命令cp 1.txt dir2 #将1.txt复制到dir2目录下cp 1.txt 2.txt #将1.txt复制到当前目录下并命名为2.txtcp -a 1.txt 3.txt #复制文件并保持原有属性,原有属性是指文件或目录的元数据，包括文件权限、所有者、所属组、创建时间、修改时间等信息。使用`cp -a`命令可以保持原有文件的所有这些属性。cp dir1 dir2 -r #复制目录和目录下的所有子目录与文件cp 1.txt 2.txt -i #交互式复制，覆盖会让用户确认cp ~/dir1 ~/dir2 -r #拷贝指定目录至指定目录下\n\n\n\n\nmv命令mv 1.txt abc.txt #移动到当前目录下并重命名（类似于重命名文件）mv abc.txt dir1 #将abc文件移动至dir1mv abc.txt dir1/abcrename.txt #将abc文件移动至dir1并改名为abcrenamemv dir1 dir2 #移动到当前目录下并重命名（类似于重命名文件夹）mv dir2 dir3 #将dir2移动到dir3目录下\n\n\n重定向#重定向ls &gt;1.txt #1.txt不存在则创建，存在则在内部内容编辑覆盖。ls返回的结果放入1.txt文件中ls &gt;&gt;1.txt #1.txt不存在则创建，存在则在内部内容编辑。ls返回的结果追加在1.txt文件中\n\n\ncat命令cat 1.txt #查看1.txt的内容cat 1.txt 2.txt #按顺序显示12的文件内容cat 1.txt 2.txt &gt; 3.txt #将1.tx和2.txt的内容合并到3.txt\n\nmore命令more 1.txt #查看文件1.txt，从文件开始显示，space向下翻一页，b往回翻一页，enter向下翻一行，按q键退出\n\n\nhead用于显示文件的开头内容。默认情况下，它显示文件的开头 10 行内容\n\n\nhead -15查看前15行内容\n\n\n\n\ntail用于显示文件的末尾内容。默认情况下，它显示文件的最后 10 行内容\n\n-n &lt;num&gt;：显示文件末尾的 &lt;num&gt; 行内容，例如 -n 20 表示显示最后 20 行。\n-f：实时跟踪文件的增长，在文件末尾显示新添加的内容，非常适用于查看日志文件。可以和数字组合，获取动态信息的某几行内容\n-c &lt;num&gt;：显示文件末尾的 &lt;num&gt; 字节内容，例如 -c 1000 表示显示最后 1000 字节。\n-q：禁止显示文件名。\n\n\n\n\n案例：动态查看模拟日志内容不断更新的场景\n\n\n管道：|command1 | command2:command1的返回结果由command2处理ls -al / | more #以more查看文件的方式查看/目录下的内容，b按钮没用，只能往下翻ps aux | grep &quot;firefox&quot; # 用ps命令查看系统中运行的进程并通过管道命令传递给grep来筛选sort file2 |uniq # sort对文件内容排序并通过uniq除去同步行tail -f log | grp &quot;error&quot; # 追踪日志，通过grep过滤关键字\n\n\n进程查看进程psps -e #显示系统中的所有进程ps -f #显示完整的进程信息-u #显示指定用户的进程-aux #显示所有进程的详细信息\n\n\n\n杀死进程killkill pid杀死该进程\nkill -9 pid强制结束\n\n\n命令行版任务管理器top动态的\n\n端口号HTTP：80\nHTTPS：443\nSSH:22\nMySQL：3306\nnetstat查看端口root能看到更详细的端口信息\nnetstat -anptu\n\npid一栏没有信息\n切换至root\n\n配合grep：\nlsoflsof -i列出符合条件的进程\nlsof -i:3306列出使用端口3306的进程信息\n\n链接\n软链接：不占用磁盘空间，源文件删除则软链接直接失效\n硬链接：只能链接普通文本，不能链接目录\n\n## 软链接ln -s 1.txt 1_soft_link #创建1.txt的软链接，名称叫1_soft_link#源文件改变，快捷方式也变。修改软连接相当于修改源文件，为源文件的别名#软链接不储存内容，只记录指向文件的名称rm 1.txt #源文件删除后，软链接会报红，无法查看（但是软链接还存在）touch 1.txt #新建与源文件重名的文件，软链接会重新指向新的同名文件ln -s /home/admin/demo1/1.txt ~/1_soft_link #在家目录里创建该目录下1.txt的软链接（软链接与源文件不在同一目录时，需指明源文件所在的路径）ln -s demo1 demo1_soft_link #在当前目录下创建demo1的软链接##硬链接 链接的内容改变，文件同步变化ln 1.txt 1_hard_link #当前目录下为1.txt创建硬链接#源文件删除，不影响硬链接#使用ll查看时，有一个数字代表有几个文字能同步发生变化\n\n\n\n\n\n\n\ngrep命令#一般格式为：grep [-options] &#x27;content&#x27; filenamegrep hello 1.txt #在1.txt里搜索hello（按行搜索，匹配到文字返回该行）grep -n hello 1.txt  #匹配内容及所在行grep -i hello 1.txt #不区分大小写进行匹配grep -v hello 1.txt #反向查找，过滤出不包含指定模式的行grep -n hello . -r #会在当前目录（包括子目录）中递归地搜索包含字符串 &quot;hello&quot; 的文件，并显示匹配的行，并显示匹配的行的行号。grep -n ^h 1.txt #匹配行以h开头的内容grep -n o$ 1.txt #匹配行以o结尾的内容# [] 匹配[]中任一字符grep h. 1.txt  #h后跟任何一个字符的行，整行显示\n\n\n\n\n\nfind命令查找文件名\n#一般格式为：find directory -name filenamefind . -name 2.txt #查找当前目录下2.txt所在的位置，会遍历所有的文件夹find ~ -name &#x27;*txt&#x27; #查找家目录下所有以txt结尾的文件 find . -type d -name &quot;hello&quot; #在当前目录及其子目录中查找名字为 &quot;hello&quot; 的文件夹，并将它们列出来。\n\n\ntar命令用于将多个文件打包成一个单独的文件（归档文件），通常以 .tar 为扩展名。它本身不具备压缩功能，但可以与 gzip、bzip2 等压缩工具结合使用，将打包的文件进行压缩，生成 .tar.gz 或 .tar.bz2 等格式的压缩文件。\n#创建打包文件，注意f要写在最后，指定档案文件名称tar -cf a.tar 2.txt 3.txt #将2.txt和3.txt打包到a.tar中,f-file。文件扩展名以tar结尾显示为红色tar cf a 2.txt 3.txt #将2.txt和3.txt打包到a.tar中#列出文件tar tf a.tar #列包tar xf a.tar #解包，文件会在当前目录下#####################tar cvf a.tar *txt #打包当前目录下所有txt文件，并展示过程tar xvf a.tar -C tar #将解压的文件放入当前目录下的tar目录中，但是没有tar目录不会自动生成\n\n给已打包好的tar文件重新打包会覆盖里面的文件\n\ngzip命令用于压缩文件，通常将文件压缩成 .gz 格式。它可以通过 gzip 命令进行压缩，通过 gunzip 或者 gzip -d 命令进行解压缩。\n#一般格式为：gzip [options] filegzip -r a.tar #-r压缩所有子目录，文件被压缩成新的文件a.tar.gzgzip -d a.tar.gz #解压文件\n\n\n一步压缩解压tar czf b.tar.gz *txt #打包压缩所有txt文件,并命令为b.tar.gztar xzf b.tar.gz -C btar #解压解包文件b.tar.gz并存放在btar文件夹中#bzip2用法tar jcf j.tar.bz2 *txt #打包压缩所有txt文件,并命令为j.tar.bz2tar xjf j.tar.bz2 -C jtar  #解压解包文件b.tar.bz2并存放在jtar文件夹中#zip、unzipzip -r zz *txt #将txt文件打包压缩成zz文件，会显示打包过程，生成文件扩展名为zipunzip -d zz zz.zip #解压zz.zip里的文件至zz文件夹中，若文件夹不存在先创建文件夹## 压缩率：zip&lt;gzip&lt;bzip2 ## 通用性：zip&gt;gzip&gt;bzip2###一般以gizp为主\n\n\n\n\n其他命令#which命令which zip #查看zip命令在的位置，命令是可执行的文件which mysql # 查看安装的文件位置# who命令 查看当前系统中登录的所有用户信息whoami #当前用户who# cd ls bash cp mv为shell命令#su命令 切换到root用户su #在命令行中切换至root用户su admin #su + username 切换成对应的用户#passwd命令passwd #更改当前用户的密码passwd admin #更改admin用户的密码#exit命令exit #安装用户的顺序退出命令行窗口#who命令who #查看当前登录的用户，tty表示用户登录操作系统，pts表示用户登录终端 #reboot、shutdown命令,reboot不需要root权限，shutdown需要root权限reboot #重启shutdown h +10#系统再过十分钟后自动关机 \n\n\n\n\nchmod命令#按字母修改chmod u/g/o/a +/-/= rwx file# u:user表示该文件的所有者# g:group表示与该文件所有者属于同一组者，即用户组# o:other表示其他以外的人# a:all表示这三者皆是# +:增加权限# -:减少权限# =:赋值新的权限chmod u+x test.txt #给拥有者对于test.txt增加可执行权限chmod u-r test.txt #减去可读权限chmod u=r test.txt #给拥有者赋予test.txt可读权限chmod u=rwx test.txtchmod u-w test.txtchmod u=- test.txt #不赋予任何权限chmod u+r,g-w,o=wx test.txt #分别赋予权限chmod a+w test.txt# 共同改变权限##数字修改# r-&gt;4# w-&gt;2# x-&gt;1# - -&gt;0chmod 666 test.txt #所有用户都有rw权限chmod 777 test.txt #所有用户都有rwx权限chmod 135 text.txt # x、wx、rx\n\nyum命令软件包管理工具\nyum list # 列出所有可安装的软件清单yum search # 查找软件包yum install # 安装yum update # 更新yum remove # 删除\n\n","categories":["os"],"tags":["Linux"]},{"title":"Markdown语法","url":"/2022/03/25/Markdown%E8%AF%AD%E6%B3%95/","content":"Markdown学习标题标题用 #+标题（中间要有空格）回车生成，有六级标题，一个#是一级标题，六#是六级标题。\n字体在文段内容，两边各加**就可以变成粗体，两边各加*就可以变成斜体，加***就会加粗斜体。在两边各加~~就会有中间划线的效果。\n引用\n引用效果 在开头加 &gt; 空格，表示语句是被引用的。\n\n分割线\n输入三个-再回车\n\n输入三个*再回车\n图片输入![图片的名字](图片的路径) \n  \n超链接wrinta\n[链接的名字](网址)\n列表有序列表输入数字英语句号空格，回车会出下一个。\n\nR\nint\na\n\n无序列表输入-再空格\n\na\nint\nR\n\n表格Typora可以通过鼠标右键的点击直接增加表格。\n通过|符号可以实现表格的生成，打出表头，用|分隔每一栏(开始和结尾也要有|)\n\n\n\n名字\n性别\n生日\n\n\n\n小狗\n男\n2111&#x2F;11&#x2F;1\n\n\n代码插入`&#96;&#96;回车表示要插入代码，右下角可以选择语言\nprintf(&quot;hello world!&quot;);\n\n","tags":["Markdown"]},{"title":"Python","url":"/2024/03/11/Python/","content":"Python介绍\npython常用于回归测试。\npython+selenium web自动化（功能测试转换为代码）\npython+appium 移动端（手机端app）自动化\npython+ requests 接口\n\nPython 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。python是轻量级语言。\nPython 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。\n\nPython 是一种解释型语言： 这意味着开发过程中没有编译这个环节。类似于PHP和Perl语言。\nPython 是交互式语言： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。\nPython 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。\nPython 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。\n\nPython基础代码标识符\n第一个字符必须是字母表中字母或下划线**_** ,不能以数字开头。\n驼峰命名法：\n​\t大驼峰（又称帕斯卡命名法Pascal Case）：通常用于标识符（如变量名、函数名、类名等）的命名。在帕斯卡命名法中，每个单词的首字母都大写，单词之间没有下划线或其他分隔符。：MyName\n​\t小驼峰（Camel Case）：通常用于命名变量、函数、方法等标识符。在小驼峰命名法中，除了第一个单词的首字母小写外，后续单词的首字母都大写，单词之间没有下划线或其他分隔符。，其他大写：myName\n​\t下划线连接法（Snake Case）：每个单词之间用下划线连接my_name\n\n变量一般使用下划线法\n\n标识符的其他的部分由字母、数字和下划线组成。\n\n标识符对大小写敏感。\n\n\n在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。\npython保留字\n&gt;[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;,&gt;&#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &gt;&#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;,&gt;&#x27;yield&#x27;]\n\n多行语句Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 ** 来实现多行语句，例如：\ntotal = item_one + \\        item_two + \\        item_three\n\n在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 ****，例如：\ntotal = [&#x27;item_one&#x27;, &#x27;item_two&#x27;, &#x27;item_three&#x27;,        &#x27;item_four&#x27;, &#x27;item_five&#x27;]\n\n数字类型\nint (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。\nbool (布尔), 如 True。\nfloat (浮点数), 如 1.23、3E-2\ncomplex (复数), 如 1 + 2j、 1.1 + 2.2j\n\n输出print()# print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=&quot;&quot;x = &quot;a&quot;y = &quot;b&quot;# 换行输出print(x)print(y)print(&#x27;---------&#x27;)# 不换行输出print(x, end=&quot; &quot;)print(y, end=&quot; &quot;)print()\n\n\n格式化输出print(&quot;%s&quot;,%str) #格式化输出字符串,%s可以填充任意类型的数据print(&quot;%d&quot;,%a) #有符号的的十进制数print(&quot;%06d&quot;,%b) #表示输出的整数显示位数，不足位以0补全，超出位数则原样输出print(&quot;%f&quot;,%c) #浮点数print(&quot;.2f&quot;,%d) #保留2位小数输出（四舍五入），小数默认显示6位print(&quot;%%&quot;) #输出%\n\nname = &#x27;ana&#x27;age = 18height = 1.752print(&quot;her name is %s,her age is %d,her height is %.2fm&quot; % (name, age, height))\n\n\nnum = 90print(&#x27;percentage %d%%&#x27; % num)\n\n\nF-string（f字符串的格式化方法）1. 需要在字符串前面加上f&quot;&quot;或者F&quot;&quot;2. 占位符号统一变为&#123;variable name&#125;3. 需要填充的变量写在&#123;&#125;\n\nstu_num = 1num = 90name = &#x27;ana&#x27;age = 19height = 1.821print(f&#x27;her name is &#123;name&#125;,age is &#123;age&#125;,height is &#123;height:.2f&#125;m,student number is &#123;stu_num:06d&#125;,percentage is &#123;num&#125;%&#x27;)\n\n\n输入inputa = input(&#x27;输入你心中想的内容：&#x27;)print(&quot;你输入的是&quot; + a)print(type(a))\n\n\n输入的内容类型是字符串类型\n类型转换a = input(&#x27;输入你的年龄：&#x27;)b = int(a)print(&quot;你的年龄是&quot;, b)print(&quot;一年后你的年龄是&quot;, int(a) + 1)print(type(a))print(type(b))\n\n\n\nint()可以将其他类型转换成int类型\n​\t可以将float类型转换成整型\n​\t可以将整数类型字符串转换为整型\n\n\nfloat()可以将其他类型转换成float类型\n\n可以将int类型转换成浮点型\n可以将数字类型字符串（整数、小数）转换为浮点型\n\n\nstr()可以将其他类型转换成字符串类型\n\n任何类型都可以使用str()将其转换成字符串，一般都是直接加引号\n\n\n\nimport与from…import在 python 用 import或者 from...import来导入相应的模块。\n\n将整个模块(somemodule)导入，格式为：import somemodule\n从某个模块中导入某个函数,格式为： from somemodule import somefunction\n从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc\n将某个模块中的全部函数导入，格式为： from somemodule import *\nimport somemodule as alias导入模块指定别名alias\n\npython中的三种波浪线和pep\n红色：表示代码的错误，代码没有写完也会出现\n\n灰色：不会影响代码的正常执行，pep8为代码的书写规范。可以在写完后使用ctrl+alt+L格式化\n\n\n\n\n绿色：在引号中，认为书写的内容不是英文单词时会出现\n\n\nPython基本数据类型Python 中的变量不需要声明。每个变量在使用前都必须赋值，如果事先不知道赋什么数值，可以先赋值None，variable = None进行初始化。变量赋值以后该变量才会被创建。\n在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。变量名在赋值时，实际上是将对象的引用（即内存地址）赋值给变量名。因此，变量名实际上是对象的引用，而不是直接对内存地址的引用。\nimport ctypesa = 12  # 变量a指向12的引用（12的内存地址）b = a  # 变量b指向变量a指向的引用，12print(&#x27;12的内存地址:&#x27;, id(a))print(&#x27;通过内存地址140714148648072访问值:&#x27;, ctypes.cast(140714148648072, ctypes.py_object).value)  # 12的内存地址print(&#x27;12的内存地址:&#x27;, id(b))a = 30  # 变量a指向新的引用，30print(&#x27;a现在指向30的内存空间，通过a访问&#x27;, a)print(&#x27;30的内存地址:&#x27;, id(a))print(&#x27;b仍然指向之前的引用&#x27;, b)  # b仍然指向之前的引用，12print(&#x27;b指向的内存地址&#x27;, id(b))\n\n\nPython允许你同时为多个变量赋值，连续赋值从右往左，分别赋值按位置进行赋值。例如：\na = b = c =1# 等同于：c = 1b = ca = ba,b,c=1,2,&#x27;hello&#x27;# 等同于：a = 1b = 2c = &#x27;hello&#x27;\n\n标准数据类型Python3 中常见的数据类型有：\n\nNumber（数字）\n\n整数（int）： 表示整数值，例如 42 或 -10。\n浮点数（float）： 表示带有小数点的数值，例如 3.14 或 -0.001。\n\n\nString（字符串）：表示文本数据，用单引号 &#39; &#39; 或双引号 &quot; &quot; 括起来，例如 &#39;hello&#39; 或 &quot;world&quot;。\n\nbool（布尔类型）：表示逻辑值，只有两个值：True 和 False。\n\nList（列表）：表示有序的可变集合，可以包含任意类型的元素，例如 [1, 2, &#39;hello&#39;]。\n\nTuple（元组）： 表示有序的不可变集合，可以包含任意类型的元素，例如 (1, 2, &#39;hello&#39;)。\n\nSet（集合）：表示无序的不重复元素的集合，例如 &#123;1, 2, 3&#125;。\n\nDictionary（字典）：表示键值对的集合，其中每个键都对应一个值，例如 &#123;&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 30&#125;。\n\nNoneType（空值）： 表示空值或者缺失值，用 None 表示。\n\nbytes（字节串）： 表示二进制数据，例如 b&#39;hello&#39;。\n- \n\nimport sys\n\ns = &quot;hello&quot;\nb = b&#39;hello&#39;\nprint(sys.getsizeof(s))  # 获取字符串对象 s 占用的内存空间大小\nprint(sys.getsizeof(b))  # 获取字符串对象 b 占用的内存空间大小\n    ![](image-20240403135732256.png)Python3 的六个标准数据类型中：- **不可变类型（3 个）：**可变类型在创建后其内容无法被修改，每次对不可变类型进行操作时，都会创建一个新的对象  Number（数字）、String（字符串）、Tuple（元组）；- **可变类型（3 个）：**在 Python 中，可变类型是指可以在创建后修改其内容的数据类型。可变类型的数据结构在内存中的内容可以改变，而不会改变其在内存中的地址。这意味着，对可变类型对象进行操作时，不会创建新的对象，而是直接修改原始对象。  List（列表）、Dictionary（字典）、Set（集合）。- - ```python  list1 = [1, 2, 3]  print(&#x27;list1的内存地址：&#x27;, id(list1))  print(&#x27;list1[0]:1的内存地址：&#x27;, id(list1[0]))  print(&#x27;list1[1]:2的内存地址：&#x27;, id(list1[1]))  print(&#x27;list1[2]:3的内存地址：&#x27;, id(list1[2]))  list1.append(5)  print(&#x27;list1的内存地址：&#x27;, id(list1))  list1 = [1, 3, 4]  # 指向了一个新的列表对象，原来的列表对象因为没有变量指向它，会被回收  print(&#x27;list1的内存地址：&#x27;, id(list1))  print(&#x27;list1[0]:1的内存地址：&#x27;, id(list1[0]))  print(&#x27;list1[1]:3的内存地址：&#x27;, id(list1[1]))  print(&#x27;list1[2]:4的内存地址：&#x27;, id(list1[2]))  x = 42  print(&#x27;x的内存地址&#x27;, id(x))  print(&#x27;x+1的内存地址&#x27;, id(x + 1))\n\n\n\n\n\n\nnumber数字Python3 支持 int、float、bool、complex（复数）。\n注意：\n\n数值的除法包含两个运算符：**&#x2F;** 返回一个浮点数，**&#x2F;&#x2F;** 返回一个整数。\n\n\n\n在混合计算时，Python会把整型转换成为浮点数。\n\n\n\n\n查看类型type()\ntype(obj) 函数返回对象 obj 的类型对象。\n例如，type(5) 返回 &lt;class &#39;int&#39;&gt;，表示整数对象的类型是 int 类型。\n\na,b,c,d=2,3.14,True,3+4jprint(type(a),type(b),type(c),type(d))\n\n\nisinstance()\nisinstance(obj, classinfo) 函数用于检查对象 obj 是否是指定类型 classinfo 的实例，或者是其子类的实例。\nclassinfo 参数可以是类型对象、类型元组或类型列表。如果 obj 是 classinfo 类型的实例或其子类的实例，则返回 True；否则返回 False。\n例如，isinstance(5, int) 返回 True，表示整数对象 5 是 int 类型的实例。\n\nprint(isinstance(a,int))\n\n一定要注意二者的区别和使用方法class A():    passclass B(A):    passa = A()b = B()print(type(a))print(type(b))print(isinstance(b, A))print(isinstance(b, B))\n\n\nString字符串\nPython 中单引号 ‘ 和双引号 “ 使用完全相同。\n\n使用三引号**’’’** 或 **”””**可以指定一个多行字符串。\n\n\n转义符\\。\n\n反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n 会显示，并不是换行。\n按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。\n字符串可以用 + 运算符连接在一起，用 ***** 运算符重复。\n\nprint(&#39;123\\n123&#39;)\nprint(r&#39;123\\n123&#39;)\nprint(&#39;this&#39;&#39;is&#39;&#39;a&#39;&#39;string&#39;)\nprint(&#39;a&#39; + &#39;bc&#39;)\nprint(&#39;a&#39; * 5)\n  - ![](image-20240403153219978.png)- Python 中的字符串有两种索引方式，从左往右以 **0** 开始，从右往左以 **-1** 开始。- Python 中的字符串不能改变。- Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。```pythonword = &#x27;字符串&#x27;sentence = &quot;这是一个句子。&quot;paragraph = &quot;&quot;&quot;这是一个段落，可以由多行组成&quot;&quot;&quot;\n\n\n\n\n\n字符串的截取字符串的截取的语法格式如下：\n变量[头下标:尾下标]\n索引值以 0 为开始值，-1 为从末尾的开始位置。\n尾下标对应的字符不包含\n\nstr = &#x27;abcdefghijk&#x27;print(str)print(&quot;输出字符串第一个字符：&quot; + str[0])print(&quot;输出字符串最后一个字符：&quot; + str[-1])print(&quot;输出字符串第一个到第3个字符：&quot; + str[0:3])print(&quot;输出字符串第一个到倒数第二个个字符：&quot; + str[0:-1])print(&quot;输出字符串第一个到第3个字符：&quot; + str[:3])print(&quot;从字符串倒数第三个字符开始输出：&quot; + str[-3:])print(&quot;字符串的每个字符间隔1个输出（步长为2）：&quot; + str[::2])print(&quot;字符串输出2次：&quot; + str * 2)print(&quot;字符串拼接输出：&quot; + &#x27;你好&#x27; + str)print(&quot;反转字符串：&quot; + str[::-1])print(&#x27;hello\\npython&#x27;)print(r&#x27;hello\\npython&#x27;)\n\n\n相关函数len()len()可以用来获取字符串长度\n\n查找方法find()字符串.find(sub_str,start,end)# 在字符串中查找是否存在sub_str这样的字符串# start默认为0# end默认是len()返回结果：1. 找到了，返回第一次出现的下标（sub_str第一个字符在字符串中的下标）2. 没有找到，返回-1\n\nstr = &#x27;abcdefghijk&#x27;print(str.find(&#x27;abc&#x27;))\n\n\nstr = &#x27;ana and luke and lei&#x27;num = str.find(&#x27;and&#x27;)# 查找第2个and出现的位置print(str.find(&#x27;and&#x27;, num + 1))\n\n\n# 过7游戏for i in range(1, 100):    if i % 7 == 0 or str(i).find(&#x27;7&#x27;) != -1:        print(&quot;过&quot;)    else:        print(i)\n\n\n字符串替换replace()字符串.replace(old_str,new_str,count)# 将old_str替换成new_str# count：替换的次数，默认全部替换# 返回替换之后的完整字符串，原来的字符串没有发生改变\n\n# 将str1中所有的g改为Gstr1 = &#x27;good good study&#x27;str2 = str1.replace(&#x27;g&#x27;, &#x27;G&#x27;)print(&quot;str1=&quot;, str1)print(&quot;str2=&quot;, str2)\n\n\n# 将str1中第一个good改成GOODstr1 = &#x27;good good study&#x27;str2 = str1.replace(&#x27;good&#x27;, &#x27;GOOD&#x27;,1)print(&quot;str1=&quot;, str1)print(&quot;str2=&quot;, str2)\n\n\n# 将str1中第二个good改成GOODstr1 = &#x27;good good study&#x27;str2 = str1.replace(&#x27;good&#x27;, &#x27;GOOD&#x27;, )str3 = str2.replace(&#x27;GOOD&#x27;, &#x27;good&#x27;, 1)print(&quot;str2=&quot;, str2)print(&quot;str3=&quot;, str3)\n\n\n字符串的拆分spilt()字符串.split.(sep,maxsplit)# 将字符串按照sep进行拆分，默认为空白字符（空格，换行\\n，tab键\\t）# max_spilt:分隔次数，默认全部分隔# 返回：将一个字符串拆分成多个存在列表中# 注意：sep不写，想要指定分割次数，写法如：字符串.spilt(maxspilt=n)\n\nstr = &quot;Hello,my name is Elora&quot;list1 = str.split()print(list1)print(str.split(maxsplit=1))\n\n\n字符串的连接join()字符串1.join(列表) # 括号中的内容主要是列表，可以是其他容器# 将字符串插入到列表中每相邻的两个数据之间，组成一个新的字符串# 注意：列表中的数据必须都是字符串类型，否则会报错\n\nlist1 = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;you&#x27;]str1 = &#x27; &#x27;.join(list1)print(str1)str2 = &#x27; and &#x27;.join(list1)print(str2)\n\n\n字符串格式化字符串.format()1. 在需要使用变量的地方使用&#123;&#125;占位2. &#x27;&#123;&#125;,&#123;&#125;...&#x27;.format(变量,变量)...\n\nstu_num = 1num = 90name = &#x27;ana&#x27;age = 19height = 1.821print(&#x27;her name is &#123;&#125;,age is &#123;&#125;,height is &#123;:.2f&#125;m,student number is &#123;:06d&#125;,percentage is &#123;&#125;%&#x27;.format(name, age, height, stu_num, num))\n\n\nname = &#x27;Alice&#x27;age = 30# 位置参数：message = &#x27;My name is &#123;0&#125; and I am &#123;1&#125; years old.&#x27;.format(name, age)print(message)# 关键字参数：message = &#x27;My name is &#123;name&#125; and I am &#123;age&#125; years old.&#x27;.format(name=&#x27;Alice&#x27;, age=30)print(message)# 格式化输出：pi = 3.14159formatted_pi = &#x27;The value of pi is &#123;:.2f&#125;&#x27;.format(pi)print(formatted_pi)  # 输出: The value of pi is 3.14# 索引和命名参数混合使用：message = &#x27;My name is &#123;0&#125; and I am &#123;age&#125; years old.&#x27;.format(name, age=30)print(message)\n\n\nbool布尔类型在 Python 中，True 和 False 都是关键字，表示布尔值。\n布尔类型特点：\n\n布尔类型只有两个值：True 和 False。\n布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。\n布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值。\n布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0。\n\n注意: 在 Python 中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 0、空字符串、空列表、空元组等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。\nlist列表\n列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（嵌套）。\n列表是写在方括号 [] 之间、用逗号分隔开的元素列表。\n和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。截取的语法格式：变量[头下标:尾下标]\n\n索引值以 0 为开始值，**-1** 为从末尾的开始位置。\n\nlist1 = list()  # 定义一个空的列表# list(容器)将其他容器转换成列表print(list(&#x27;hello&#x27;))\n\n\nlist1 = list()  # 定义一个空的列表# list(容器)将其他容器转换成列表print(list(&#x27; h ello&#x27;))\n\n\n列表的切片list1 = [&#x27;abcd&#x27;, 78910, 2.233333, &#x27;hello&#x27;, 351]tinylist1 = [123, &#x27;abcdefg&#x27;]print(list1)print(tinylist1)print(&quot;打印整个列表:&quot;, end=&#x27; &#x27;)print(list1)print(&quot;打印列表的第一个元素：&quot;, end=&#x27; &#x27;)print(list1[0])print(&quot;打印列表第二到第三个元素（包含第三个元素）:&quot;, end=&#x27; &#x27;)print(list1[1:3])print(&quot;打印列表第二到第三个元素（不包含第三个元素）:&quot;, end=&#x27; &#x27;)print(list1[1:2])print(&quot;打印列表第二个元素:&quot;, end=&#x27; &#x27;)print(list1[1])print(&quot;打印列表第三个元素到末尾:&quot;, end=&#x27; &#x27;)print(list1[2:])print(&quot;打印tiny列表两次&quot;, end=&#x27; &#x27;)print(tinylist1 * 2)print(&quot;打印两个列表&quot;, end=&#x27; &#x27;)print(tinylist1 + list1)print(&quot;打印两个列表合并后第二个到第五个元素&quot;, end=&#x27; &#x27;)print((tinylist1 + list1)[1:6])print(&quot;逆转list&quot;, end=&#x27; &#x27;)print(list1[::-1])\n\n\n列表查询相关操作数据下标index()列表.index(el,start,end)# 使用和find方法一样# 区别：index()方法，找到返回第一次出现的下标，没有找到直接报错,find()则是返回-1\n\nmylist = [1, 3, 5, 7, 2, 3]num = mylist.index(3)print(&quot;出现3的下标是：&quot;, num)print(&quot;出现4的下标是：&quot;, mylist.index(4))\n\n\n判断是否存在in()el in 容器# 存在返回True，不存在返回False\n\n\n统计出现次数count()列表.count(el)# 返回元素出现的次数，没有返回数字0\n\n\n列表修改数据# 直接更改list元素值list1 = [&#x27;abcd&#x27;, 78910, 2.233333, &#x27;hello&#x27;, 351]list1 = [12321]  # list1=[12321]list1[1:3] = [&#x27;a&#x27;, &#x27;b&#x27;]list1[3:4] = [444]print(list1)\n\n\nlist1 = [&#x27;abcd&#x27;, 78910, 2.233333, &#x27;hello&#x27;, 351]list1[0] = 12321list1[1:3] = [&#x27;a&#x27;, &#x27;b&#x27;]list1[3:4] = [444]print(list1)\n\n\n列表添加数据尾部添加（最常用）列表.append(数据)# 返回：返回的None（关键字，空），一般就不再使用变量保存返回内容# 查看打印列表，表示返回值\n\n指定下标位置添加列表.insert(下标,数据)# 在指定的下标位置添加数据，如果指定的下标位置有数据，原数据后移# 返回：返回的None（关键字，空），一般就不再使用变量保存返回内容# 查看打印列表，表示返回值\n\nmylist = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;and&#x27;]mylist.append(&#x27;you&#x27;)print(mylist)mylist.insert(1, &#x27;Lily&#x27;)print(mylist)mylist.append([&#x27;him&#x27;, &#x27;and&#x27;])print(mylist)mylist.insert(1, [&#x27;Manny&#x27;, &#x27;Sue&#x27;])print(mylist)\n\n\n\n\n列表合并extend()列表1.extend(列表2) # 将列表2中的所有数据逐个添加到列表1的尾部，不会改变列表1的内存地址# 返回：返回的None（关键字，空），一般就不再使用变量保存返回内容# 查看打印列表，表示返回值\n\n# list2拆开添加到mylistmylist = [&#x27;我&#x27;, &#x27;爱&#x27;]list2 = list(&#x27;螺蛳粉&#x27;)mylist.extend(list2)print(mylist)#list2作为整体加入mylist中mylist.append(list2)print(mylist)\n\n\n列表删除在列表中删除中间的数据，后面的数据会向前移动\n根据下标删除列表.pop(下标) #删除指定下标对应的数据# 下标不写，默认删除最后的数据# 存在的下标，删除对应下标位置的数据，不存在的下标，报错IndexError# 返回删除的数据del.列表[下标]\n\n根据数据值删除列表.remove(数据) # 返回None# 若删除的数据不存在，会报错# 重复的数据删除第一个，想要删除多个进行循环\n\nlist1=[&#x27;h&#x27;,&#x27;h&#x27;,&#x27;h&#x27;,&#x27;h&#x27;,&#x27;h&#x27;,&#x27;h&#x27;,&#x27;h&#x27;,&#x27;h&#x27;,&#x27;h&#x27;,&#x27;h&#x27;,&#x27;o&#x27;,&#x27;l&#x27;]while &#x27;h&#x27; in list1:    list1.remove(&#x27;h&#x27;)    print(list1)\n\n\n清空数据（一般不用）列表.clear()\n\n列表的反转和逆置1. 列表[::-1] # 得到一个新列表，原列表不会改变2. 列表.reverse() # 直接修改原列表，返回reverse,列表的内存地址不变\n\nlist1=list(&#x27;hello&#x27;)print(id(list1))list1.reverse()print(list1)print(id(list1))\n\n\n列表的复制# 使用场景，修改列表中的数据与修改之前的原始数据进行对比1. 使用切片变量 = 列表[:]2. 使用copy方法变量 = 列表.copy()列表1 = 列表2 # 会创建一个新的列表对象，并将 list2 中的元素复制到新的列表对象中。这样做会使得 list1 和 list2 指向不同的内存空间，即它们是两个独立的列表对象。list1 和 list2 是两个不同的变量，它们分别指向两个不同的列表对象，这两个列表对象中的元素相同，但是它们在内存中的地址是不同的。\n\nlist1=[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]list2=[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]list3=list1.copy()print(id(list1))print(id(list2))print(list3)print(id(list3))\n\n\n列表的排序列表的排序一般是针对数字进行排序\n列表.sort() # 按照升序排序列表.sort(reverse=True) # 降序排序\n\n列表去重去除列表中重复的数据\n错误示范my_list = [1, 23, 33, 11, 2, 23, 3, 2, 1, &#x27;3&#x27;, 3]for i in my_list:    while (my_list.count(i) &gt; 1):        my_list.remove(i)print(my_list)\n\n\n当检测到列表中该数据需要删除时，列表后方数据会向前移动，所以紧跟在被删除数据后方的元素会不参与遍历\n正确示范思想：放入新容器my_list = [1, 23, 33, 11, 2, 23, 3, 2, 1, &#x27;3&#x27;, 3]new_list=[]for i in my_list:    if i not in new_list:        new_list.append(i)    else:        continueprint(new_list)\n\n\n利用集合set特点\n缺点：不能保证数据在原列表中的顺序（一般不考虑）\n元组tuple\nPython 的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号 **( )**，列表使用方括号 **[ ]**。\n\n元组一般在函数的传参或者返回值中使用，保证数据不会被修改\n\n\nmytuple = tuple(list) #将列表转化为元组mytuple1 = tuple(str) #将字符串转化为元组\n\n元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用：\ntuple1 = (1)tuple2 = (1,)print(type(tuple1), tuple1)print(type(tuple2), tuple2)\n\n\n元组的常用方法\n没有修改方法\n元组中可以使用下标和切片获取数据\n元组中存在index方法\n元组中存在count方法\n可以使用in操作\n\n字典\n字典是另一种可变容器模型，且可存储任意类型对象。\n字典的每个键值 key&#x3D;&gt;value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示：\n\n变量 = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;\n\n\n键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变类型，键一般是字符串，可以是数字，不能是列表。\n字典不能转化成列表、元组和字符串\n\n# 创建空的字典dict1dict1 = &#123;&#125;print(type(dict1), dict1)# 创建空的字典dict2dict2 = dict()print(type(dict2), dict2)dict3 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: &#x27;32&#x27;, &#x27;height&#x27;: &#x27;1.78&#x27;, &#x27;is married&#x27;: True, &#x27;hobbies&#x27;: [&#x27;painting&#x27;, &#x27;music&#x27;]&#125;print(dict3)print(len(dict3)) # 却决于键的个数\n\n\n字典的增加修改字典[键]=数据值1. 如果键已经存在，就是修改数据值2. 如果键不存在，就是添加数据（即添加键值对）\n\ndict1 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: 32, &#x27;height&#x27;: &#x27;1.78&#x27;, &#x27;is married&#x27;: True, &#x27;hobbies&#x27;: [&#x27;painting&#x27;, &#x27;music&#x27;]&#125;print(dict1)dict1[&#x27;gender&#x27;] = &#x27;female&#x27;print(dict1)dict1[&#x27;age&#x27;] = 33print(dict1)dict1[&#x27;hobbies&#x27;].append(&#x27;studying&#x27;)print(dict1)\n\n\nlist1 = []for i in range(0, 3):    dict1 = &#123;&#125;    dict1[&#x27;name&#x27;] = input(&quot;请输入姓名&quot;)    dict1[&#x27;age&#x27;] = input(&quot;请输入年龄&quot;)    list1.append(dict1)print(list1)\n\n\n字典的删除\n删除指定的键值对\n\ndel 字典[键]字典.pop(键)\n\ndict1 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: &#x27;32&#x27;, &#x27;height&#x27;: &#x27;1.78&#x27;, &#x27;is married&#x27;: True, &#x27;hobbies&#x27;: [&#x27;painting&#x27;, &#x27;music&#x27;],         &#x27;gender&#x27;: &#x27;female&#x27;&#125;del dict1[&#x27;gender&#x27;]print(dict1)dict1.pop(&#x27;age&#x27;)print(dict1)dict1[&#x27;hobbies&#x27;].pop(0)print(dict1)dict1[&#x27;hobbies&#x27;].remove(&#x27;music&#x27;)print(dict1)dict1.clear()print(dict1)\n\n\n\n清空\n\n字典.clear()\n\n字典的查询字典中没有下标，要获取数据需要使用键来获取\n\n使用字典[键]\n# 字典[键]# 如果键存在，返回对应数据值# 如果键不存在，报错\n\n\n\n使用字典.get(键)\n字典.get(键,数据值)# 数据值一般不写，默认None# 如果键存在，返回对应数据值# 如果键不存在，返回括号中书写的数据值（None）\n\ndict1 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: &#x27;32&#x27;, &#x27;height&#x27;: &#x27;1.78&#x27;, &#x27;is married&#x27;: True, &#x27;hobbies&#x27;: [&#x27;painting&#x27;, &#x27;music&#x27;]&#125;print(dict1[&#x27;name&#x27;])print(dict1.get(&#x27;name&#x27;))print(dict1.get(&#x27;gender&#x27;))print(dict1.get(&#x27;gender&#x27;, &#x27;secret&#x27;))print(dict1[&#x27;hobbies&#x27;][0])print(dict1.get(&#x27;hobbies&#x27;)[0])print(dict1.get(&#x27;address&#x27;,&#x27;no info&#x27;))\n\n\n字典的遍历对字典的键进行遍历1. for key in 字典:\tprint(key)2. for key in 字典.keys():  # 字典.keys()可以获取字典中所有的键\tprint(key)\n\n对值进行遍历for value in 字典.values():  # 字典.values()可以获取字典中所有的值    print(value) # 输出值\n\n对键值对进行遍历for k, v in 字典.items(): # 字典.items()可以获取字典中所有键值对    print(k,v) # 输出键值对\n\ndict1 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: &#x27;32&#x27;, &#x27;height&#x27;: &#x27;1.78&#x27;&#125;# 遍历字典的键for k in dict1:    print(k)for k in dict1.keys():    print(k)# 遍历字典的值print(&#x27;-&#x27; * 30)for v in dict1.values():    print(v)print(&#x27;-&#x27; * 30)for k, v in dict1.items():    print(k, v)\n\n\n容器总结\n字符串，列表，元组支持加法运算\n字符串、列表、元组支持乘上一个整数\nlen()在容器中（str、list、dict、tuple）都可以使用\nin 在容器中都可以使用，在字典中判断字典的key是否存在\n\nmy_list = [&#123;&#x27;id&#x27;: 1, &#x27;money&#x27;: 10&#125;, &#123;&#x27;id&#x27;: 2, &#x27;money&#x27;: 20&#125;,&#123;&#x27;id&#x27;: 3, &#x27;money&#x27;: 30&#125;,&#123;&#x27;id&#x27;: 4, &#x27;money&#x27;: 40&#125;]def func():    for element in my_list:        if element[&#x27;id&#x27;] % 2 == 0:            element[&#x27;money&#x27;] += 10        else:            element[&#x27;money&#x27;] += 20func()print(my_list)\n\n\nmy_dict = &#123;&#x27;登录&#x27;: [&#123;&#x27;desc&#x27;: &#x27;正确的用户名密码&#x27;, &#x27;username&#x27;: &#x27;admin&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;, &#x27;expect&#x27;: &#x27;登录成功&#x27;&#125;,                    &#123;&#x27;desc&#x27;: &#x27;错误的用户名&#x27;, &#x27;username&#x27;: &#x27;root&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;, &#x27;expect&#x27;: &#x27;登录失败&#x27;&#125;,                    &#123;&#x27;desc&#x27;: &#x27;错误的密码&#x27;, &#x27;username&#x27;: &#x27;admin&#x27;, &#x27;password&#x27;: &#x27;123123&#x27;, &#x27;expect&#x27;: &#x27;登录失败&#x27;&#125;,                    &#123;&#x27;desc&#x27;: &#x27;错误的用户名和密码&#x27;, &#x27;username&#x27;: &#x27;aaa&#x27;, &#x27;password&#x27;: &#x27;123123&#x27;, &#x27;expect&#x27;: &#x27;登录失败&#x27;&#125;],           &#x27;注册&#x27;: [&#123;&#x27;desc&#x27;: &#x27;注册1&#x27;, &#x27;username&#x27;: &#x27;abcd&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;&#125;,                    &#123;&#x27;desc&#x27;: &#x27;注册1&#x27;, &#x27;username&#x27;: &#x27;xyz&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;&#125;]&#125;opt = input(&quot;请输入信息：登录/注册&quot;)  # 获取测试人员的信息info_list = []if opt == &#x27;登录&#x27;:    print(&quot;获取登录数据&quot;)    for i in my_dict.get(&#x27;登录&#x27;):        my_tuple = (i.get(&#x27;username&#x27;), i.get(&#x27;password&#x27;), i.get(&#x27;expect&#x27;))        info_list.append(my_tuple)    print(info_list)elif opt == &#x27;注册&#x27;:    print(&quot;获取注册数据&quot;)    for i in my_dict.get(&#x27;注册&#x27;):        my_tuple = (i.get(&#x27;username&#x27;), i.get(&#x27;password&#x27;))        info_list.append(my_tuple)    print(info_list)else:    print(&quot;输入错误&quot;)\n\n\n\nPython运算符算术运算符以下假设变量 a&#x3D;10，变量 b&#x3D;21：\n\n\n\n运算符\n描述\n实例\n\n\n\n+\n加 - 两个对象相加\na + b 输出结果 31\n\n\n-\n减 - 得到负数或是一个数减去另一个数\na - b 输出结果 -11\n\n\n*\n乘 - 两个数相乘或是返回一个被重复若干次的字符串\na * b 输出结果 210\n\n\n&#x2F;\n除 - x 除以 y（返回浮点类型）\nb &#x2F; a 输出结果 2.1\n\n\n%\n取模 - 返回除法的余数\nb % a 输出结果 1\n\n\n**\n幂 - 返回x的y次幂\na**b 为10的21次方\n\n\n&#x2F;&#x2F;\n取整除 - 往小的方向取整数\n&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5\n\n\n优先级：() &gt; ** &gt; * &#x2F; &#x2F;&#x2F; % &gt; + -\n比较运算符以下假设变量 a 为 10，变量 b 为20：\n\n\n\n运算符\n描述\n实例\n\n\n\n&#x3D;&#x3D;\n等于 - 比较对象是否相等\n(a &#x3D;&#x3D; b) 返回 False。\n\n\n!&#x3D;\n不等于 - 比较两个对象是否不相等\n(a !&#x3D; b) 返回 True。\n\n\n&gt;\n大于 - 返回x是否大于y\n(a &gt; b) 返回 False。\n\n\n&lt;\n小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。\n(a &lt; b) 返回 True。\n\n\n&gt;&#x3D;\n大于等于 - 返回x是否大于等于y。\n(a &gt;&#x3D; b) 返回 False。\n\n\n&lt;&#x3D;\n小于等于 - 返回x是否小于等于y。\n(a &lt;&#x3D; b) 返回 True。\n\n\n逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:\n\n\n\n运算符\n逻辑表达式\n描述\n实例\n\n\n\nand\nx and y\n布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。当第一个条件为False时，第二个条件不判断\n(a and b) 返回 20。\n\n\nor\nx or y\n布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。当第一个条件为True，第二个条件不再判断\n(a or b) 返回 10。\n\n\nnot\nnot x\n布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。\nnot(a and b) 返回 False\n\n\n当数字不是0时，都表示True\n赋值运算符以下假设变量a为10，变量b为20：\n\n\n\n运算符\n描述\n实例\n\n\n\n&#x3D;\n简单的赋值运算符\nc &#x3D; a + b 将 a + b 的运算结果赋值为 c\n\n\n+&#x3D;\n加法赋值运算符\nc +&#x3D; a 等效于 c &#x3D; c + a\n\n\n-&#x3D;\n减法赋值运算符\nc -&#x3D; a 等效于 c &#x3D; c - a\n\n\n*&#x3D;\n乘法赋值运算符\nc *&#x3D; a 等效于 c &#x3D; c * a\n\n\n&#x2F;&#x3D;\n除法赋值运算符\nc &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a\n\n\n%&#x3D;\n取模赋值运算符\nc %&#x3D; a 等效于 c &#x3D; c % a\n\n\n**&#x3D;\n幂赋值运算符\nc * *&#x3D; a 等效于 c &#x3D; c ** a\n\n\n&#x2F;&#x2F;&#x3D;\n取整除赋值运算符\nc &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a\n\n\n:&#x3D;\n海象运算符，这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。Python3.8 版本新增运算符。\n在这个示例中，赋值表达式可以避免调用 len() 两次:print(n:=10)输出结果：10\n\n\n成员运算符\n\n\n运算符\n描述\n实例\n\n\n\nin\n如果在指定的序列中找到值返回 True，否则返回 False。\nx 在 y 序列中 , 如果 x 在 y 序列中返回 True。\n\n\nnot in\n如果在指定的序列中没有找到值返回 True，否则返回 False。\nx 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。\n\n\n条件控制if elif elseif condition_1:    statement_block_1elif condition_2:    statement_block_2else:    statement_block_3\n\nage = input(&#x27;输入你的年龄：&#x27;)if int(age) &gt;= 18:    print(&quot;满18岁了可以去网吧&quot;)else:    print(&quot;未成年不能进入网吧&quot;)\n\n\nname = input(&#x27;输入你的用户名：&#x27;)if name == &#x27;admin&#x27;:    print(&quot;admin登录成功！&quot;)elif name == &#x27;test&#x27;:    print(&quot;test登录成功！&quot;)else:    print(&quot;登陆失败！&quot;)name = input(&#x27;输入你的用户名：&#x27;)if name == &#x27;admin&#x27; or name == &#x27;test&#x27;:    print(&quot;%s登陆成功！&quot; % name)else:    print(&quot;登陆失败！&quot;)\n\n\ndate = input(&quot;输入今天是星期几：&quot;)if date == &#x27;1&#x27;:    print(&quot;今天要去上班&quot;)elif date == &#x27;2&#x27;:    print(&quot;才上了一天班呢&quot;)elif date == &#x27;3&#x27;:    print(&quot;到周中了&quot;)elif date == &#x27;4&#x27;:    print(&quot;今天是疯狂星期四&quot;)elif date == &#x27;5&#x27;:    print(&quot;明天就放假了！&quot;)elif date == &#x27;6&#x27;:    print(&quot;放假第一天&quot;)elif date == &#x27;7&#x27;:    print(&quot;明天就上班了&quot;)else:    print(&quot;你输入错误了&quot;)\n\n\nif嵌套num = int(input(&quot;请输入一个整数&quot;))if num % 2 == 0:    if num % 3 == 0:        print(&quot;数字%d可以整除2和3&quot; % num)    else:        print(&quot;数字%d可以整除2，不能整除3&quot; % num)else:    if num % 3 == 0:        print(&quot;数字%d可以整除3，不能整除2&quot; % num)    else:        print(&quot;数字%d既不能整除2也不能整除3&quot; % num)\n\n\nmatch…casematch subject:    case &lt;pattern_1&gt;:        &lt;action_1&gt;    case &lt;pattern_2&gt;:        &lt;action_2&gt;    case &lt;pattern_3&gt;:        &lt;action_3&gt;    case _:        &lt;action_wildcard&gt;\n\ndef http_error(status):    match status:        case 400:            return &quot;Bad request&quot;        case 404:            return &quot;Not found&quot;        case 418:            return &quot;I&#x27;m a teapot&quot;        case 401 | 403 | 404:            return &quot;Not allowed&quot;        case _: # 用于捕获所有未被显式匹配的情况，简单地表示“其他所有情况”            return &quot;Something&#x27;s wrong with the internet&quot;mystatus=int(input(&#x27;输入状态码&#x27;))print(http_error(mystatus))\n\n\n猜拳游戏import randomwhile True:    player = input(&quot;剪刀石头布，你出什么，想要退出输入0&quot;)    if player == &#x27;0&#x27;:        break    randomid = random.randint(0, 2)  # 产生0-2之间的随机整数，包含0和2    listcom = [&#x27;剪刀&#x27;, &#x27;石头&#x27;, &#x27;布&#x27;]    computer = listcom[randomid]    match computer:        case &#x27;剪刀&#x27;:            print(&quot;电脑出的是%s&quot; % computer)            print(&quot;你出的是%s&quot; % player)            match player:                case &#x27;剪刀&#x27;:                    print(&quot;平局！&quot;)                case &#x27;石头&#x27;:                    print(&quot;你赢了！&quot;)                case &#x27;布&#x27;:                    print(&quot;你输了！&quot;)                case _:                    print(&quot;出错了！&quot;)        case &#x27;石头&#x27;:            print(&quot;电脑出的是%s&quot; % computer)            print(&quot;你出的是%s&quot; % player)            match player:                case &#x27;剪刀&#x27;:                    print(&quot;你输了！&quot;)                case &#x27;石头&#x27;:                    print(&quot;平局！&quot;)                case &#x27;布&#x27;:                    print(&quot;你赢了！&quot;)                case _:                    print(&quot;出错了！&quot;)        case &#x27;布&#x27;:            print(&quot;电脑出的是%s&quot; % computer)            print(&quot;你出的是%s&quot; % player)            match player:                case &#x27;剪刀&#x27;:                    print(&quot;你赢了！&quot;)                case &#x27;石头&#x27;:                    print(&quot;你输了！&quot;)                case &#x27;布&#x27;:                    print(&quot;平局！&quot;)                case _:                    print(&quot;出错了！&quot;)\n\n\n循环语句while循环while 判断条件(condition)：    执行语句(statements)……\n\n死循环和无限循环\n死循环：bug造成的\n无限循环：while true，故意设计的。应用场景：书写循环时，不确定循环要执行多少次。无限循环的使用一般会在循环中添加if判断，当if条件成立，使用关键字break终止循环\n\nwhile# 1到100的数字之和i = 1sum = 0while (i &lt;= 100):    sum = sum + i    i = i + 1print(sum)\n\n\n# 1到100的之间的偶数之和i = 2sum = 0while (i &lt;= 100):    sum = sum + i    i = i + 2print(sum)# if判断计算1到100的之间的偶数之和i = 1sum = 0while (i &lt;= 100):    i = i + 1    if i % 2 == 0:        sum = sum + iprint(sum)\n\n\nwhile…else如果 while 后面的条件语句为 false 时，则执行 else 的语句块。如果循环由break中断，不执行else中的语句\n语法格式如下：\nwhile &lt;expr&gt;:    &lt;statement(s)&gt;else:    &lt;additional_statement(s)&gt;\n\ncount = 0while count &lt; 5:    print(count, &quot; 小于 5&quot;)    count = count + 1else:    print(count, &quot; 大于或等于 5&quot;)\n\n\ncount = 0while count &lt; 5:    print(count, &quot; 小于 5&quot;)    count = count + 1    if count == 3:        breakelse:    print(count, &quot; 大于或等于 5&quot;)\n\n\nfor循环for 循环可以遍历容器中的数据，容器：字符串、列表、元组、字典\nfor循环的一般格式如下：\nfor &lt;variable&gt; in &lt;sequence&gt;:    &lt;statements&gt;else:    &lt;statements&gt;\n\nfor … in …\n容器中有多少个数据，循环执行多少次\n每次循环会将容器中的数据取出，保存到in前面的变量中\n\n# 遍历列表中的元素sites = [&quot;Baidu&quot;, &quot;Google&quot;, &quot;chrome&quot;, &quot;Taobao&quot;]for site in sites:    print(site)\n\n\nword = &#x27;Google&#x27;for letter in word:    print(letter, end=&#x27; &#x27;)\n\n\nfor … in range()整数范围值可以配合 range() 函数使用：\nfor number in range(1, 6):    print(number,end=&#x27;&#x27;)\n\n\nfor x in range(6):    if x == 4:        break    print(x, end=&#x27; &#x27;)else:    print(&quot;Finally finished!&quot;)\n\n\nfor … else在 Python 中，for…else 语句用于在循环结束后执行一段代码。\n语法格式如下：\nfor item in iterable:    # 循环主体else:    # 循环结束后执行的代码\n\n当循环执行完毕（即遍历完 iterable 中的所有元素）后，会执行 else 子句中的代码，如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句。\nfor x in range(6):    print(x,end=&#x27; &#x27;)else:    print(&quot;Finally finished!&quot;)\n\n\nfor x in range(6):    if x == 4:        break    print(x, end=&#x27; &#x27;)else:    print(&quot;Finally finished!&quot;)\n\n\nrange()函数\nrange() 函数会生成数列，range(n)，可以生成0到n（不包含n）的数字。循环循环n次\nrange(a,b)生成从a到b（不含b）的数列\nrang(a,b,c)c为步长（增量），可以为负数\n\n# 获取列表索引list1 = [&#x27;hello&#x27;, 234, 56, &#x27;wer&#x27;, 0, &#x27;wqqe&#x27;]for i in range(len(list1)):    print(i, list1[i])\n\n\n\n\n还可以使用 range() 函数来创建一个列表\nlist(range(5))[0, 1, 2, 3, 4]\n\nbreak和continue\nbreak：终止循环，循环立即结束\ncontinue：跳过本次循环，本次循环剩下的代码不再执行，进行下一次循环\nbreak 语句可以跳出 for 和 while 的循环体。else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，如果从 for 或 while 循环中被break终止，任何对应的循环 else 块将不执行。\ncontinue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。\n\n\nstr = input(&quot;输入一个字符串并打印,当输入i的时候i不打印，当输入%的时候结束打印&quot;)for i in str:    if i == &#x27;i&#x27;:        continue    if i == &#x27;%&#x27;:        break    print(i, end=&#x27;&#x27;)else:    print(&quot;打印完成！&quot;)\n\n\n\npass语句pass是空语句，是为了保持程序结构的完整性。\npass不做任何事情，一般用做占位语句\n函数函数的定义\n函数必须先定义后调用\n\ndef functname():    code    ...# 1. def是关键字，用来定义函数的# 2. 函数名需要遵守标识符的规则# 3. 处于def缩进中的代码称为函数体# 4. 函数定义的时候，函数体中的代码不会执行，调用的时候才会执行\n\n函数的调用functname()# 1. 函数调用的时候会执行函数体中的代码# 2. 函数调用的代码要写在函数体外面\n\n文档注释本质上是注释，只是书写的位置和作用比较特殊\n\n书写位置：在函数名的下方使用，三对双引号进行注释\n作用：告诉别人函数如何使用\n查看，在调用的时候，将光标放到函数名上使用ctrl+q\nctrl+b会转到函数的声明（按住ctrl鼠标左键点击）\n\n\n函数的嵌套调用在一个函数定义中调用另一个函数\n注意：\n\n函数定义不会调用函数体中的代码\n函数调用会执行函数体中的代码\n函数体中代码执行结束会回到函数被调用的地方继续向下执行\n\n函数参数\n在函数定义的时候，使用变量代替具体的数据（进行占位），称为形参，在调用函数的时候，传递具体的数值，称为实参\n函数的传参传递的是引用\n\n函数传参的方式位置传参在函数调用的时候，按照形参的顺序，将实参值传递给形参\n关键字传参在函数调用的时候，指定数据值给到那个形参\n混合使用\n关键字传参必须写在位置传参的后面\n不能给一个形参传递多个数据\n\n# 求和函数def my_sum(a, b):    return a + bnum1 = int(input(&#x27;输入第一个数字&#x27;))num2 = int(input(&#x27;输入第一个数字&#x27;))print(my_sum(num1, num2))\n\n\n缺省参数缺省参数即默认参数\n# 在函数定义的时候，给形参一个默认的数据值，这个形参就变为缺省参数# 缺省参数的书写要放在普通参数的后边# 缺省参数在函数调用的时候可以传递实参值，也可以不传递实参值# 传参即为实参值，不传即为缺省值def functname(para1,para2=&#x27;value&#x27;)\n\n多值参数（不定长参数）比如print()函数，可以有多个参数\n在书写函数不确定参数个数的时候，可以使用不定长参数（多值参数）\n\n不定长位置参数（不定长元组参数）\n\n在普通参数的前面加上一个*，这个参数就变为不定长位置参数\n这个形参可以接受任意多个位置的传参\n参数将被收集到一个元组中，并传递给函数\n不定长位置参数写在普通参数的后面\n一般写法，不定长位置参数的名字为args，即(*args)\n\n\n\n\n不定长关键字参数（不定长字典参数）\n\n在普通参数的前面加上两个**，这个参数就变为不定长关键字参数\n这个形参可以接受任意多个关键字的传参\n这些参数将被收集到一个字典中，并传递给函数。\n不定长关键字参数写在所有参数的后面\n一般写法，不定长关键字参数的名字为kwargs，即(**kwargs)\n\n\n\n\n\ndef my_sum(*args, **kwargs):    num = 0    for i in args:        num += i    for j in kwargs.values():        num += j    print(num)my_sum(1, 2, a=4, b=5, c=6)\n\n\ndef my_sum(*args, **kwargs):    num = 0    for i in args:        num += i    for j in kwargs.values():        num += j    print(num)mylist = [1, 2, 3, 4]mydict = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;# 将列表(元组)中的数据分别作为位置参数进行传参，需要对列表进行解包操作my_sum(*mylist)  # my_sum(1,2,3,4)# 将字典中的数据作为关键字传参，需要使用**对字典进行解包my_sum(**mydict)  # my_sum(a=1,b=2,c=3,d=4)my_sum(*mylist, **mydict)\n\n\n完整的参数顺序def functname (普通参数, *args, **kwargs):    pass\n\ndef func(*args, **kwargs):    print(type(args), args)    print(type(kwargs), kwargs)    print(&#x27;-&#x27; * 30)func()func(1, 2, 3)  # 数据都给argsfunc(a=1, b=2, c=3)  # 关键字传参，数据都给kwargsfunc(1, 2, 3, a=4, b=5, c=6)  # 不定长传参,前面数据都给args，后面kwargs\n\n\n*在传参的作用* 的作用是定义位置参数的结束和关键字参数的开始。当在函数定义中的参数列表中出现 * 时，它将标志着其前面的参数只能通过位置传递，而后面的参数只能通过关键字传递。\ndef func(a, b, *, d):    print(a, b, d)func(1, 2, d=3)  # 合法的调用方式，指定了参数d的名称# 输出：1 2 3func(1, 2, 3)  # 错误的调用方式，因为参数d必须通过关键字传递# 输出：TypeError: func() takes 2 positional arguments but 3 were given\n\n\n函数的返回值函数整体执行的结果，函数中得到的数据在后续的代码中还要使用，这时需要将数据作为返回值返回\nreturn之后的代码不会执行\ndef functname():   # 返回值None    passdef functname():    return     # 返回值Nonedef functname():    return xx  # 返回值xx\n\n变量引用\n变量和数据都是保存在内存中的。在 Python 中，变量是用来存储数据的标识符，它们也存储在计算机的内存中。Python 是一种动态类型语言，这意味着变量的类型是根据赋给它们的值来确定的，而不是在声明变量时显式地指定类型。\n当我们在 Python 中创建变量并给它们赋值时，Python 解释器会在内存中分配一块空间来存储这些变量的值。每个变量都有一个名称（标识符）和一个关联的内存地址，我们可以使用这个名称来访问和操作变量的值。\n\n变量存储的是对象的引用（对象的内存地址）\n\n在python中函数的参数传递以及返回值都是靠引用传递的\n\n\n1. 在定义变量的时候 变量=数据值，Python解释器会在内存中开辟两块空间2. 变量和数据都有自己的空间3. 本质：数据的地址保存到变量对应的内存中4. 变量中储存数据地址的行为就是引用（变量引用了数据的地址，简单说就是变量中储存了数据）存储的地址称为引用地址5. 可以使用id()，获取变量中的引用地址，即数据的地址。如果两个变量的id()获取的引用地址一样，代表着两个变量引用了同一个数据6. 只有赋值运算符=可以改变变量的引用\n\na = 1b = 2c = 1print(id(a))print(id(b))print(id(c))\n\n\n可变类型和不可变类型数据类型：int float bool str list tuple dict set可变类型：数据所在的内存允许修改不可变类型：数据所在的内存不允许修改不使用=，变量引用的数据中的内容是否会变化，会变化是可变的，不会变化是不可变的。比方list可以用append()方法进行修改可变类型：list,dict,set不可变类型：int，float，bool，str，tuple\n\nlist1=[1,2,3]print(&#x27;list1&#x27;,id(list1))list2=[1,2,3]print(&#x27;list2&#x27;,id(list2))print(&#x27;list1[0]&#x27;,id(list1[0]))print(&#x27;list1[1]&#x27;,id(list1[1]))print(&#x27;list1[2]&#x27;,id(list1[2]))print(&#x27;list2[0]&#x27;,id(list2[0]))print(&#x27;list2[1]&#x27;,id(list2[1]))print(&#x27;list2[2]&#x27;,id(list2[2]))list1[1]=10print(&#x27;list1&#x27;,id(list1))print(&#x27;list1[0]&#x27;,id(list1[0]))print(&#x27;list1[1]&#x27;,id(list1[1]))print(&#x27;list1[2]&#x27;,id(list1[2]))\n\n\nmytuple = (1, 2, [3, 4])# 元组中的数据不能改变，指的是这三个地址不能改变print(id(mytuple[-1]))mytuple[-1][0] = 10  # 修改的是列表中下标为0的位置的引用地址，列表的地址没有变，元组中的内容没有变化(元组的内容是引用地址)print(mytuple)print(id(mytuple[-1]))\n\n\n\n如果将可变对象（如列表、字典等）作为函数的参数，并在函数内部修改了这些对象的值（而不是重新赋值给参数），那么这些修改将会影响到传递给函数的实际参数（也称为实参）。这是因为在 Python 中，可变对象是通过引用传递的，而不是通过值传递的。\n\n当你传递可变对象（如列表、字典等）给一个函数作为参数时，实际上是将该对象的引用传递给了函数。所谓的引用，实际上是指向存储对象的内存地址的指针。换句话说，函数内部的参数将指向与调用函数时传递的实际对象相同的内存地址，而不是对象的副本。\n因此，如果在函数内部修改了这个可变对象（例如，向列表中添加元素、修改字典中的键值对等），则实际上是在修改同一个对象。由于函数参数和调用者之间共享对象的引用，因此对对象的修改会在函数外部产生影响。\ndef modify_list(lst):\n    lst.append(4)\n    lst[0] = 100\n\nmy_list = [1, 2, 3]\nmodify_list(my_list)\nprint(my_list)  # 输出 [100, 2, 3, 4]\n\n\n需要注意的是，如果在函数内部重新给参数赋值，例如 lst = [4, 5, 6]，这将会改变参数的引用，但不会影响到原始对象。\ndef modify_list(lst):\n    lst = [4, 5, 6]\n\n\nmy_list = [1, 2, 3]\nprint(my_list)\nmodify_list(my_list)\nprint(my_list)\n  - ![](image-20240403215607166.png)- list中+=操作的本质是extend的操作，所以列表的内存地址不发生改变- 不可变对象（如整数、字符串、元组等）是通过值传递的，而不是通过引用传递的。这意味着当你将不可变对象传递给函数作为参数时，实际上是将该对象的值复制一份，然后将这个复制的值传递给函数。  由于不可变对象的值无法在内存中被修改，因此在函数内部对不可变对象的任何修改都不会影响到原始对象。这意味着函数内部对不可变对象的操作不会影响到函数外部的实际参数。  ```python  def modify_string(s):      s = s + &quot; World&quot;    my_string = &quot;Hello&quot;  modify_string(my_string)  print(my_string)  # 输出 Hello  \n\n\n\n\n\n交换两个变量的值# 数学方法a = 10b = 20a = a + bb = a - ba = a - b# Python特有a, b = b, a #先组包，后拆包\n\n组包(pack)和拆包(unpack)\n组包：将多个数据值使用逗号连接的过程，组成元组\n\n拆包：将容器中数据值使用多个变量分别保存的过程，注意：变量的个数和容器中数据的个数要保持一致\n\n赋值运算符先执行=右边的内容，执行的结果保存到等号左边的变量中\n\n注意：对字典进行拆包得到的是字典的键\ndict1=&#123;&#x27;name&#x27;:&#x27;Ana&#x27;,&#x27;age&#x27;:18,&#x27;height&#x27;:12&#125;a,b,c=dict1print(a,b,c)print(dict1[a])print(dict1[b])print(dict1[c])\n\n\n\n\na = 10b = 20c = a, b# 组包print(&#x27;组包结果：&#x27;, type(c), c)# 拆包a, b = c  # a,b等于c容器中的两个数据print(&#x27;拆包结果是&#x27;, a, b)# 先组包后拆包x, y, z = [1, 2, 3] #将1,2,3组起来，然后存入x,y,zprint(x, y, z)\n\n\n局部变量和全局变量\n根据变量定义的位置进行区分\n\n局部变量在函数内部定义的变量，称为局部变量。形参属于局部变量\n特点：\n\n局部变量只能在当前函数内部使用，不能在其他函数和函数外部使用\n在不同函数中，可以定义名字相同的局部变量，两者之间没有明显\n局部变量生存周期（生命周期，作用范围）：在函数被调用的时候，局部变量被创建；函数调用结束，局部变量的值被销毁，不能使用\n\n函数局部变量的值想要被函数外部使用，需要使用return关键字\n全局变量在函数外部定义的变量，称为全局变量\n特点：\n\n可以在任何函数中读取全局变量的值\n如果在函数中存在和全局变量名字相同的局部变量，在函数中使用的是局部变量的值（就近原则）\n在函数内部想要修改全局变量的引用（数据值），需要添加global关键字对变量进行声明为全局变量。类似列表的.append()操作不改变引用不需要globa的操作（引用传递）\n代码执行的时候全局变量被创建，代码执行结束全局变量被销毁\n\nnum=10def func1():    print(num)def func2():    num=20    print(num)def func3():    global num    num=30    print(num)func1()func2()func3()func1()\n\n\n函数返回值# 返回多个数据值，将多个数据值组包进行返回return a,b\n\n匿名函数（lambda表达式）Python 使用 lambda 来创建匿名函数。\nlambda 函数是一种小型、匿名的、内联函数，它可以具有任意数量的参数，但只能有一个表达式。\n匿名函数不需要使用 def 关键字定义完整函数。\nlambda 函数通常用于编写简单的、单行的函数，通常在需要函数作为参数传递的情况下使用，例如在 map()、filter()、reduce() 等函数中。\nlambda 函数特点：\n\nlambda 函数是匿名的，它们没有函数名称，只能通过赋值给变量或作为参数传递给其他函数来使用。返回值不需要return，一行代码（表达式）的结果就是返回值\nlambda 函数通常只包含一行代码，这使得它们适用于编写简单的函数。\n\nlambda 参数: 一行代码# 匿名函数一般作为函数的参数使用\n\n# 1. 无参无返回值def func1():    print(&#x27;hello world&#x27;)func1()a = lambda: print(&#x27;hello lambda&#x27;)a()# 2. 无参有返回值def func2():    return 10print(func2())b = lambda: 22print(b())# 3. 有参无返回值def mysum(a, b):    print(a + b)mysum(1, 2)c = lambda a, b: print(a + b)c(10, 22)# 4. 有参有返回值def sum1(a, b):    return a + bprint(sum1(2, 4))d = lambda a, b: a + bprint(d(5, 6))\n\n\n# 定义一个匿名函数，参数为字典，返回字典中键为age的值# 参数只是占位作用，定义的时候没有具体值，形参的值是在调用的时候进行传递，此时形参才具有数据值# 形参的类型就是由实参决定，在函数定义的时候形参只是一个函数符号。想要形参是字典类型，实参是字典类型就可b = lambda x: x.get(&#x27;age&#x27;)print(b(&#123;&#x27;name&#x27;: &#x27;ann&#x27;, &#x27;age&#x27;: 18&#125;))\n\n\n匿名函数作为参数列表中的字典排序sort()方法会原地修改列表，而不是返回一个新的排序后的列表。该方法有两个可选参数：key 和 reverse。\n\nkey 参数是一个函数，用于指定排序的比较方式。默认情况下，sort() 方法会按照列表元素的大小进行排序。如果指定了 key 参数，sort() 方法会使用该函数的返回值来比较元素，从而进行排序。\nreverse 参数是一个布尔值，用于指定排序的顺序。默认情况下，reverse=False，即升序排序。如果设置为 True，则会进行降序排序。\n\n对字典来说，比大小需要使用sort()中的key参数。key参数需要传递一个函数，一般是匿名函数。\n字典的排序需要指定依照字典的什么键进行排序，需要使用匿名函数返回字典的键对应的值\nuser_list = [&#123;&#x27;name&#x27;: &#x27;lisi&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 17&#125;]user_list.sort(key=lambda x: x.get(&#x27;name&#x27;), reverse=True)  # 降序排序# 匿名函数的参数是列表中的数据。在sort()函数内部，会调用key函数，将列表中的每个元素作为实参传递给形参，从列表中获取函数的返回值，对返回值进行比大小print(user_list)user_list.sort(key=lambda x: x.get(&#x27;age&#x27;), reverse=True)print(user_list)\n\n\nord()可以获取字符对应的ASCII码\nchr(ASCII)可以获取ASCII码对应的字符\n面向对象面向对象是一种编程思想\n类和对象\n类\n多个特征和行为相同或相似事物的统称\n泛指的（指代多个，而不是一个）\n\n\n对象\n具体存在的一个事物，看得见摸得着的\n特指的（指一个）\n由类创建的\n\n\n\n苹果   -----&gt;类红苹果  -----&gt;类张三嘴里吃的苹果 ----&gt;对象\n\n类的组成\n类名：给多个事物起的名称，在代码中要满足大驼峰命名法\n属性：事物的特征\n方法：事物的行为，类中定义的函数。\n\n类的抽象（类的设计）：找到类的类名，属性和方法\n1. 小明 今年18岁，身高1.75，每天早上跑完步会去吃东西2. 小红 今年17岁，身高1.72，不跑步，喜欢吃吃东西类名：人类（Person）属性：名字（name）、年龄（age）、身高（height）方法：跑步（run）、吃（eat）一只黄颜色的狗狗叫大黄，看见生人汪汪叫，看见熟人摇尾巴类名：狗类（dog）属性：颜色（color）、名字（name）方法：汪汪叫（bark），摇尾巴（shake）\n\n对象python中一切都是对象，即用class定义的类也是对象\n\n属性：对对象的特征的描述\n方法：对象具有的行为\n\n对象的划分实例对象（实例）通过类名()创建的对象即实例对象，简称实例\n创建对象的过程称作类的实例化\n我们平时说的对象就是实例对象\n每个实例都有自己的内存空间，在自己的内存空间中保存自己的属性（实例属性）\n类对象（类名）类对象就是类，可以认为是类名（类名包含了整个类）\n在 Python 中，类也是对象。更具体地说，类是一个类型对象，它是由 type 类创建的实例。因此，类对象就是一个实例化了 type 类的对象。\n类对象是python解释器在执行代码的过程中创建的\n类对象的作用：使用类对象创建实例，类对象也有自己的内存空间，可以保存一些属性值（类属性）信息\n在一个代码中，一个类只有一份内存空间\n属性的划分实例属性概念：是实例对象具有的属性\n定义和使用：\n在__init__方法中，使用self.属性名= 属性值定义\n在方法中使用self.属性名来调用\n在每个实例当中都存在一份内存空间\n使用时机：基本上99%都是实例属性，通过self定义。多个对象判断这个值是不是一样的，如果都是一样的，同时变化，一般定义为类属性，否则定义为实例属性\n类属性概念：是类对象具有的属性\n定义和使用：\n在类内部，方法外部定义的变量\n类对象.属性名=属性值或类名.属性名=属性值\n使用类对象.属性名或类名.属性名调用\n只有类对象中存在一份内存空间\nclass Dog:    # 定义类属性count，记录创建对象的个数    count = 0    def __init__(self, name):        # 定义实例属性，实例属性在init方法中定义        self.name = name;        # 每创建一个对象就会调用init方法        Dog.count += 1dog1 = Dog(&#x27;小花&#x27;)print(Dog.count)dog2 = Dog(&#x27;大黄&#x27;)print(Dog.count)dog2 = Dog(&#x27;小白&#x27;)print(Dog.count)# 可以用 实例对象.类属性名 来获取类属性的值（原因：实例对象属性的查找现在实例属性中找，找到直接使用，没有找到会去类属性里寻找）print(dog1.count)print(dog2.count)print(dog3.count)\n\n\n方法的划分实例方法（最常用）\n定义：在类中直接定义的方法\nclass Demo:    def func(self): # self一般表示实例对象        pass\n\n\n\n定义时机：如果在方法中需要使用实例属性（需要使用self），则这个方法必须定义为实例方法\n\n调用：对象.方法名()\n\n\n类方法\n定义：在方法名字的上方书写@classmethod 装饰器\nclass Demo:    @classmethod    def func(cls): # cls表示的是类对象（类名）class        pass\n\n定义时机：方法中不需要使用实例属性（即self），用到了类属性，可以将这个方法定义为类方法，也可以定义为实例方法\n\n调用：通过类对象调用：类名.方法名()，通过实例对象调用：实例.方法名()\n\n\n静态方法\n定义：在方法名字的上方书写@staticmethod 装饰器\nclass Demo:    @staticmethod    def func(): # 一般没有参数        pass\n\n\n\n使用时机：方法中不需要使用实例属性，也不使用类属性，可以将这个方法定义为静态方法\n\n调用：通过类对象调用：类名.方法名()，通过实例对象调用：实例.方法名()\n\n\nimport randomclass Game:    top_score = 0    def __init__(self, name):        self.name = name    @classmethod    def start_game(cls):        cls.score = random.randint(10, 100)        print(f&#x27;本次游戏得分&#123;cls.score&#125;&#x27;)    @classmethod    def show_top_score(cls):        if cls.score &gt; Game.top_score:            Game.top_score = cls.score            print(f&#x27;现在的最高分是&#123;Game.top_score&#125;&#x27;)        else:            print(f&#x27;现在的最高分是&#123;Game.top_score&#125;&#x27;)    @staticmethod    def show_help():        print(&quot;这场游戏的得分都是随机的&quot;)player1 = Game(&#x27;小王&#x27;)player1.start_game()Game.show_top_score()player1.start_game()Game.show_top_score()Game.show_help()\n\n\nimport randomclass Game:    top_score = 0    top_score_player=&#x27;&#x27;    def __init__(self, name):        self.name = name        self.score = 0    def start_game(self):        self.score = random.randint(10, 100)        print(f&#x27;本次&#123;self.name&#125;游戏得分&#123;self.score&#125;&#x27;)    def show_top_score(self):        if self.score &gt; Game.top_score:            Game.top_score = self.score            Game.top_score_player = self.name            print(f&#x27;现在的最高分是&#123;Game.top_score&#125;,得主是&#123;Game.top_score_player&#125;&#x27;)        else:            print(f&#x27;现在的最高分是&#123;Game.top_score&#125;,得主是&#123;Game.top_score_player&#125;&#x27;)    @staticmethod    def show_help():        print(&quot;这场游戏的得分都是随机的&quot;)player1 = Game(&#x27;小王&#x27;)player1.start_game()player1.show_top_score()player2 = Game(&#x27;小李&#x27;)player2.start_game()player2.show_top_score()player3 = Game(&#x27;小张&#x27;)player3.start_game()player3.show_top_score()player4 = Game(&#x27;小红&#x27;)player4.start_game()player4.show_top_score()Game.show_help()\n\n\n面向对象的代码步骤\n定义类，在定义类之前先设计类\n先定义简单的类，不包含属性，在python中定义类需要使用关键字class\n方法：在类中定义的函数，第一个参数是self（实例方法）\nclass 类名:\tdef 方法名(self):        pass\n\n创建对象，使用第一步定义的类创建对象\n创建对象使用类名()进行创建\n变量=类名() #变量中保存的是对象的地址，一般直接称为对象# 一个类可以创建多个对象\n\n通过对象调用方法\n对象.方法名()\n\n案例实现\n# 需求：小猫爱吃鱼，小猫要喝水# 类名：猫类Cat# 属性：暂无# 方法：吃鱼eat(),喝水drink()# 类的定义class Cat:    def eat(self):        print(&quot;小猫爱吃鱼&quot;)    def drink(self):        print(&quot;小猫要喝水&quot;)# 创建对象bluecat = Cat()bluecat.eat()bluecat.drink()redcat = Cat()redcat.eat()redcat.drink()    \n\n\n\n\nself的说明   class Cat:    def eat(self):        print(&quot;小猫爱吃鱼&quot;)\n\n\n从函数的语法上讲，self是形参，就可以是任意的变量名，只不过我们习惯性将这个形参写成self\nself是普通的形参，但是调用的时候没有传递实参值，原因是python解释器在执行代码的时候，自动**调用这个方法的对象传递给了self**，即self的本质是对象\n只需要确定通过哪个对象调用，对象的引用和self的引用一样\n\n# 类的定义class Cat:    def eat(self):        print(f&#x27;&#123;id(self)&#125;,self&#x27;)        print(&quot;小猫爱吃鱼&quot;)# 创建对象bluecat = Cat()bluecat.eat()  # bluecat调用eat()方法，解释器就会将bluecat对象传给selfprint(id(bluecat), &#x27;bluecat&#x27;)a = bluecat  # 不是创建对象a.eat()print(id(a), &#x27;a&#x27;)redcat = Cat()redcat.eat()print(id(redcat), &#x27;redcat&#x27;)# self是函数局部变量，创建的对象是全局变量\n\n\n每次创建对象会开辟新的内存空间\n对象的属性操作添加属性对象.属性名 = 属性值\n\n类内部添加\nself.属性名 = 属性值# 在类中添加属性一般写在__init__方法中\n\n\n\n类外部添加\n对象.属性名 = 属性值 # 一般不使用\n\n魔法方法python中有一类方法，以两个下划线开头，两个下划线结尾，并且在满足某个条件的情况下会自动调用，这类方法称为魔法方法\n__init__方法\n创建对象后会自动调用\n应用场景：给对象添加属性的（初始方法，构造方法）。某些代码，在每次创建对象后都要执行，可以写在__init__方法中\n如果__init__函数有除了self之外的参数，要记得传参\n\nclass Cat:    def __init__(self): # 创建对象才调用        self.name = &#x27;蓝猫&#x27;        self.age = 2        # 下方代码只是为了验证该方法被调用，实际代码中不要书写        print(&quot;我是__init__,我被调用了&quot;)    def show_info(self):        print(f&#x27;小猫的名字是&#123;self.name&#125;，年龄是&#123;self.age&#125;&#x27;)# 创建对象Cat()  # 创建了对象，但是没有保存bluecat = Cat()a = bluecat # 不是在创建对象，不调用__init__()bluecat.show_info()\n\n\n带参数的_init_:\nclass Cat:    # 定义添加书属性的方法    def __init__(self, name, age):  # 创建对象才调用        self.name = name        self.age = age        # 下方代码只是为了验证该方法被调用，实际代码中不要书写        print(&quot;我是__init__,我被调用了&quot;)    def show_info(self):        print(f&#x27;小猫的名字是&#123;self.name&#125;，年龄是&#123;self.age&#125;&#x27;)# 创建对象bluecat = Cat(&#x27;蓝猫&#x27;, 2)bluecat.show_info()redcat = Cat(&#x27;红猫&#x27;, 3)redcat.show_info()\n\n\n__str__方法\n使用print()打印对象后会自动调用\n应用场景：在这个方法中一般书写对象的属性信息，即打印对象的时候想要查看的信息在此方法中定义。如果类中没有定义此方法，print(对象)输出对象的引用地址\n这个方法必须返回一个字符串\n\nclass Cat:    # 定义添加书属性的方法    def __init__(self, name, age):  # 创建对象才调用        self.name = name        self.age = age    def __str__(self):        return f&#x27;小猫的名字是&#123;self.name&#125;，年龄是&#123;self.age&#125;&#x27;# 创建对象bluecat = Cat(&#x27;蓝猫&#x27;, 2)print(bluecat)redcat = Cat(&#x27;红猫&#x27;, 3)print(redcat)\n\n\n__del__方法__del__方法（析构方法），对象被删除销毁时，自动调用。一种是程序运行结束，所有对象被销毁；一种是使用del删除对象（如果对象有多个名字即多个变量引用同个对象，需要把所有的对象都删除）\nclass Demo:    def __init__(self, name):        print(&#x27;__init__被调用了&#x27;)        self.name = name    def __del__(self):        print(f&#x27;&#123;self.name&#125;没了&#x27;)a = Demo(&#x27;a&#x27;)b = Demo(&#x27;b&#x27;)c = Demo(&#x27;c&#x27;)del aprint(&#x27;代码运行结束&#x27;)\n\n\n小明跑步class Person:    def __init__(self, name, weight):        self.name = name        self.weight = weight    def __str__(self):        return f&#x27;姓名：&#123;self.name&#125;，体重是&#123;self.weight&#125;公斤&#x27;    def run(self):        # 跑步减少0.5公斤        print(f&#x27;&#123;self.name&#125;跑了5km，体重减少了&#x27;)        self.weight -= 0.5    def eat(self):        print(f&#x27;&#123;self.name&#125;大餐一顿，体重增加了&#x27;)        self.weight += 1.0xm = Person(&#x27;小明&#x27;, 75.0) # 调用__init__print(xm) #调用__str__xm.run()print(xm) #调用__str__xm.eat()print(xm) #调用__str__\n\n\n摆放家具class House:    def __init__(self, housetype, square):        self.housetype = housetype  # 房子的户型        self.square = square  # 房子的总面积        self.leftsquare = square  # 房子剩余的面积，初始值等于总面积        self.furniture = []  # 房子有的家具    def __str__(self):        return (f&#x27;房子的户型是&#123;self.housetype&#125;,房子的总面积是&#123;self.square&#125;平方米,&#x27;                f&#x27;房子的剩余面积是&#123;self.leftsquare&#125;平方米,家具有&#123;self.furniture&#125;&#x27;)    def add_item(self, item):  # 添加家具        if self.leftsquare &gt; item.square:            self.furniture.append(item.name)  # 将家具加入列表            self.leftsquare -= item.square  # 剩余面积计算        else:            print(&#x27;剩余面积不够了！添加失败！&#x27;)class HouseItem:    def __init__(self, name, square):        self.name = name  # 家具的名字        self.square = square  # 家具的占据面积    def __str__(self):        return f&#x27;家具是&#123;self.name&#125;,占据面积是&#123;self.square&#125;平方米&#x27;bed = HouseItem(&#x27;席梦思&#x27;, 4)print(bed)chest = HouseItem(&#x27;衣柜&#x27;, 2)print(chest)table = HouseItem(&#x27;餐桌&#x27;, 1.5)print(table)newhouse = House(&#x27;一室一厅&#x27;, 98)newhouse.add_item(bed)print(newhouse)newhouse.add_item(bed)print(newhouse)newhouse.add_item(chest)print(newhouse)newhouse.add_item(table)print(newhouse)\n\n\n登录案例class LoginPage:    def __init__(self, username, password, code):        self.name = username        self.password = password        self.code = code        self.btn = &#x27;登录&#x27;    def login(self):        print(f&#x27;1. 输入用户名&#123;self.name&#125;&#x27;)        print(f&#x27;2. 输入密码&#123;self.password&#125;&#x27;)        print(f&#x27;3. 输入验证码&#123;self.code&#125;&#x27;)        print(f&#x27;4. 点击按钮&#123;self.btn&#125;&#x27;)login = LoginPage(&#x27;admin&#x27;, &#x27;123456&#x27;, &#x27;8888&#x27;)login.login()\n\n\n获取属性对象.属性名\n\n类内部添加：self.属性名\n类外部添加：对象.属性名，一般很少使用\n给对象进行属性添加后，对象内存地址不变\n\nclass Cat:    def eat(self):        print(f&#x27;&#123;id(self)&#125;,self&#x27;)        print(f&quot;小猫&#123;self.name&#125;爱吃鱼&quot;)# 创建对象bluecat = Cat()# 给蓝猫添加 name属性print(f&#x27;&#123;id(bluecat)&#125;,bluecat&#x27;)bluecat.name = &#x27;蓝猫&#x27;bluecat.eat()redcat = Cat()print(f&#x27;&#123;id(redcat)&#125;,redcat&#x27;)redcat.name = &#x27;红猫&#x27;redcat.eat()\n\n\n私有和公有在Python中定义的方法和属性，可以添加访问控制权限（即在什么地方可以使用这个属性和方法）\n\n公有权限\n直接书写的方法和属性都是公有的\n公有的方法和属性可以在任意地方访问和使用\n\n\n私有权限\n在类内部，属性名或者方法名前面加上两个下划线__，就变为私有\n私有方法和属性只能在当前类内部使用\n在类外部操作私有属性，在类内部定义公有方法去操作私有属性\n\n\n什么时候定义私有？\n\n某个属性或者方法不写在类外部被访问和使用，将其定义为私有\n测试中一般不怎么使用，直接公有\n开发中根据需求文档去确定什么作为私有\n\n\n\n\n\nclass Person:    def __init__(self, name, age):        self.name = name        self.__age = age    def __str__(self):        return f&#x27;名字：&#123;self.name&#125;,年龄&#123;self.__age&#125;&#x27;xm = Person(&#x27;小明&#x27;, 18)# 类内部可以使用__ageprint(xm)# 类外部不能直接使用私有属性print(xm.__age) \n\n\nclass Person:    def __init__(self, name, age):        self.name = name        # 私有的本质：解释器执行代码，发现属性名或者方法前有两个__，会将这个名字重命名        # 会在这个名字前面加上_类名前缀，即self.__age=self._Person__age        self.__age = age    def __str__(self):        return f&#x27;名字：&#123;self.name&#125;,年龄&#123;self.__age&#125;&#x27;xm = Person(&#x27;小明&#x27;, 18)# 类内部可以使用__ageprint(xm)xm.__age = 20 #不是修改私有属性，是添加了一个名叫__age的公有属性print(xm)print(xm._Person__age)xm._Person__age=19 #这样才从外部访问修改了私有属性print(xm._Person__age)\n\n\n__dict__魔法属性可以将对象具有的属性组成字典返回\nxm = Person(&#x27;小明&#x27;, 18)# 类内部可以使用__ageprint(xm.__dict__)xm.__age = 20 #不是修改私有属性，是添加了一个公有属性__ageprint(xm.__dict__)\n\n\n继承继承描述的是类与类之间的关系，可以减少代码的冗余，实现代码的重用。\n子类继承父类之后，子类的对象可以直接使用父类中定义的公有属性和方法。\n单继承：一个类只继承一个父类\nclass 类名(父类名):    passclass A: #没有写父类，但是有父类object，object类是python中最原始的类    passclass B(A): #类B继承类A，A类是父类（基类），B类为子类（派生类）    pass\n\nclass Animal:    def eat(self):        print(&#x27;哐哐吃&#x27;)class Dog(Animal):    def bark(self):        print(&#x27;汪汪叫&#x27;)class XiaoTianQuan(Dog):    passani = Animal()ani.eat()dog = Dog()dog.eat()  # 调用父类的方法dog.bark()  # 调用自己的方法xiaotian = XiaoTianQuan()xiaotian.eat()xiaotian.bark()\n\n\n重写在子类中定义了和父类中名字相同的方法就是重写。\n当父类中的方法不能满足子类对象的需求，所以重写。\n重写之后，调用子类自己的方法，不调用父类中的方法\n重写的方式\n覆盖：父类中的功能完全抛弃，重新书写\nclass Dog:    def bark(self):        print(&#x27;汪汪叫&#x27;)class XiaoTianQuan(Dog):    # 覆盖重写    def bark(self):        print(&#x27;嗷嗷嗷&#x27;)dog = Dog()dog.bark()  # 调用自己的方法xiaotian = XiaoTianQuan()xiaotian.bark()\n\n\n\n扩展：父类中的功能还调用，只是添加新的功能（更常见）。直接在子类中定义和父类中名字相同的方法，在合适的地方调用父类中的方法 super().方法()。然后书写添加的新功能\nclass Dog:    def bark(self):        print(&#x27;汪汪叫&#x27;)        print(&#x27;汪汪叫&#x27;)class XiaoTianQuan(Dog):    # 扩展重写    def bark(self):        print(&#x27;嗷嗷嗷&#x27;)        super().bark()        print(&#x27;嗷嗷嗷&#x27;)dog = Dog()dog.bark()  # 调用自己的方法xiaotian = XiaoTianQuan()xiaotian.bark()\n\n\n多态不同类的对象对相同的方法做出不同的响应。简单来说，多态性使得能够以统一的方式使用不同类型的对象，而不必关心它们具体的类型。\n多态性使得我们可以编写更加灵活和通用的代码，因为我们不需要关心对象的具体类型，只需要知道它们共享相同的接口（即方法），就可以以统一的方式对待它们。\n文件文件通常是以字节序列的形式存储在存储设备（如硬盘、固态硬盘、闪存驱动器等）上的。\n文本文件：能使用记事本软件打开，能使用记事本转换为文字。txt、md、py\n二进制文件：不能使用记事本打开的。exe、mp3、mp4、png、jpg\n文件操作的步骤打开文件将文件从磁盘中读取到内存中（CPU只能对内存执行操作）\n文件流一般写入try中，因为文件流容易报错\nopen(file,mode=&#x27;r&#x27;,encoding=None)&gt; 参数file:打开的文件，类型是字符串，文件路径可以是相对路径（推荐），也可以是绝对路径&gt; 参数mode:默认参数（缺省参数），表示打开文件的方式\t&gt; r:read 只读打开    &gt; w:write 只写打开    &gt; a:append 追加打开，在文件的末尾写入内容&gt; 参数encoding:编码方式,文字和二进制如何转换\t&gt;gbk:将一个汉字转换为两个字节二进制    &gt;utf-8:将一个汉字转换为三个字节二进制&gt; 返回值:返回的是文件对象，后续对文件的操作都需要这个对象\n\n读写文件写文件向文件中写入指定的内容。\n前提：文件的打开方式是 w 或者 a\n文件对象.write(&#x27;写入文件的内容&#x27;)# 返回值：写入文件的字符数，一般不关注# 注意w方式打开文件：1. 文件不存在会直接创建2. 文件存在会覆盖原文件# 注意a方式打开文件：1. 文件不存在会直接创建2. 文件存在会在末尾写入内容\n\nf = open(&#x27;a.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)f.write(&#x27;good good&#x27;)f.close()\n\n\n读文件将文件中的内容读取出来\n前提：文件的打开方式是 r \n文件对象.read(n)# 参数n:表示读取多少个字符，一般不写表示读取全部内容# 返回值：读取到的文件内容，类型：字符串# 注意r方式打开文件，文件不存在会报错\n\nf = open(&#x27;a.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)buf = f.read()print(buf)f.close()\n\n\n关闭文件关闭文件:将文件占用的资源进行清理，同时会保存文件，文件关闭之后这个文件对象就不能使用了文件对象.close()\n\nwith open打开文件好处：不用自己去书写关闭文件的代码，会自动进行关闭\nwith open(file, mode, encoding=&#x27;utf-8&#x27;) as 变量:    # 缩进中读取/写入文件# 缩进中的代执行结束，出缩进之后文件会自动关闭\n\nwith open(&#x27;a.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:    f.write(&#x27;day day up&#x27;)\n\n\n按行读取一次读取一行内容，文件对象.readline()\nwith open(&#x27;a.txt&#x27;, encoding=&#x27;utf-8&#x27;) as f:    buf=f.readline()    print(buf)    print(f.readline())\n\n\nwith open(&#x27;a.txt&#x27;, encoding=&#x27;utf-8&#x27;) as f:    for i in f:  # 按行遍历        print(i, end=&#x27;&#x27;)# read()和readline()读到文件末尾会返回空的字符串with open(&#x27;a.txt&#x27;, encoding=&#x27;utf-8&#x27;) as f:    while True:        buf = f.readline()        if len(buf) == 0: #if buf:容器中的数据个数为0为空            break        else:            print(buf,end=&#x27;&#x27;)\n\n\njson文件json&#x3D;’java script object notation’,是JavaScript对象表示法，是一种基于文本，独立于语言的轻量级数据交换格式。\n\n基于文本：是一个文本文件，不能包含图片，音视频等\n独立于语言：不是某个语言特有的，每种编程语言都可以使用\n轻量级：相同的数据和其他格式相比占用的大小比较小\n数据交换格式：后端程序员给前端的数据（json,html,xml）\n\njson文件也是一种文本文件，可以直接使用read()和write()操作，但是不方便。json文件有独特的读取和写入方法\n常用在做测试的时候，将测试数据定义为json文件格式，使用代码读取json文件，即读取测试数据，进行传参（参数化）\njson语法规则\njson文件的后缀是.json\njson文件中的主要数据类型是对象（{}类似Python中的字典）和数组（[]类似列表），对象和数组可以互相嵌套\n一个json文件是一个对象或者数组，即json文件的最外层要么是一个大括号{}，要么是一个数组[]\njson中的对象是由键值对组成的，每个数据之间使用,隔开，但是最后一个数据后面不要写逗号\njson中的字符串必须使用””双引号\njson中的其他数据类型：数字类型（int float）、字符串string（str）、布尔类型（true、false）、None（null）\n\n&#123;  &quot;name&quot;: &quot;小明&quot;,  &quot;age&quot;: 18,  &quot;gender&quot;: 1,  &quot;isFan&quot;: true,  &quot;hobbies&quot;: [    &quot;听歌&quot;,    &quot;游戏&quot;,    &quot;购物&quot;,    &quot;睡觉&quot;  ],  &quot;address&quot;: &#123;    &quot;country&quot;: &quot;China&quot;,    &quot;city&quot;: &quot;Shanghai&quot;  &#125;&#125;\n\n读取json文件1. 导包 import jason2. 读打开文件3. 读文件json.load(文件对象)# 返回的是字典（对象）或者列表（数组）\n\nimport jsonwith open(&#x27;info.json&#x27;, encoding=&#x27;utf-8&#x27;) as f:    # buf = f.read()    # print(type(buf), buf)    result = json.load(f)    print(type(result))    print(result.get(&#x27;name&#x27;))    print(result.get(&#x27;age&#x27;))    print(result.get(&#x27;address&#x27;).get(&#x27;city&#x27;))\n\n\n[&#123;  &quot;name&quot;: &quot;小明&quot;,  &quot;age&quot;: 18,  &quot;gender&quot;: 1,  &quot;isFan&quot;: true,  &quot;hobbies&quot;: [    &quot;听歌&quot;,    &quot;游戏&quot;,    &quot;购物&quot;,    &quot;睡觉&quot;  ],  &quot;address&quot;: &#123;    &quot;country&quot;: &quot;China&quot;,    &quot;city&quot;: &quot;Shanghai&quot;  &#125;&#125;, &#123;&quot;name&quot;: &quot;小红&quot;,  &quot;age&quot;: 17,  &quot;gender&quot;: 0,  &quot;isFan&quot;: false,  &quot;hobbies&quot;: [    &quot;听歌&quot;,    &quot;学习&quot;,    &quot;购物&quot;,    &quot;睡觉&quot;  ],  &quot;address&quot;: &#123;    &quot;country&quot;: &quot;China&quot;,    &quot;city&quot;: &quot;Beijing&quot;  &#125;&#125;]\n\nwith open(&#x27;info.json&#x27;, encoding=&#x27;utf-8&#x27;) as f:    # buf = f.read()    # print(type(buf), buf)    result = json.load(f)    print(type(result))    for info in result:        print(info.get(&#x27;name&#x27;), info.get(&#x27;age&#x27;), info.get(&#x27;address&#x27;).get(&#x27;city&#x27;))\n\n\n测试读取案例[  &#123;    &quot;desc&quot;: &quot;正确的用户名密码&quot;,    &quot;username&quot;: &quot;admin&quot;,    &quot;password&quot;: &quot;123456&quot;,    &quot;expect&quot;: &quot;登录成功&quot;  &#125;,  &#123;    &quot;desc&quot;: &quot;错误的用户名&quot;,    &quot;username&quot;: &quot;root&quot;,    &quot;password&quot;: &quot;123456&quot;,    &quot;expect&quot;: &quot;登录失败&quot;  &#125;,  &#123;    &quot;desc&quot;: &quot;错误的密码&quot;,    &quot;username&quot;: &quot;admin&quot;,    &quot;password&quot;: &quot;123123&quot;,    &quot;expect&quot;: &quot;登录失败&quot;  &#125;,  &#123;    &quot;desc&quot;: &quot;错误的用户名和密码&quot;,    &quot;username&quot;: &quot;aaa&quot;,    &quot;password&quot;: &quot;123123&quot;,    &quot;expect&quot;: &quot;登录失败&quot;  &#125;]\n\n# 获取用户名、密码和预期结果，组成[(),(),()]格式（自动化参数化需要的格式）with open(&#x27;test.json&#x27;, encoding=&#x27;utf-8&#x27;) as f:    # buf = f.read()    # print(type(buf), buf)    result = json.load(f)    test_list = []    for info in result:        test_tuple = (info.get(&#x27;username&#x27;), info.get(&#x27;password&#x27;), info.get(&#x27;expect&#x27;))        test_list.append(test_tuple)    print(test_list)\n\n\njson的写入文件对象.write(字符串)不能直接将python的列表和字典作为参数传递。想要将python中的数据类型存为json文件，需要使用json提供的方法，不再使用write\n1. 导包 import json 2. 写(w)方式打开文件3. 写入json.dump(python中的数据类型,文件对象)\n\nimport jsonmy_list = [(&#x27;admin&#x27;, &#x27;123456&#x27;, &#x27;登录成功&#x27;), (&#x27;root&#x27;, &#x27;123456&#x27;, &#x27;登录失败&#x27;), (&#x27;admin&#x27;, &#x27;123123&#x27;, &#x27;登录失败&#x27;),           (&#x27;aaa&#x27;, &#x27;123123&#x27;, &#x27;登录失败&#x27;)]with open(&#x27;info1.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    # json.dump(my_list, f, ensure_ascii=False) #单行显示    # 显示缩进    json.dump(my_list, f, ensure_ascii=False,indent=2) # indent是缩进的意思\n\n\ndef dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True,        allow_nan=True, cls=None, indent=None, separators=None,        default=None, sort_keys=False, **kw)\n\n函数参数列表里，*后面的参数只能以关键字的形式传参，不能使用位置传参\n异常程序运行时，python解释器遇到一个错误，会停止程序的执行，并且提示一些错误信息，这就是异常。\n程序停止执行并且提示错误信息，这个动作是抛出异常（raise）。程序遇到异常，默认动作是终止代码程序的执行。捕获异常可以使代码继续执行，不会终止运行\n异常捕获try:    可能发生异常的代码except: # 任何类型的异常都能去捕获    发生了异常执行的代码   try:    可能发生异常的代码except 异常类型: # 只能捕获特定类型及其子类的异常，如果不是这个异常还是会报错    发生了异常执行的代码\n\nwhile True:    try:        num=input(&#x27;请输入数字&#x27;)        num=int(num)        print(num)    except:        print(&#x27;请输入正确数字&#x27;)    print(&#x27;后续代码仍然运行&#x27;)\n\n\n可以针对不同的异常错误，运行单独的代码处理\ntry:    可能发生的异常的代码except 异常类型1:    发生异常类型1执行的代码# Exception是常见异常类的父类，这里书写Exception可以捕获常见的所有异常，as 变量，变量是一个异常类的对象，print(变量)可以打印异常信息except Exception as 变量:    发生其他类型的异常，执行的代码else:    没有发生异常执行的代码finally:    不论如何都会执行的代码\n\ntry:    可能发生的异常的代码except Exception as e:    发生异常执行的代码\n\n\n\ntry:    num=input(&#x27;请输入数字&#x27;)    num=int(num)    num=20/num    print(num)except ValueError:    print(&#x27;发生了异常，请输入正确数字&#x27;)except ZeroDivisionError:    print(&#x27;不要输入0&#x27;)\n\n\nwhile True:    try:        num=input(&#x27;请输入数字&#x27;)        num=int(num)        num=20/num        print(num)    except Exception as e:        print(f&#x27;错误信息为：&#123;e&#125;&#x27;)    else:        print(&quot;没有发生异常&quot;)    finally:        print(&#x27;我都会执行&#x27;)\n\n\n异常传递python会将异常进行传递。在函数嵌套调用的过程中，被调用的函数发生了异常，如果没有捕获，会将这个异常向外层传递。如果传到最外层还没有捕获，才报错。\n抛出异常raise让代码报错\n模块和包模块（Module）是一个包含 Python 代码的文件。这些文件通常包含了一些函数、类和变量的定义，可以被其他 Python 程序导入并使用。模块使得代码的组织和管理更加方便，同时也可以提高代码的可重用性。\n模块名同样也是一个标识符，需要符合标识符的命名规则\n在模块中定义的全局变量、函数、类都是提供给外界直接使用的工具\n模块就好比是工具包，要使用这个工具包的工具需要先导入这个模块\n自己写的代码想要作为模块使用，代码的名字需要满足标识符的规则\n模块的导入import导入使用模块中的内容：模块名.工具名\nimport 模块1名,模块2名# 使用模块中的内容：模块名.工具名# 举例import randomimport jsonrandom.randint(a,b)json.loadjson.dump\n\nfrom 模块名 import 工具名# 使用工具名# 举例from random import randintfrom json import load,dumprandint(a, b)load()dump()\n\n# 可能存在多个模块之间有名字相同的工具，会造成冲突from 模块名 import * # 将模块中的所有内容都导入# 举例from random import *from json import *randint(a, b)load()dump()\n\n对于导入的模块和工具可以使用as起别名，如果起别名，原来的名字就不能使用了\n模块的查找顺序在导入模块的时候，会先在当前目录中找模块，如果找到，就直接使用。如果没有找到，就回去系统的目录中进行查找，找到就直接使用，没有找到会报错\n注意：在定义代码文件的时候，代码名字不能和要导入的模块名字相同，会造成混淆产生命名冲突，Python 解释器会优先使用当前目录下的同名文件，而不是标准库或其他模块中的同名模块。\n# tool.pydef func():    print(&#x27;我是tools模块中的func方法&#x27;)class Dog:    def __init__(self, name, age):        self.name = name        self.age = age    def play(self):        print(f&#x27;&#123;self.name&#125;在快乐的玩耍&#x27;)######import toolstools.func()dog1 = tools.Dog(&#x27;大黄&#x27;, 3)dog1.play()\n\n\n__name__作用每个代码文件都是一个模块，在导入模块的时候，会执行模块中的方法。\n__name__变量：\n\n是python解释器自动维护的变量\n__name__ 变量，如果代码直接运行，值是&quot;__main__&quot;\n__name__ 变量，如果代码是被导入运行，值是模块名（代码名）\n\n包package包（Package）是一种包含多个模块的目录结构。通常情况下，包是一个目录，包含了一个特殊的 __init__.py 文件和多个模块文件。__init__.py 文件可以为空，也可以包含一些初始化代码。包可以嵌套，即一个包可以包含其他包。\n在python使用的时候不需要可以区分是包还是模块，因为使用方式是一样的\nrandom是一个模块json是一个包\nUnitTest框架是python中自带的单元测试框架。pytest是第三方框架，需要安装。\n对于开发来说，单元测试框架主要用来做单元测试。对测试来说，unittest框架的作用是自动化脚本（用例代码）执行框架，管理运行多个测试用例\n\n为什么使用UnitTest框架？\n能够组织多个用例去执行\n提供丰富的断言方法（让程序代码替人工自动的判断预期结果和实际结果是否相符）\n能够生成测试报告\n\n\n\nUnitTest核心(组成)\nTestCase（最核心的模块）\nunittest.TestCase 类是编写测试用例的基础。你可以通过创建继承自 TestCase 的子类，并在子类中定义测试方法来编写测试用例。每个测试方法都应该以 test_ 开头，这样 unittest 才能识别它们并执行。\n\nTestSuite\n测试套件是一组测试用例的集合。你可以使用 unittest.TestSuite 类来创建一个测试套件，并将多个测试用例添加到这个套件中。这样可以方便地对多个测试用例进行组织和管理。\n\nTestRunner\n测试运行器负责执行测试套件中的测试用例，并生成测试报告。unittest 提供了命令行接口和 GUI 工具来运行测试，并且可以生成详细的测试报告，包括测试结果、运行时间、覆盖率等信息。\n\nTestLoader\nTestLoader（测试加载），对TestSuite（测试套件）功能的补充。自动搜索加载的一种方式，从指定的模块或目录中加载测试用例，并根据一定的规则将它们组织成测试套件。它可以自动发现符合命名规范的测试用例，并将它们添加到测试套件中，以便后续执行。\n\nFixture\nFixture（测试夹具），书写在TestCase代码中，是一个代码结构，可以在每个方法执行前后都会执行的内容（前置代码）。unittest 提供了 setUp() 和 tearDown() 方法，它们分别在每个测试方法执行前后自动调用，用于准备测试环境和清理测试\n\n\nTestCase(测试用例)在这个代码文件中书写真正的用例代码，代码文件的名字必须按照标识符的规则来书写\n步骤：\n\n导包（unittest）\n自定义测试类，新建测试类必须继承unittest.TestCase。运行的时候主模块是TestCase\n在测试类中书写测试方法，测试方法名称必须以test_开头。\n执行用例\n\n&quot;&quot;&quot;学习TestCase模块的书写方法&quot;&quot;&quot;# 1. 导包（unittest）import unittest# 2. 自定义测试类,需要继承UnitTest模块中的TestCase类class TestDemo(unittest.TestCase):    # 3. 在测试类中书写测试方法,即用例代码。目前用print代替    # 测试方法必须以test 开头，_连接    def test_method1(self):        print(&#x27;测试方法1&#x27;)    def test_method2(self):        print(&#x27;测试方法2&#x27;)# 4. 执行用例# 4.1 将光标放在类名后边运行，会执行类中的所有测试方法# 4.2 将光标放在方法名后边运行，只执行当前的方法\n\n\nTestSuite&amp;TestRunnerTestSuite（测试套件）:管理、打包、组装TestCase（测试用例）文件\nTestRunner（测试执行，测试运行）:执行TestSuite（测试套件）\n步骤：\n\n导包（unittest）\n实例化（创建对象）套件对象\n使用套件对象添加用例方法\n实例化运行对象\n使用运行对象去执行套件对象\n\n&quot;&quot;&quot;用来学习testsuite和testrunner&quot;&quot;&quot;# 1. 导包（unittest）import unittestfrom day1.testcase1 import TestDemo1from day1.testcase2 import TestDemo2# 2. 实例化（创建对象）套件对象suite=unittest.TestSuite()# 3. 使用套件对象添加用例方法# 方式一：套件对象.addtest(测试类名(&#x27;方法名&#x27;)),建议直接复制相关名字suite.addTest(TestDemo1(&#x27;test_method1&#x27;))suite.addTest(TestDemo1(&#x27;test_method2&#x27;))suite.addTest(TestDemo2(&#x27;test_method1&#x27;))suite.addTest(TestDemo2(&#x27;test_method2&#x27;))# 方法二：添加一个类里所有以test开头的方法suite.addTest(unittest.makeSuite(ClassName))# 4. 实例化运行对象runner=unittest.TextTestRunner()# 5. 使用运行对象去执行套件对象# 运行对象.run(套件对象)runner.run(suite)\n\n\n&quot;&quot;&quot;用来学习testsuite和testrunner&quot;&quot;&quot;# 1. 导包（unittest）import unittestfrom day1.testcase1 import TestDemo1from day1.testcase2 import TestDemo2# 2. 实例化（创建对象）套件对象suite = unittest.TestSuite()# 3. 使用套件对象添加用例方法# 方法二：将一个测试类中的所有方法添加，套件对象.addTest(unittest.makeSuite(测试类名)))# 缺点：makeSuite()不会提示suite.addTest(unittest.makeSuite(TestDemo1))suite.addTest(unittest.makeSuite(TestDemo2))# 4. 执行测试套件runner = unittest.TextTestRunner()# 5. 使用运行对象去执行套件对象# 运行对象.run(套件对象)runner.run(suite)\n\n\n运行结果中的。表示用例通过，F表示用例不通过（运行结果和预期结果不符合），E代表用例代码有问题。\nmakeSuite()要被python官方弃用！！\n\nTestLoader（测试加载）TestLoader（测试加载）和TestSuite作用是一样的，对TestSuite功能的补充，用来组装测试用例。如果TestCase的代码文件有很多，可以使用TestLoader\n步骤\n\n导包\n实例化测试加载对象并添加用例，得到的是Suite对象\n实例化运行对象\n运行对象执行套件对象\n\n在一个项目中TestCase的代码一般放在一个单独的目录（case）\n# 1. 导包import unittest# 2. 实例化加载对象并添加用例# unittest.TestLoader().discover(&#x27;用例所在的路径&#x27;,&#x27;用例的代码文件名&#x27;)# 用例所在的路径建议使用相对路径，用例的代码文件名可以使用*（任意多个任意字符）通配符。defaultTestLoader = unittest.TestLoader()suite = unittest.TestLoader().discover(&#x27;./case&#x27;, &#x27;*.py&#x27;)# 3. 实例化运行对象runner = unittest.TextTestRunner()# 4. 执行runner.run(suite)# 可以将3、4步变为1步# 即跳过创建runner对象，unittest.TextTestRunner().run(suite)\n\n\n\nTestLoader与TestSuite区别\n\nTestSuite需要手动添加测试用例（可以添加测试类，也可以添加测试类中的某个方法\nTestLoader搜索指定目录下指定开头.py文件并添加测试类中的以test开头的所有的测试方法，不能指定添加方法\n\n\nmakeSuite()方法要被弃用，可以使用TestLoader添加用例\nimport unittestclass MyTestCase(unittest.TestCase):    def test_case1(self):        self.assertEqual(1 + 1, 2)    def test_case2(self):        self.assertTrue(True)    def test_case3(self):        self.assertFalse(False)# 创建一个测试套件suite = unittest.TestLoader().loadTestsFromTestCase(MyTestCase)# 使用 TextTestRunner 运行测试套件，并输出测试结果runner = unittest.TextTestRunner()runner.run(suite)\n\n\n\nFixture（测试夹具）是一个概述，对一个测试用例环境的初始化和销毁就是一个Fixture。在某些特点的情况下会自动去执行\n方法级别写在方法里，在每个测试方法（用例代码）执行前后都会自动调用的结构\n# 方法执行之前def setup(self):    # 每个测试方法执行之前都会执行    pass# 方法执行之后def teardown(self):    # 每个测试方法执行之后都会执行    pass\n\n\n\n类级别在每个测试类中所有方法执行前后都会自动调用的结构（整个类中前后各一次）写在类里面\n类级别的Fixture方法是一个类方法\n# 类中所有方法之前@classmethoddef setupClass(cls):    pass# 类中所有方法之后@classmethoddef teardownClass(cls):    pass\n\n\n\n模块级别在每个代码文件执行前后执行的代码结构，需要写在类的外面，直接定义函数即可\n# 代码文件之前def setupModule():    pass# 代码文件之后def teardownModule():    pass\n\n方法级别和类级别的前后方法不需要同时出现，根据用例代码的需要自行的选择使用\n登录案例import unittestfrom day1.login_1 import loginclass LoginTest(unittest.TestCase):    def setUp(self):# 方法级        &quot;&quot;&quot;每个测试方法执行之前都会先调用的方法&quot;&quot;&quot;        print(&#x27;输入网址...&#x27;)    def tearDown(self):        &quot;&quot;&quot;每个测试方法执行之后都会先调用的方法&quot;&quot;&quot;        print(&#x27;关闭网站...&#x27;)    def test_username_password_ok(self):        print(&#x27;输入正确用户名和密码点击登录1&#x27;)        if login(&#x27;admin&#x27;, &#x27;123456&#x27;) == &#x27;登录成功&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    @classmethod    def setUpClass(cls): #类级别        print(&#x27;1. 打开浏览器&#x27;)    @classmethod    def tearDownClass(cls):        print(&#x27;5. 关闭浏览器&#x27;)    def test_username_error(self):        print(&#x27;输入错误用户名和密码点击登录2&#x27;)        if login(&#x27;root&#x27;, &#x27;123456&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_password_error(self):        if login(&#x27;admin&#x27;, &#x27;123123&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_username_password_error(self):        if login(&#x27;aaa&#x27;, &#x27;123123&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)\n\n\n测试add&quot;&quot;&quot;学习TestCase模块的书写方法&quot;&quot;&quot;# 1. 导包（unittest）import unittestimport tools# 2. 自定义测试类,需要继承UnitTest模块中的TestCase类class TestAdd(unittest.TestCase):    def test_method1(self):        if tools.add(1, 2)==3:            print(&#x27;测试通过&#x27;)        else:            print(&#x27;测试不通过&#x27;)    def test_method2(self):        if tools.add(10,20)==30:            print(&#x27;测试通过&#x27;)        else:            print(&#x27;测试不通过&#x27;)    def test_method3(self):        if tools.add(2, 3)==5:            print(&#x27;测试通过&#x27;)        else:            print(&#x27;测试不通过&#x27;)\n\n\nlogin函数测试def login(username,password):    if username ==&#x27;admin&#x27; and password==&#x27;123456&#x27;:        return &#x27;登录成功&#x27;    else:        return &#x27;登录失败&#x27;\n\nimport unittestfrom day1.login_1 import loginclass LoginTest(unittest.TestCase):    def test_username_password_ok(self):        if login(&#x27;admin&#x27;, &#x27;123456&#x27;) == &#x27;登录成功&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_username_error(self):        if login(&#x27;root&#x27;, &#x27;123456&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_password_error(self):        if login(&#x27;admin&#x27;, &#x27;123123&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_username_password_error(self):        if login(&#x27;aaa&#x27;, &#x27;123123&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)\n\n\n断言让程序代替人工自动判断预期结果和实际结果是否相符\n断言的结果：True-&gt;用例通过，False-&gt;代码抛出异常，用例不通过\npython自带的断言，判断两个字符串是否相等assert &quot;hello&quot; == &quot;hello&quot; assert &quot;hello&quot;==&quot;hello1&quot; &quot;出错啦&quot;\n判断是否包含assert &quot;h&quot; in &quot;hello&quot;\n判断是否为True、False assertTrue assert1 assertFalse assert0\n在unittest中使用断言，都需要通过self.断言方法来试验\nassertEqualassertEqual(预期结果,实际结果)，判断预期结果和实际结果是否相等\n如果相等，用例通过；如果不相等，用例不通过，抛出异常\nimport unittestfrom day1.login_1 import loginclass LoginTest(unittest.TestCase):    def test_username_password_ok(self):        self.assertEqual(&#x27;登录成功&#x27;,login(&#x27;admin&#x27;, &#x27;123456&#x27;))    def test_username_error(self):        self.assertEqual(&#x27;登录失败&#x27;,login(&#x27;root&#x27;, &#x27;123456&#x27;) )    def test_password_error(self):        self.assertEqual(&#x27;登录失败&#x27;, login(&#x27;admin&#x27;, &#x27;123123&#x27;))    def test_username_password_error(self):        self.assertEqual(&#x27;登录失败&#x27;, login(&#x27;aaa&#x27;, &#x27;123123&#x27;))\n\n\n失败：\n\nassertInassertIn(预期结果,实际结果)判断预期结果是否包含于实际结果\n如果包含，用例通过；如果不不包含，用例不通过，抛出异常\nassertTrueassertTrue(ex)判断ex是否为True\n参数化解决相同业务逻辑，不同业务数据\n在测试方法中，使用变量代替具体的测试数据，使用传参的方法将测试数据传递给方法的变量，可以减少相似代码的书写。测试数据一般放在json文件中，使用代码读取json文件，提取要的数据[(),(),()],[[],[]]\nunittest框架本身不支持参数化，需要安装插件完成\n1. 导包 unittest/parameterized2. 定义测试类3. 书写测试方法(用到的测试数据使用变量来代替)4. 组织测试数据并传参\n\nlogin_1代码:\ndef login(username,password):    if username ==&#x27;admin&#x27; and password==&#x27;123456&#x27;:        return &#x27;登录成功&#x27;    else:        return &#x27;登录失败&#x27;\n\n# 1. 导包 unittest/parameterizedimport unittestfrom parameterized import parameterizedfrom day1.login_1 import login# 组织测试数据,按位置传参data = [    (&#x27;admin&#x27;, &#x27;123456&#x27;, &#x27;登录成功&#x27;),    (&#x27;root&#x27;, &#x27;123456&#x27;, &#x27;登录失败&#x27;),    (&#x27;admin&#x27;, &#x27;123123&#x27;, &#x27;登录失败&#x27;),    (&#x27;root&#x27;, &#x27;123123&#x27;, &#x27;登录失败&#x27;)]  # 几组数据就有几组用例# 2. 定义测试类class TestLogin(unittest.TestCase):    # 4. （装饰器@修饰方法）组织测试数据并传参（列表类型,多个参数为列表嵌套元组）    @parameterized.expand(data)    # 3. 书写测试方法(用到的测试数据使用变量来代替)按位置传参    def test_login(self, username, password, expect):        self.assertEqual(expect, login(username, password))\n\n\n通过json导入// test.json[  &#123;    &quot;desc&quot;: &quot;正确的用户名密码&quot;,    &quot;username&quot;: &quot;admin&quot;,    &quot;password&quot;: &quot;123456&quot;,    &quot;expect&quot;: &quot;登录成功&quot;  &#125;,  &#123;    &quot;desc&quot;: &quot;错误的用户名&quot;,    &quot;username&quot;: &quot;root&quot;,    &quot;password&quot;: &quot;123456&quot;,    &quot;expect&quot;: &quot;登录失败&quot;  &#125;,  &#123;    &quot;desc&quot;: &quot;错误的密码&quot;,    &quot;username&quot;: &quot;admin&quot;,    &quot;password&quot;: &quot;123123&quot;,    &quot;expect&quot;: &quot;登录失败&quot;  &#125;,  &#123;    &quot;desc&quot;: &quot;错误的用户名和密码&quot;,    &quot;username&quot;: &quot;aaa&quot;,    &quot;password&quot;: &quot;123123&quot;,    &quot;expect&quot;: &quot;登录失败&quot;  &#125;]\n\n\n\n# 1. 导包 unittest/parameterizedimport unittestfrom parameterized import parameterizedimport jsonfrom day1.login_1 import login# 组织测试数据,按位置传参def build_data():    with open(&#x27;test.json&#x27;, encoding=&#x27;utf-8&#x27;) as f:        res = json.load(f)        data = []        for i in res: #每个i是一个字典元素            testtuple = (i.get(&#x27;username&#x27;), i.get(&#x27;password&#x27;), i.get(&#x27;expect&#x27;))            data.append(testtuple)        return data# 2. 定义测试类class TestLogin(unittest.TestCase, ):    # 4. 组织测试数据并传参（装饰器@）    @parameterized.expand(build_data())    # 3. 书写测试方法(用到的测试数据使用变量来代替)    def test_login(self, username, password, expect):        self.assertEqual(expect, login(username, password))\n\n\n跳过对于一些未完成的或者不满足测试条件的测试函数和测试类可以跳过执行，使用装饰器完成。代码书写在TestCase中\n# 直接将测试函数标记为跳过@unittest.skip(&#x27;跳过原因&#x27;)# 根据条件判断测试函数是否跳过，判断条件成立跳过@unittest.skipIf(condition, reason)# 跳过可以用来修饰类\n\nimport unittestversion = 30class TestDemo(unittest.TestCase):    @unittest.skip(&#x27;没有什么原因就是不想执行&#x27;)    def test_1(self):        print(&#x27;method 1&#x27;)    @unittest.skipIf(version &gt;= 30, &#x27;版本号新，不用测试&#x27;)    def test_2(self):        print(&#x27;method 2&#x27;)    def test_3(self):        print(&#x27;method 3&#x27;)\n\n\n测试报告自带的测试报告：只有单独运行TestCase的代码才能生成测试报告，组装打包的测试用例不能生成\nHTMLTestRunner是一个类库，生成第三方的的测试报告需要用到。\n\n获取第三方的测试运行模块，将其放在代码的目录中\n导包\n使用套件对象，加载对象添加用例方法\n实例化第三方的运行对象并运行套件\n\n组织用例文件（TestCase），书写参数化，书写断言，书写Fixture，书写跳过，如果单个测试文件直接运行，得到测试报告，如果有多个测试文件需要使用套件对象组装、加载对象组装运行生成测试报告。接下来要运行对象，使用第三方运行类进行运行。运行对象.run(套件对象)\n# 1. 获取第三方的测试运行模块，将其放在代码的目录中# 2. 导包import unittestfrom HtmlTestRunner import HTMLTestRunner# 3. 使用套件对象，加载对象添加用例方法suite = unittest.defaultTestLoader.discover(&#x27;.&#x27;, &#x27;parametertest.py&#x27;)# 4. 实例化第三方的运行对象并运行套件  # 测试报告的文件对象（open）要使用wb打开（二进制方法书写）HTMLTestRunner().run(suite)  # 运行对象\n\nunittest自带报告：\n\nhtml报告：\n\n","categories":["Python Learning"],"tags":["Python"]},{"title":"git操作","url":"/2024/03/31/git%E6%93%8D%E4%BD%9C/","content":"初步操作先进入相关的目录，输入\ngit config --global user.name &quot;username&quot;\ngit config --global user.email &quot;email&quot;进行全局配置。输入git init在本地进行初始化，相关目录下会生成.git文件夹\n\n这个文件夹会保存每个git版本和变化\n记录文件初始化后，文件没有被记录，使用git add将文件加进git版本控制系统中，文件全部添加使用git add .。添加后git暂时保存。提交需要使用git commit命令，会出现vim终端编辑器写提交说明。\n\npycharm的terminal按esc退出无效，左键点击terminal的同时按esc。\ngit按行来比对文件的不同。只有新增和删除，同一行的修改则是删除一行，新增一行\n\n提交成功后，可以用git log来查看提交的日志信息（每次git提交都会记录）。\n\ncommit后的字符是随机id，是提交的唯一标识。\n git commit -m &quot;the second try&quot;是写提交说明的简单化操作\n\n修改文件后：\n\n提交规范说明git commit -m &quot;fix(test): change content&quot;\n回退版本硬重置会覆盖所有变更。\n用git log查看几次提交的id，输入git  reset --hard commit id就可以回退到这次提交的状态\n\n后面提交的其他版本也被清空，可以用git reflog查看\nGit分支想要在不同版本切换的好方法，团队也可以利用这个合并（merge）团队合作的代码。\ngit branch branchname创建分支。git branch -a查看当前已建立的分支。\n\n\n使用git checkout branchname进行切换分支操作\n","categories":["GitHub"],"tags":["github"]},{"title":"Overwatch","url":"/2021/07/16/overwatch/","content":"Hello Overwatch!\n","tags":["overwatch"]},{"title":"Web自动化","url":"/2024/03/12/Web%E8%87%AA%E5%8A%A8%E5%8C%96/","content":"自动化测试解决的问题：回归测试、压力测试、兼容性测试。\n自动化测试的误区：自动化测试可以完全代替手工测试，自动化测试一定比手工测试更厉害，自动化测试可以捕获更多的bug，自动化测试适用于所有功能\n\n什么样的web项目适合做自动化测试？\n\n需求变动不频繁\n项目周期长\n项目需要回归测试\n\n\n自动化测试在什么阶段开始–&gt;功能测试完毕（手工测试）\n\nweb自动化属于黑盒测试（功能测试）\n\n元素定位元素定位就是通过元素的信息或元素层级结构来定位\nselenium提供的8种定位元素方式\n1. id2. name3. class_name4. tag_name(&lt;标签名.../&gt;)5. link_text(定位超链接a标签)6. partial_link_text(定位超链接a标签 模糊)7. XPath(基于元素路径)8. CSS(元素选择器)\n\nid定位html规定id属性在整个html文档中必须是唯一的\nel=driver.find_element(by=By.ID, value=&#39;id值&#39;)\n打开百度输入内容进行查询\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()# 打开urlbrowser.get(&quot;https://www.baidu.com&quot;)# 通过id定位搜索框el = browser.find_element(by=By.ID, value=&#x27;kw&#x27;)# 搜索框输入内容el.send_keys(&#x27;怪物猎人&#x27;)# 通过id查找搜索按钮并点击browser.find_element(by=By.ID, value=&#x27;su&#x27;).click()time.sleep(20)browser.quit()\n\n\nname定位html中name属性值是可以重复的\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get(&quot;https://www.baidu.com&quot;)browser.find_element(by=By.NAME,value=&#x27;wd&#x27;).clear()el = browser.find_element(by=By.NAME, value=&#x27;wd&#x27;)el.send_keys(&#x27;索尼&#x27;)browser.find_element(by=By.ID, value=&#x27;su&#x27;).click()time.sleep(20)browser.quit()\n\n\nclass name定位根据元素class属性值定位元素，html通过class来定义元素的样式。如果class有多个属性值，只使用其中一个\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get(&quot;https://www.bilibili.com/&quot;)browser.find_element(by=By.CLASS_NAME, value=&#x27;channel-link&#x27;).click() # 有多个相同元素，返回第一个time.sleep(20)browser.quit()\n\n\n查找第三个\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get(&quot;https://www.bilibili.com/&quot;)browser.find_elements(by=By.CLASS_NAME, value=&#x27;channel-link&#x27;)[2].click()time.sleep(20)browser.quit()\n\n\ntag_name定位通过标签名来定位，一般有多个。如果存在多个相同标签则返回第一个\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bydr = webdriver.Chrome()dr.get(&#x27;https://www.csdn.net/&#x27;)dr.find_elements(By.TAG_NAME, &#x27;dl&#x27;)[0].click()time.sleep(20)\n\n\n\nlink_text定位a标签，link_text定位元素的内容必须全部匹配（不然会报错）\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Byimport timebrowser = webdriver.Chrome()browser.get(&#x27;https://rinta.top/&#x27;)browser.find_element(By.LINK_TEXT,&#x27;Python&#x27;).click()time.sleep(20)\n\n\npartial_link_text模糊匹配linktext定位找到元素，但是要保证唯一性\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Byimport timebrowser = webdriver.Chrome()browser.get(&#x27;https://rinta.top/&#x27;)browser.find_element(By.LINK_TEXT,&#x27;Python&#x27;).click()time.sleep(5)browser.find_element(By.PARTIAL_LINK_TEXT,&#x27;AR&#x27;).click()time.sleep(20)\n\n\nXpathxpath是XML路径定位器，HTML与XML相似，所以也可以用xpath来定位。针对定位到多个元素时也可以下标取值，下标从1开始\n//*[text()=&quot;xxx&quot;]     # 文本内容是xxx的元素//*[contains(@attribute,&#x27;xxx&#x27;)] # 属性中含有xxx的元素//*[starts-with(@attribute,&#x27;xxx&#x27;)] # 属性以xxx开头的元素\n\n\n\n\n\n\n表达式\n描述\n\n\n\nnodename\n选取此节点的所有子节点\n\n\n&#x2F;\n从当前节点选取直接子节点\n\n\n&#x2F;&#x2F;\n从当前节点选取子孙节点\n\n\n.\n选取当前节点\n\n\n. .\n选取当前节点的父节点\n\n\n@\n选取属性\n\n\n*\n任何元素\n\n\n通过路径定位绝对路径：以&#x2F;开头，不能跳级\n相对路径：以&#x2F;&#x2F;开头，后跟元素名称，不知道名称可以用*代替（*代表所有元素）\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bydr = webdriver.Chrome()dr.get(&#x27;https://www.bilibili.com/&#x27;)dr.find_element(By.XPATH, value=&#x27;//*[@id=&quot;i_cecream&quot;]/div[2]/div[1]/div[3]/div[2]/div[1]/a[8]&#x27;).click()# @为添加属性,//开头为相对路径# value=&#x27;//*[@class=&quot;channel-items__left&quot;]/a[8]time.sleep(20)//*\n\n\n\n\n利用元素属性dr.find_element(By.XPATH, value=&#39;//*[@id=&quot;i_cecream&quot;]/div[2]/div[1]/div[3]/div[2]/div[1]/a[8]&#39;).click()# @修饰属性\n属性和逻辑结合通过and连接两个属性\n//*[@id=&#39;id值&#39; and @属性=&#39;属性值&#39;]\n层级与属性结合//*[@id=&#39;父级id值&#39; ]/input\ncss选择器css用来描述html元素的显示样式，在css中，选择题是一种模式用于选择需要添加样式的元素。\ncss定位常用策略：id选择器、class选择器、元素选择器、属性选择器、层级选择器\n符号.代表class, 符号 # 代表id\n# id选择器# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()# 打开urlbrowser.get(&quot;https://www.baidu.com&quot;)# 通过css定位搜索框,#代表idel = browser.find_element(by=By.CSS_SELECTOR, value=&#x27;#kw&#x27;)# 搜索框输入内容el.send_keys(&#x27;怪物猎人&#x27;)time.sleep(20)browser.quit()\n\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()# 打开urlbrowser.get(&quot;https://www.bilibili.com/&quot;)# 通过css定位搜索框,#代表id,结合xpathel = browser.find_element(by=By.CSS_SELECTOR, value=&#x27;#i_cecream &gt; div.bili-feed4 &gt; div.bili-header.large-header &gt; div.bili-header__channel &gt; div.right-channel-container &gt; div.channel-items__left &gt; a:nth-child(6)&#x27;# el = browser.find_element(by=By.CSS_SELECTOR, value=&#x27;.channel-items__left &gt; a:nth-child(6)&#x27;)                     # 搜索框输入内容el.click()time.sleep(20)browser.quit()\n\n\n定位下拉框通过css定位[属性名=属性值]定位\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)# 最大化窗口browser.maximize_window()# 隐式等待，每次查找元素前等待browser.implicitly_wait(10) browser.get(&quot;https://www.ke.com/city/&quot;)time.sleep(5)time.sleep(3)# 找到下拉框元素el = browser.find_elements(By.CSS_SELECTOR, value=&#x27;.chang-city&#x27;)[0]el.click()# []来指定属性值time.sleep(3)browser.find_element(By.CSS_SELECTOR, &#x27;[data-province_id=&quot;130000&quot;]&#x27;).click()time.sleep(10)browser.quit()\n\n\n通过select类定位# value# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()browser.implicitly_wait(10)browser.get(    &quot;https://signup.live.com/signup?lcid=1033&amp;wa=wsignin1.0&amp;rpsnv=13&amp;ct=1667977589&amp;rver=7.0.6737.0&amp;wp=MBI_SSL&amp;wreply=https%3a%2f%2foutlook.live.com%2fowa%2f%3fnlp%3d1%26signup%3d1%26RpsCsrfState%3d03e6f63b-7b44-e3a7-1cec-67445341a6de&amp;id=292841&amp;CBCXT=out&amp;lw=1&amp;fl=dob%2cflname%2cwld&amp;cobrandid=90015&amp;lic=1&amp;uaid=5cd6f6e2004b4d5f96bcb3f20e670a07&quot;)time.sleep(5)browser.find_element(By.CSS_SELECTOR, value=&#x27;#iSignupAction&#x27;).click()time.sleep(3)# 找到下拉框元素# 使id属性定位下拉框el = browser.find_element(By.CSS_SELECTOR, value=&#x27;#LiveDomainBoxList&#x27;)# 使name属性定位下拉框el = browser.find_element(By.CSS_SELECTOR, value=&#x27;[name = LiveDomainBoxList]&#x27;)# option通过value定位Select(el).select_by_value(&#x27;hotmail.com&#x27;)time.sleep(10)browser.quit()\n\n\n# index# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()browser.implicitly_wait(10)browser.get(    &quot;https://signup.live.com/signup?lcid=1033&amp;wa=wsignin1.0&amp;rpsnv=13&amp;ct=1667977589&amp;rver=7.0.6737.0&amp;wp=MBI_SSL&amp;wreply=https%3a%2f%2foutlook.live.com%2fowa%2f%3fnlp%3d1%26signup%3d1%26RpsCsrfState%3d03e6f63b-7b44-e3a7-1cec-67445341a6de&amp;id=292841&amp;CBCXT=out&amp;lw=1&amp;fl=dob%2cflname%2cwld&amp;cobrandid=90015&amp;lic=1&amp;uaid=5cd6f6e2004b4d5f96bcb3f20e670a07&quot;)time.sleep(5)browser.find_element(By.CSS_SELECTOR, value=&#x27;#iSignupAction&#x27;).click()time.sleep(3)# # 找到下拉框元素el = browser.find_element(By.CSS_SELECTOR, value=&#x27;#LiveDomainBoxList&#x27;)# 使用index定位下拉框Select(el).select_by_index(1)time.sleep(10)browser.quit()\n\n# visible_text# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()browser.implicitly_wait(10)browser.get(    &quot;https://signup.live.com/signup?lcid=1033&amp;wa=wsignin1.0&amp;rpsnv=13&amp;ct=1667977589&amp;rver=7.0.6737.0&amp;wp=MBI_SSL&amp;wreply=https%3a%2f%2foutlook.live.com%2fowa%2f%3fnlp%3d1%26signup%3d1%26RpsCsrfState%3d03e6f63b-7b44-e3a7-1cec-67445341a6de&amp;id=292841&amp;CBCXT=out&amp;lw=1&amp;fl=dob%2cflname%2cwld&amp;cobrandid=90015&amp;lic=1&amp;uaid=5cd6f6e2004b4d5f96bcb3f20e670a07&quot;)time.sleep(5)browser.find_element(By.CSS_SELECTOR, value=&#x27;#iSignupAction&#x27;).click()time.sleep(3)# # 找到下拉框元素el = browser.find_element(By.CSS_SELECTOR, value=&#x27;#LiveDomainBoxList&#x27;)# 使用visible_text属性定位下拉框（文本）Select(el).select_by_visible_text(&#x27;hotmail.com&#x27;)time.sleep(3)Select(el).select_by_visible_text(&#x27;outlook.com&#x27;)time.sleep(10)browser.quit()\n\n警告框处理Selenium中对处理弹出框的操作，有专用的处理方法，并且处理方式都一样\n1. 获取弹出框对象alert=driver.switch_to.alert2. 调用alert.text        ---&gt; 返回alert/confirm/prompt中文字信息alert.accept()   ---&gt;接受对话框选项alert.dismiss()  ---&gt;取消对话框选项\n\naler警告框# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()browser.implicitly_wait(20)# 访问urlbrowser.get(&quot;https://www.runoob.com/try/try.php?filename=tryjs_alert&quot;)time.sleep(5)# 点击运行按钮browser.switch_to.frame(&quot;iframeResult&quot;)browser.find_element(By.CSS_SELECTOR, &#x27;[value=&quot;显示警告框&quot;]&#x27;).click()time.sleep(3)# 切换到alert框内alert = browser.switch_to.alert  # 返回alert对话框对象# 获取文本print(alert.text)# 点击确定alert.accept()time.sleep(10)browser.quit()\n\n\nconfirm确认框prompt提示框元素操作.click()单击输入\nclear()清楚文本\nsendkeys()模拟输入，如果要上传本地文件也使用这个\n获取元素信息的常用方法size 返回元素大小\ntext 获取元素文本\nget_attribute(&quot;xxx&quot;) 获取属性值，传递到参数为元素的属性名\nis_displayed() 判断元素在页面上是否可见。\nis_enabled() 判断元素是否可用，即元素是否可以进行交互操作，比如点击、输入等\nis_selected() 判断元素是否选择，用来检查复选框或者单选按钮是否被选中\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.bilibili.com/&quot;)# 获取元素大小print(browser.find_element(By.CSS_SELECTOR,value=&#x27;.nav-search-content&#x27;).size)# 获取元素个数print(len(browser.find_elements(By.CSS_SELECTOR,value=&#x27;.channel-link&#x27;)))time.sleep(2)el1=browser.find_element(By.CSS_SELECTOR,value=&#x27;.nav-search-input&#x27;)el1.send_keys(&#x27;python&#x27;)time.sleep(3)browser.refresh()el=browser.find_elements(By.CSS_SELECTOR,value=&#x27;.channel-link&#x27;)[0]print(el.text)time.sleep(3)# 打印a元素的href属性print(el.get_attribute(&#x27;href&#x27;))el.click()time.sleep(3)# 判断元素是否可见el2=browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[3]print(el2.is_displayed())time.sleep(3)# 元素可见，点击if el2.is_displayed():    el2.click()time.sleep(3)# 判断元素是否可用el3=browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[4]print(el3.is_enabled())if el3.is_enabled():    el3.click()time.sleep(3)# 关闭主窗口browser.close()time.sleep(5)browser.quit()\n\n\n\n浏览器常用操作maximize_window()最大化浏览器窗口\nset_window_size(width,height)设置浏览器窗口大小\nset_window_position设置浏览器窗口位置\nback()模拟浏览器后退\nforward()前进\nrefresh()刷新，在cookie中使用到\nclose()关闭当前窗口\nquit()关闭浏览器驱动对象（会关闭所有窗口）\ntitle获取页面title\ncurrent_url获取当前页面url\n# 实现前进后退# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()# 设置窗口位置browser.set_window_position(320,150)time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.baidu.com/&quot;)browser.get(&quot;https://www.bilibili.com/&quot;)time.sleep(2)# 执行后退browser.back()time.sleep(2)# 执行前进browser.forward()time.sleep(2)browser.quit()\n\n关闭的窗口是创建的主窗口\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.bilibili.com/&quot;)# print(browser.find_element(By.CSS_SELECTOR,value=&#x27;nav-search-content&#x27;).size)time.sleep(2)el1=browser.find_element(By.CSS_SELECTOR,value=&#x27;.nav-search-input&#x27;)el1.send_keys(&#x27;python&#x27;)time.sleep(3)browser.refresh()el=browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[1]time.sleep(2)el.click()print(browser.current_url)time.sleep(2)browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[3].click()time.sleep(3)browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[4].click()time.sleep(3)# 关闭主窗口browser.close()time.sleep(5)browser.quit()\n\n\n\n鼠标和键盘操作鼠标操作click()是元素的事件，不是鼠标的事件。在selenium中操作鼠标的方法封装在ActionChains类中\n实例化对象：action=ActionChains(driver)\n方法：\ncontext_click(element) 右击\ndouble_click(element)双击\ndrag_and_drop(source,target) 拖动\nmove_to_element悬停\nperform()执行以上所有鼠标操作，所有的方法都需要执行才生效\nfrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Byimport timebrowser=webdriver.Chrome()action=ActionChains(browser)browser.get(&#x27;https://www.bilibili.com&#x27;)el1 = browser.find_element(By.CSS_SELECTOR, value=&#x27;.nav-search-input&#x27;)# 右击鼠标action.context_click(el1).perform()el1.send_keys(&#x27;python&#x27;)time.sleep(3)# 双击action.double_click(el1).perform()time.sleep(3)browser.refresh()el2 = browser.find_element(By.CSS_SELECTOR, value=&#x27;.download-client-trigger__icon&#x27;)# 悬停time.sleep(3)action.move_to_element(el2).perform()time.sleep(5)browser.quit()\n\n拖拽：\n# 导包from selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlaction = ActionChains(browser)browser.get(&quot;https://www.baidu.com/&quot;)time.sleep(2)el1 = browser.find_element(By.CSS_SELECTOR, value=&#x27;.title-content-title&#x27;)el2=browser.find_element(By.CSS_SELECTOR,value=&#x27;#kw&#x27;)time.sleep(3)# 将元素el1拖至el2action.drag_and_drop(el1,el2).perform()time.sleep(3)browser.find_element(By.CSS_SELECTOR,value=&#x27;#su&#x27;).click()time.sleep(5)browser.quit()\n\n\ndrag_and_drop_by_offset(source,xoffset,yoffset)通过坐标偏移量执行拖拽\n实例化匿名：ActionChains(driver).double_click(element).perform()\n实名：action=ActionChains(driver)\n键盘操作常用的键盘操作：\nsend_keys(Keys.BACK_SPACE)  删除键\nsend_keys(Keys.SPACE)  空格键\nsend_keys(Keys.TAB)  制表键\nsend_keys(keys.ESCAPE) 回退键\nsend_keys(keys.ENTER)  回车键\nsend_keys(keys.CONTROL,&#39;a&#39;) ctrl+a\nsend_keys(keys.CONTROL,&#39;c&#39;) ctrl+c\n# 导包from selenium import webdriverfrom selenium.webdriver import ActionChains, Keysfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlaction = ActionChains(browser)browser.get(&quot;https://www.baidu.com/&quot;)time.sleep(2)el1 = browser.find_element(By.CSS_SELECTOR, value=&#x27;#kw&#x27;)time.sleep(3)el1.send_keys(&#x27;Python1&#x27;)time.sleep(3)el1.send_keys(Keys.BACK_SPACE)time.sleep(3)el1.send_keys(Keys.CONTROL, &#x27;a&#x27;)time.sleep(3)el1.send_keys(Keys.CONTROL, &#x27;c&#x27;)time.sleep(3)# 粘贴el1.send_keys(Keys.CONTROL, &#x27;v&#x27;)el1.send_keys(Keys.CONTROL, &#x27;v&#x27;)browser.find_element(By.CSS_SELECTOR, value=&#x27;#su&#x27;).click()time.sleep(5)browser.quit()\n\n\n元素等待在定位页面元素如果未找到，会在指定时间内一直等待的过程。在设置的时长内加载出来，会执行代码；没有加载出来则抛出异常\n为什么要设置元素等待？网络速度慢、电脑配置低、服务器处理请求慢\n隐式等待隐式等待为全局设置，设置一次，作用于所有元素。一般为前置必写代码\n定位元素时，如果能定位到元素则直接返回该元素，不触发等待；如果不能定位到该元素，则间隔一段时间后再去定位元素；如果在达到最大时长时还没有找到指定元素，则抛出元素不存在的异常NoSuchElementException\n方法：driver.implicitly_wait(timeout),timeout为等待最大时长，单位秒。\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.baidu.com/&quot;)# 设置隐式等待10sbrowser.implicitly_wait(10)time.sleep(2)# 正确id为kwel1 = browser.find_element(By.CSS_SELECTOR, value=&#x27;#kj&#x27;)el1.send_keys(&#x27;python&#x27;)\n\n\n显式等待对单个的元素有效\n定位元素时，如果能定位到元素则直接返回该元素，不触发等待；如果不能定位到该元素，则间隔一段时间后再去定位元素；如果在达到最大时长时还没有找到指定元素，则抛出超时异常TimeoutException\n1. 导包2. webDriverWait(driver, timeout, poll_frequency=0.5) 1) driver: 浏览器驱动对象 2) timeout: 超时的时长单位秒 3) poll_frequency: 检测间隔时间，默认0.5s3. 调用方法 until(method):直到...时 1) method: 函数名称，该函数用来实现对元素的定位 2) 一般使用匿名函数来实现：lambda x: x.find_element(By.方法,value)4. element = WebDriverWait(driver, 10, 1).util(lambda x: x.find_element(By.,value))\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.wait import WebDriverWait# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.baidu.com/&quot;)# 设置显式等待10s# 正确id为kwel = WebDriverWait(browser, 10, poll_frequency=0.5).until(lambda x: x.find_element(By.CSS_SELECTOR, value=&#x27;#kj&#x27;))# 此时el还不是元素，代码运行起来才是el.send_keys(&#x27;python&#x27;)\n\n\n区别\n显示等待针对单个元素生效，隐式等待针对全局元素生效\n\n滚动条操作html页面元素为动态显示，元素根据滚动条的下拉而加载。\nSelenium没有提供操作滚动条的方法，但是提供了可执行JS脚本的方法，我们通过JS脚本来达到操作滚动条的目的\n1. 设置JS脚本控制滚动条\tjs = &quot;window.scrollTo(0,1000)&quot;\t(0:左边距;1000:上边距 单位:像素)2. selenium调用JS脚本的方法\tdriver.execute_scrip(js)\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https://rinta.top&quot;)time.sleep(5)# 设置js控制语句js = &quot;window.scrollTo(0,10000)&quot;# 滚动条下拉browser.execute_script(js)time.sleep(3)time.sleep(10)browser.quit()\n\n\nframe切换frame是html页面中的一种框架，主要作用是在当前页面的指定区域显示一页面元素\n形式一：&lt;frameset cols=&quot;25%,75%&quot;&gt;    &lt;frame src=&quot;frame_a.htm&quot;&gt;&lt;/frame&gt;\t&lt;fram src=&quot;frame_.htm&quot;&gt;&lt;/fram&gt;&lt;/frameset&gt;形式二：&lt;iframe name=&quot;iframe_a&quot; src=&quot;demo_iframe.htm&quot; width=&quot;200&quot;,height=&quot;200&quot;&gt;&lt;/iframe&gt;\n\nframe切换方法1. 切换到指定frame的方法，frame_reference可以为frame框架的name、id或者定位到的frame元素driver.switch_to.frame(frame_reference)   2. 恢复默认页面,在frame中操作其他页面一定要切换到默认页面driver.switch_to.default_content()\n\n窗口切换Selenium的默认焦点是在主窗口。在selenium中封装了获取当前窗口的句柄、获取所有窗口句柄和切换到指定句柄窗口的方法\n句柄：handle，窗口的唯一识别码\n# 获取当前窗口句柄driver.current_window_handle  # 获取所有窗口句柄driver.window_handles# 切换指定句柄窗口driver.switch_to.window(handle)\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https://www.baidu.com/&quot;)time.sleep(5)# 输入内容并查询browser.find_element(By.CSS_SELECTOR, &#x27;#kw&#x27;).send_keys(&#x27;小润&#x27;)browser.find_element(By.CSS_SELECTOR, &#x27;#su&#x27;).click()time.sleep(3)ch = browser.current_window_handleprint(ch)# 点击词条browser.find_element(By.CSS_SELECTOR, &#x27;._around-mask_bo7t2_14&#x27;).click()# 获取所有窗口句柄handles = browser.window_handlesprint(handles)time.sleep(3)for handle in handles:    # 切换窗口,虽然看到的页面是新打开的小润页面，但是元素定位仍在主窗口    if handle != ch:        browser.switch_to.window(handle)        browser.find_elements(By.CSS_SELECTOR, &#x27;.text_BqlxX&#x27;)[2].click()time.sleep(10)browser.quit()\n\n\n\n窗口截图与验证码窗口截图在执行出错的时候对当前窗口截图保存，可以通过图片直观地看到出错的原因\ndriver.get_screenshot_as_file(imgpath)\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https://www.baidu.com/&quot;)time.sleep(5)# 输入内容并查询browser.find_element(By.CSS_SELECTOR, &#x27;#kw&#x27;).send_keys(&#x27;小润&#x27;)browser.find_element(By.CSS_SELECTOR, &#x27;#su&#x27;).click()time.sleep(3)# 截图browser.get_screenshot_as_file(&#x27;./screenshot.png&#x27;)time.sleep(10)browser.quit()\n\n\n根据时间戳获取截图：\nbrowser.get_screenshot_as_file(&#39;./&#123;&#125;.png&#39;.format(time.strftime(&quot;%Y_%m_%d_%H_%M_%S&quot;)))\n\n验证码selenium中没有对验证码处理的方式\n\n去掉验证码（测试环境下采用）\n设置万能验证码（生产环境和测试环境下采用）\n验证码识别技术（通过Python-tesseract来识别图片类型验证码，识别率很难达到100%）\n记录cookie（通过cookie进行跳过登录）\n\ncookie\ncookie是由web服务器生成的，并且保存至用户浏览器上的小型文本文件，可以包含用户相关信息。\ncookie数据格式：键值对组成（python中的字典）\ncookie产生：客户端请求服务器。如果服务器需要记录该用户状态，就向客户端颁发一个cookie数据\ncookie使用：当浏览器再次请求该网站时，浏览器把请求的数据和cookie数据一同提交给服务器检查该cookie，以此来辨认用户状态\nCookie通常用于以下几个方面：\n\n会话管理：用于跟踪用户的会话信息，例如在用户登录后保持用户的登录状态。\n用户跟踪：用于记录用户的行为和偏好，以便网站提供个性化的体验。\n高级功能：用于实现购物车、记住密码、广告定位等功能。\n安全性：可以用于防止跨站点请求伪造（CSRF）等安全问题。\n\nselenium操作cookie# 1. 获取指定cookie，name为cookie的名称。底层是get_cookies()get_cookie(name)# 2. 获取本网站所有本地cookiesget_cookies()# 3. 添加coockie。cookie_dict:一个字典对象，必选的键包括&#x27;name&#x27; and &#x27;value&#x27;add_cookie(cookie_dict)\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https://www.baidu.com/&quot;)time.sleep(3)# 添加cookie，以登录状态进入browser.add_cookie(&#123;&quot;name&quot;: &quot;BDUSS&quot;,                    &quot;value&quot;: &quot;JwZG4zOUpyQU1RbXI2Z0VmbXVlU0ZuWmY0MUotcVZqcER-N3RqV0l-WUZveHRtSVFBQUFBJCQAAAAAAAAAAAEAAABZR~-XUmlubnQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUW9GUFFvRlSF&quot;&#125;)time.sleep(5)browser.refresh()time.sleep(10)browser.quit()\n\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https://www.baidu.com/&quot;)time.sleep(3)# 添加cookiebrowser.add_cookie(&#123;&quot;name&quot;: &quot;BDUSS&quot;,                    &quot;value&quot;: &quot;JwZG4zOUpyQU1RbXI2Z0VmbXVlU0ZuWmY0MUotcVZqcER-N3RqV0l-WUZveHRtSVFBQUFBJCQAAAAAAAAAAAEAAABZR~-XUmlubnQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUW9GUFFvRlSF&quot;&#125;)# 获取所有的cookies信息cookies=browser.get_cookies()for co in cookies:    print(co)# 获取单个cookiecookie=browser.get_cookie(&quot;name&quot;)print(cookie)print(browser.get_cookie(&#x27;BDUSS&#x27;))time.sleep(5)browser.refresh()time.sleep(10)browser.quit()\n\n\n登录测试案例import timeimport unittestfrom selenium import webdriverfrom selenium.webdriver.common.by import By# 定义测试类class TestJDShop(unittest.TestCase):    # 定义初始化方法    def setUp(self):        url = &#x27;https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F%3Fcu%3Dtrue%26utm_source%3Dbaidu-pinzhuan%26utm_medium%3Dcpc%26utm_campaign%3Dt_288551095_baidupinzhuan%26utm_term%3D0f3d30c8dba7459bb52f2eb5eba8ac7d_0_40173755626041979e00a100eec87380&#x27;        self.driver = webdriver.Chrome()        self.driver.maximize_window()        self.driver.get(url)        self.driver.implicitly_wait(10)    # 定义teardown    def tearDown(self):        # 关闭浏览器对象        time.sleep(2)        self.driver.close()    def test_code_null(self):        driver = self.driver        # 切换至短信登录        driver.find_element(By.CSS_SELECTOR, &#x27;#sms-login&#x27;).click()        # 输入账号        el1 = driver.find_element(By.CSS_SELECTOR, &#x27;#mobile-number&#x27;)        time.sleep(3)        el1.send_keys(&#x27;12345678901&#x27;)        # 点击发送验证码        time.sleep(3)        el2 = driver.find_element(By.CSS_SELECTOR, &#x27;#send-sms-code-btn&#x27;)        el2.click()        # 输入验证码        time.sleep(3)        el3 = driver.find_element(By.CSS_SELECTOR, &#x27;#sms-code&#x27;)        el3.send_keys(&#x27;324678&#x27;)        # 点击登录        time.sleep(3)        driver.find_element(By.CSS_SELECTOR, &#x27;#sms-login-submit&#x27;).click()        # 获取错误提示信息        text = driver.find_element(By.CSS_SELECTOR, &#x27;.sms-box-error-msg&#x27;).text        expect_text = &#x27;验证码为空&#x27;        print(text)        try:            self.assertEqual(text, expect_text)        except AssertionError:            driver.get_screenshot_as_file(&#x27;./&#123;&#125;.png&#x27;.format(time.strftime(&quot;%Y_%m_%d_%H_%M_%S&quot;)))            # 抛异常，有异常捕获不抛出会显示test pass            raise\n\n\n\nPO模式PO：page（页面），objecr（对象）\nv1：不采用任何模型（线性模型）\nv2：采用unittest框架\nv3：业务代码和页面对象进行分离\nv4：实际中的PO模式编写\nv1不能实现批量执行\n# 淘宝界面，用不了import timefrom selenium import webdriverfrom selenium.webdriver.common.by import By# 测试之前的前置工作# 实例化对象browser=webdriver.Chrome()# 窗口最大化browser.maximize_window()# 获取urlbrowser.get(&#x27;https://login.taobao.com/member/login.jhtml?spm=a21bo.jianhua.754894437.1.5af92a89NKrwFE&amp;f=top&amp;redirectURL=https%3A%2F%2Fwww.taobao.com%2F&#x27;)browser.implicitly_wait(10)# 切换至短信登录# 点击切换按钮time.sleep(3)browser.find_element(By.XPATH,&#x27;//*[@id=&quot;login&quot;]/div[2]/div/div[2]/a[1]&#x27;).click()time.sleep(3)# 输入错误的usernameel1=browser.find_element(By.CSS_SELECTOR,&#x27;#fm-login-id&#x27;)el1.send_keys(&#x27;15234567888&#x27;)# 输入正确的密码time.sleep(2)el2=browser.find_element(By.CSS_SELECTOR,&#x27;#fm-login-password&#x27;)el2.send_keys(&#x27;Rinta1343&#x27;)# 点击登录time.sleep(10)browser.find_element(By.CSS_SELECTOR,&#x27;.class=&quot;fm-button fm-submit password-login&#x27;).click()# 获取错误提示信息time.sleep(1)msg=browser.find_element(By.CSS_SELECTOR,&#x27;.login-error-msg&#x27;)assert msg == &#x27;账号名或登录密码不正确&#x27;# 结束工作，关闭对象time.sleep(5)browser.quit()\n\n验证密码：\nimport timefrom selenium import webdriverfrom selenium.common import NoSuchElementExceptionfrom selenium.webdriver.common.by import By# 测试之前的前置工作# 实例化对象browser=webdriver.Chrome()# 窗口最大化browser.maximize_window()# 获取urlbrowser.get(&#x27;http://demo5.tp-shop.cn/&#x27;)browser.implicitly_wait(10)# 跳转到登录页面time.sleep(3)# 输入错误的usernamebrowser.find_element(By.LINK_TEXT,&#x27;登录&#x27;).click()el1=browser.find_element(By.CSS_SELECTOR,&#x27;#username&#x27;)el1.send_keys(&#x27;13800138006&#x27;)# 输入错误的密码time.sleep(2)el2=browser.find_element(By.CSS_SELECTOR,&#x27;#password&#x27;)el2.send_keys(&#x27;123456&#x27;)# 点击登录time.sleep(10)browser.find_element(By.CSS_SELECTOR,&#x27;.J-login-submit&#x27;).click()# 如果有消息链接，则登录成功，截图# el3=browser.find_element(By.CSS_SELECTOR,&#x27;.J-umsg&#x27;)try:    # 尝试定位元素    el3=browser.find_element(By.CSS_SELECTOR,&#x27;.J-umsg&#x27;)    print(&#x27;登录成功&#x27;)    browser.get_screenshot_as_file(&#x27;./success.png&#x27;)except NoSuchElementException:    print(&#x27;登录失败&#x27;)    browser.get_screenshot_as_file(&#x27;./fail.png&#x27;)# 结束工作，关闭对象time.sleep(5)browser.quit()\n\n\n换成正确密码：\nel2.send_keys(&#x27;soubao0316&#x27;)\n\n\n缺点：数据和代码操作融合在一起，单线操作\nv2可以批量运行，代码冗余量大。没有实现页面对象与业务脚本的分离\nimport timeimport unittestfrom selenium import webdriverfrom selenium.webdriver.common.by import By# 新建测试类class TestLogin(unittest.TestCase):    browser = None    # 测试之前的前置工作    @classmethod    def setUpClass(cls):        # 实例化对象        cls.browser = webdriver.Chrome()        # 窗口最大化        cls.browser.maximize_window()        # 获取url        cls.browser.get(&#x27;http://localhost/iwebshopmaster/&#x27;)        cls.browser.implicitly_wait(10)    @classmethod    def tearDownClass(cls):        # 结束工作，关闭对象        time.sleep(5)        cls.browser.quit()    def test_login_username_not_exist(self):        browser = self.browser        # 切换至登录界面        time.sleep(3)        browser.find_element(By.LINK_TEXT, &#x27;登录&#x27;).click()        time.sleep(3)        # 输入错误的username        el1 = browser.find_element(By.NAME, &#x27;login_info&#x27;)        el1.clear()        el1.send_keys(&#x27;abc&#x27;)        # 输入正确的密码        time.sleep(2)        el2 = browser.find_element(By.NAME, &#x27;password&#x27;)        el2.clear()        el2.send_keys(&#x27;123456&#x27;)        # 点击登录        time.sleep(10)        browser.find_element(By.CSS_SELECTOR, &#x27;.submit_login&#x27;).click()        # 获取错误提示信息        time.sleep(1)        msg = browser.find_element(By.CSS_SELECTOR, &#x27;.prompt&#x27;)        try:            # 错误的断言import timeimport unittestfrom selenium import webdriverfrom selenium.webdriver.common.by import By# 新建测试类class TestLogin(unittest.TestCase):    browser = None    # 测试之前的前置工作    @classmethod    def setUpClass(cls):        # 实例化对象        cls.browser = webdriver.Chrome()        # 窗口最大化        cls.browser.maximize_window()        # 获取url        cls.browser.get(&#x27;http://localhost/iwebshopmaster/&#x27;)        cls.browser.implicitly_wait(10)    @classmethod    def tearDownClass(cls):        # 结束工作，关闭对象        time.sleep(5)        cls.browser.quit()    def test_login_username_not_exist(self):        browser = self.browser        # 切换至登录界面        time.sleep(3)        browser.find_element(By.LINK_TEXT, &#x27;登录&#x27;).click()        time.sleep(3)        # 输入错误的username        el1 = browser.find_element(By.NAME, &#x27;login_info&#x27;)        el1.clear()        el1.send_keys(&#x27;abc&#x27;)        # 输入正确的密码        time.sleep(2)        el2 = browser.find_element(By.NAME, &#x27;password&#x27;)        el2.clear()        el2.send_keys(&#x27;123456&#x27;)        # 点击登录        time.sleep(10)        browser.find_element(By.CSS_SELECTOR, &#x27;.submit_login&#x27;).click()        # 获取错误提示信息        time.sleep(1)        msg = browser.find_element(By.CSS_SELECTOR, &#x27;.prompt&#x27;).text        try:            self.assertEqual(msg, &#x27;账号名或登录密码不正确&#x27;)        except AssertionError:            browser.get_screenshot_as_file(&#x27;./failusername.png&#x27;)    def test_login_password_err(self):        browser = self.browser        # 切换至短信登录        # 点击切换按钮        time.sleep(3)        browser.find_element(By.LINK_TEXT, &#x27;登录&#x27;).click()        time.sleep(3)        # 输入正确的username        el1 = browser.find_element(By.NAME, &#x27;login_info&#x27;)        el1.clear()        el1.send_keys(&#x27;ab&#x27;)        # 输入错误的密码        time.sleep(2)        el2 = browser.find_element(By.NAME, &#x27;password&#x27;)        el2.clear()        el2.send_keys(&#x27;1234567&#x27;)        # 点击登录        time.sleep(10)        browser.find_element(By.CSS_SELECTOR, &#x27;.submit_login&#x27;).click()        # 获取错误提示信息        time.sleep(1)        msg = browser.find_element(By.CSS_SELECTOR, &#x27;.prompt&#x27;).text        try:            self.assertEqual(msg, &#x27;账号或密码错误&#x27;)        except AssertionError:            browser.get_screenshot_as_file(&#x27;../reports/failpassword.png&#x27;)            self.assertEqual(msg, &#x27;账号名或登录密码不正确&#x27;)        except AssertionError:            browser.get_screenshot_as_file(&#x27;./failusername.png&#x27;)    def test_login_password_err(self):        browser = self.browser        # 切换至短信登录        # 点击切换按钮        time.sleep(3)        browser.find_element(By.LINK_TEXT, &#x27;登录&#x27;).click()        time.sleep(3)        # 输入正确的username        el1 = browser.find_element(By.NAME, &#x27;login_info&#x27;)        el1.clear()        el1.send_keys(&#x27;ab&#x27;)        # 输入错误的密码        time.sleep(2)        el2 = browser.find_element(By.NAME, &#x27;password&#x27;)        el2.clear()        el2.send_keys(&#x27;1234567&#x27;)        # 点击登录        time.sleep(10)        browser.find_element(By.CSS_SELECTOR, &#x27;.submit_login&#x27;).click()        # 获取错误提示信息        time.sleep(1)        msg = browser.find_element(By.CSS_SELECTOR, &#x27;.prompt&#x27;)        try:            # 正确的断言            self.assertEqual(msg, &#x27;账号或密码错误&#x27;)        except AssertionError:            browser.get_screenshot_as_file(&#x27;../reports/failpassword.png&#x27;)\n\n\nv3页面层以page开头，业务层以test开头\n\n页面层级清晰，但是代码冗余量大\n页面层代码page_login.py:\n&quot;&quot;&quot;页面对象层    页面对象编写技巧：        类名：使用大驼峰将模块名称抄进来，有下划线去掉下划线        方法：根据业务需求每个操作步骤单独封装一个方法            方法名：page_XXX&quot;&quot;&quot;from selenium import webdriverfrom selenium.webdriver.common.by import Byclass PageLogin:    def __init__(self):        # 获取driver对象        self.driver = webdriver.Chrome()        # 最大化浏览器        self.driver.maximize_window()        # 隐式等待        self.driver.implicitly_wait(10)        # 打开url        self.driver.get(&#x27;http://localhost/iwebshopmaster/&#x27;)    # 点击登录链接    def page_click_login(self):        self.driver.find_element(By.LINK_TEXT, &#x27;登录&#x27;).click()    # 输入用户名    def page_input_username(self, username):        self.driver.find_element(By.NAME, &#x27;login_info&#x27;).send_keys(username)    # 输入密码    def page_input_pwd(self, pwd):        self.driver.find_element(By.NAME, &#x27;password&#x27;).send_keys(pwd)    # 点击登录    def page_click_login_btn(self):        self.driver.find_element(By.CLASS_NAME, &#x27;submit_login&#x27;).click()    # 获取异常提示    def page_get_text(self):        return self.driver.find_element(By.CSS_SELECTOR, &#x27;.prompt&#x27;).text    # 组装登录业务方法给业务层调用    def page_login(self, username, pwd):        # 切换至登录界面        self.page_click_login()        # 输入用户名        self.page_input_username(username)        # 输入密码        self.page_input_pwd(pwd)        # 点击登录        self.page_click_login_btn()\n\n业务层代码test_login：\n# 导包import timeimport unittestfrom parameterized import parameterizedfrom po.v3.page.page_login import PageLogin# 新建测试类class TestLogin(unittest.TestCase):    # 初始化方法    def setUp(self):        # 创建page对象        self.login = PageLogin()    # 结束方法    def tearDown(self):        # 关闭驱动对象        self.login.driver.quit()    # 新建测试方法    # 参数化    @parameterized.expand([(&#x27;abc&#x27;, &#x27;123456&#x27;, &#x27;账号不存在&#x27;), (&#x27;ab&#x27;, &#x27;123123&#x27;, &#x27;密码错误&#x27;)])    def test_login(self, username, pwd, expect):        # 调用测试登录方法        self.login.page_login(username, pwd)        # 获取登录信息        msg = self.login.page_get_text()        try:            # 断言            self.assertEqual(msg, expect)        except AssertionError:            self.login.driver.get_screenshot_as_file(&#x27;./&#123;&#125;.png&#x27;.format(time.strftime(&quot;%Y_%m_%d_%H_%M_%S&quot;)))\n\n\nv4抽取v3版本的page页面公共方法—&gt;base（基类&#x2F;工具层）\npage（页面对象）：一个页面封装成一个对象，继承base\nscripts（业务层）：导包调用page页面\n\nbase&#x2F;base.py\nimport timefrom selenium.webdriver.chrome.service import Servicefrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium import webdriverclass Base:    chrome_testing_path=r&quot;D:\\chrometest\\chrome-win64\\chrome.exe&quot;    chromedriver_path=r&quot;D:\\chrometest\\chrome-win64\\chromedriver.exe&quot;    options = webdriver.ChromeOptions()    options.binary_location = chrome_testing_path    options.add_experimental_option(&#x27;detach&#x27;, True)    service=Service(chromedriver_path)    # 初始化    def __init__(self):        self.driver = webdriver.Chrome(service=self.service,options=self.options)        self.driver.maximize_window()        self.driver.get(            &#x27;http://localhost/iwebshopmaster&#x27;)    # 查找元素方法（提供：点击、输入、获取文本)    def base_find_element(self, loc, timeout=30, poll_frequency=0.5):        # 封装显示等待,会返回元素        return WebDriverWait(self.driver, timeout=timeout, poll_frequency=poll_frequency).until(            lambda x: x.find_element(*loc))    # 点击方法    def base_click(self, loc):        self.base_find_element(loc).click()    # 输入方法    def base_input(self, loc, value):        el = self.base_find_element(loc)        # 清空内容        el.clear()        # 输入        el.send_keys(value)    # 获取文本方法    def base_get_text(self, loc):        return self.base_find_element(loc).text    # 截图方法    def base_get_img(self):        self.driver.get_screenshot_as_file(&quot;../img/&#123;&#125;.png&quot;.format(time.strftime(&quot;%Y_%m_%d_%H_%M_%S&quot;)))\n\npage&#x2F;_init_.py：存放loc（查找元素的参数）：\nfrom selenium.webdriver.common.by import By# 以下为登录页面元素配置信息# 登录链接login_link = By.LINK_TEXT, &quot;登录&quot;# 用户名login_username = By.NAME, &quot;login_info&quot;# 密码login_pwd = By.NAME, &quot;password&quot;# 点击按钮login_btn = By.CSS_SELECTOR, &quot;.submit_login&quot;# 提示信息login_msg = By.CSS_SELECTOR, &quot;.prompt&quot;\n\npage&#x2F;page_login.py：定义page类（继承自base）\nfrom po.v4 import pagefrom po.v4.base.base import Baseclass PageLogin(Base):    # 点击登录链接    def page_click_login_link(self):        self.base_click(page.login_link)    # 输入用户名    def page_input_username(self, username):        self.base_input(page.login_username, username)    # 输入密码    def page_input_pwd(self, pwd):        self.base_input(page.login_pwd, pwd)    # 点击登录    def page_click_login_btn(self):        self.base_click(page.login_btn)    # 获取异常信息    def page_get_text(self):        return self.base_get_text(page.login_msg)    # 截图    def page_get_screenshot(self):        self.base_get_img()    # 组装页面的操作：输入用户名、密码、点击登录    def page_login(self, username, pwd):        self.page_input_username(username)        self.page_input_pwd(pwd)        self.page_click_login_btn()\n\nscripts：\n# 导包import unittestfrom parameterized import parameterizedfrom po.v4.page.page_login import PageLogindef get_data():    return [(&#x27;abc&#x27;, &#x27;123456&#x27;, &#x27;账号不存在&#x27;), (&#x27;ab&#x27;, &#x27;123123&#x27;, &#x27;密码错误&#x27;)]# 新建测试类并继承class TestLogin(unittest.TestCase):    login = None    # setUP    @classmethod    def setUpClass(cls):        # 实例化获取页面对象PageLogin        cls.login = PageLogin()        # 点击登录        cls.login.page_click_login_link()    # tearDown    @classmethod    def tearDownClass(cls):        # 关闭驱动对象        cls.login.driver.quit()    @parameterized.expand(get_data())    def test_login(self, username, pwd, expect):        # 调用登录方法        self.login.page_login(username, pwd)        # 获取登录提示信息        msg = self.login.page_get_text()        # 断言        try:            self.assertEqual(msg, expect)        except AssertionError:            # 截图            self.login.page_get_screenshot()\n\n\n数据驱动以数据来驱动整个测试用例的执行，也就是测试数据决定测试结果，可以将用户的关注点放在测试数据的构建和维护上，而不是直接维护脚本，可以利用同样的过程对不同的数据进行测试，实现要依赖参数化。\n数据驱动常用的格式：json、xml、excel、csv、txt\njson的底层是字符串，和字典有区别\npython字典和json之间的转换python字典–&gt;json字符串dumps()\ndata = &#123;    &#x27;id&#x27;:1,    &#x27;name&#x27;:&#x27;Tom&#x27;,    &#x27;address&#x27;:&#x27;北京市海淀区&#x27;,    &#x27;school&#x27;:None&#125;json_str=json.dumps(data) #jump()是写\n\nimport jsondata = &#123;    &#x27;id&#x27;: 1,    &#x27;name&#x27;: &#x27;Tom&#x27;,    &#x27;address&#x27;: &#x27;北京市海淀区&#x27;,    &#x27;school&#x27;: None&#125;print(type(data))json_str = json.dumps(data)print(json_str)print(type(json_str))\n\n\njson字符串–&gt;dict键名必须在””中\nloads()\njson_str = &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;,&quot;address&quot;:&quot;北京市海淀&quot;,&quot;school&quot;:null&#125;&#x27;dict_data=json.loads(json_str)# loads()为读取json\n\nimport jsonjson_str = &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;,&quot;address&quot;:&quot;北京市海淀&quot;,&quot;school&quot;:null&#125;&#x27;dict_data=json.loads(json_str)print(type(json_str))print(dict_data)print(type(dict_data))\n\n\njson读写写jsondump()\nimport jsonparam = &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;,&quot;address&quot;:&quot;北京市&quot;,&quot;school&quot;:null&#125;&#x27;with open(&#x27;../test_write.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    json.dump(param, f, ensure_ascii=False)\n\n读jsonload()\nimport jsonwith open(&#x27;../test_write.json&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:    data = json.load(f)    print(data)\n\n将登录模块改为json数据驱动test_login.py:\n# 导包import jsonimport unittestfrom parameterized import parameterizedfrom po.v4.page.page_login import PageLogindef get_data():    # return [(&#x27;abc&#x27;, &#x27;123456&#x27;, &#x27;账号不存在&#x27;), (&#x27;ab&#x27;, &#x27;123123&#x27;, &#x27;密码错误&#x27;)]    with open(&#x27;../data/test_data.json&#x27;, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f:        data = json.load(f)        test_list=[]        for data in data:            test_tuple= (data.get(&quot;username&quot;),data.get(&quot;pwd&quot;),data.get(&quot;expect&quot;))            test_list.append(test_tuple)    return test_list# 新建测试类并继承class TestLogin(unittest.TestCase):    login = None    # setUP    @classmethod    def setUpClass(cls):        # 实例化获取页面对象PageLogin        cls.login = PageLogin()        # 点击登录        cls.login.page_click_login_link()    # tearDown    @classmethod    def tearDownClass(cls):        # 关闭驱动对象        cls.login.driver.quit()    @parameterized.expand(get_data())    def test_login(self, username, pwd, expect):        # 调用登录方法        self.login.page_login(username, pwd)        # 获取登录提示信息        msg = self.login.page_get_text()        # 断言        try:            self.assertEqual(msg, expect)        except AssertionError:            # 截图            self.login.page_get_screenshot()\n\njson文件：\n有几组数据就有几个testcase\n[  &#123;    &quot;username&quot;: &quot;abc&quot;,    &quot;pwd&quot;: 123456,    &quot;expect&quot;: &quot;账号不存在&quot;  &#125;,  &#123;    &quot;username&quot;: &quot;ab&quot;,    &quot;pwd&quot;: 1234567,    &quot;expect&quot;: &quot;密码错误&quot;  &#125;,  &#123;    &quot;username&quot;: &quot;a&quot;,    &quot;pwd&quot;: 123456,    &quot;expect&quot;: &quot;账号不合法&quot;  &#125;,  &#123;    &quot;username&quot;: &quot;ab&quot;,    &quot;pwd&quot;: 12345,    &quot;expect&quot;: &quot;密码错误&quot;  &#125;]\n\n\n注意：操作时间过快会导致截图被覆盖，本来要截四张图变成两张\n\n网页计算器案例base: 查找元素、点击、获取value属性、截图\nbase&gt;base.py\nimport timefrom selenium.webdriver.support.wait import WebDriverWaitclass Base:    # 初始化方法    def __init__(self, driver):        self.driver = driver    # 查找元素    def base_find_element(self, loc, timeout=30, poll=0.5):        &quot;&quot;&quot;        :param loc: 元素的定位信息，格式为元组        :param timeout: 默认超时时间，可以修改        :param poll: 访问频率莫，默认0.5        :return: 返回查找的元素        &quot;&quot;&quot;        return WebDriverWait(self.driver,                             timeout=timeout,                             poll_frequency=poll).until(lambda x: x.find_element(*loc))    # 查找元素并点击    def base_click(self, loc):        self.base_find_element(loc).click()    # 获取value    def base_value_get(self, loc):        # get_attribute()获取属性值        return self.base_find_element(loc).get_attribute(&quot;value&quot;)    def base_get_screenshot(self):        self.driver.get_screenshot_as_file(&quot;&#123;&#125;.png&quot;.format(time.strftime(&quot;%Y_%m_%d_%H_%M_%S&quot;)))\n\nbase&gt;get_driver.py\nfrom selenium import webdriverfrom cal_test import pageclass GetDriver:    driver=None    @classmethod    def get_driver(cls):        if cls.driver is None:            # 实例化浏览器            cls.driver=webdriver.Chrome()            # 最大化            cls.driver.maximize_window()            # 打开浏览器            cls.driver.get(page.url)        return cls.driver    @classmethod    def quit_driver(cls):        if cls.driver:            cls.driver.quit()            cls.driver=None\n\ndata：\n&#123;  &quot;calc_001&quot;:&#123;&quot;a&quot;: 1,&quot;b&quot;: 2,&quot;expect&quot;: 3&#125;,  &quot;calc_002&quot;:&#123;&quot;a&quot;: 33,&quot;b&quot;: 12,&quot;expect&quot;: 45&#125;,  &quot;calc_003&quot;: &#123;&quot;a&quot;: 1212,&quot;b&quot;: 12,&quot;expect&quot;: 1224&#125;,  &quot;calc_004&quot;: &#123;&quot;a&quot;: 1211,&quot;b&quot;: 11,&quot;expect&quot;: 1222&#125;,  &quot;calc_005&quot;: &#123;&quot;a&quot;: 1213,&quot;b&quot;: 13,&quot;expect&quot;: 1226&#125;&#125;\n\npage&gt;_init_.py\n&quot;&quot;&quot;以下为计算器配置数据&quot;&quot;&quot;from selenium.webdriver.common.by import By# 数字键有一定的规律，先暂时不定位此键# 服务器域名地址url=&quot;http://cal.apple886.com/&quot;# 加号calc_add=By.CSS_SELECTOR,&#x27;#simpleAdd&#x27;# 等号calc_equal=By.CSS_SELECTOR,&#x27;#simpleEqual&#x27;# 获取结果calc_res=By.CSS_SELECTOR,&#x27;#resultIpt&#x27;# 清平calc_clear=By.CSS_SELECTOR,&#x27;#simpleClearAllBtn&#x27;\n\npage&gt;page_calc.py\nfrom selenium.webdriver.common.by import Byfrom cal_test import pagefrom cal_test.base.base import Baseclass PageCalc(Base):    # 点击数字方法    def page_click_num(self, num):        for n in str(num):            # 拆开单个按钮的定位方式            loc = By.CSS_SELECTOR, &#x27;#simple&#123;&#125;&#x27;.format(n)            self.base_click(loc)    # 点击加号方法    def page_click_add(self):        self.base_click(page.calc_add)    # 点击等号    def page_click_eq(self):        self.base_click(page.calc_equal)    # 获取结果    def page_get_res(self):        return self.base_value_get(page.calc_res)    # 点击清屏    def page_clear(self):        self.base_click(page.calc_clear)    # 截屏    def page_get_screenshot(self):        self.base_get_screenshot()    # 组装    def page_add_calc(self, a, b):        self.page_click_num(a)        self.page_click_add()        self.page_click_num(b)        self.page_click_eq()\n\nscripts：\nimport unittestfrom parameterized import parameterizedfrom cal_test.base.get_driver import GetDriverfrom cal_test.page.page_calc import PageCalcfrom cal_test.tools.read_json import read_jsondef get_data():    datas = read_json(&quot;calc.json&quot;)    arrs = []    for data in datas.values():        arrs.append((data.get(&quot;a&quot;), data.get(&quot;b&quot;), data.get(&quot;expect&quot;)))    return arrsclass TestCalc(unittest.TestCase):    driver = None    # setup    @classmethod    def setUpClass(cls):        # 初始化计算页面对象        cls.driver = GetDriver().get_driver()        cls.calc = PageCalc(cls.driver)    # teardown()    @classmethod    def tearDownClass(cls):        # 关闭driver        GetDriver().quit_driver()    # 测试方法    @parameterized.expand(get_data())    def test_add_calc(self, a, b, expect):        # 调用计算业务方法        self.calc.page_add_calc(a, b)        # 断言        # 截图        try:            self.assertEqual(self.calc.page_get_res(), str(expect))        except AssertionError:            self.calc.base_get_screenshot()            raise\n\ntools&gt;read_json.py：\n# 导包import json# 调用load方法def read_json(filename):    filepath=&quot;../data/&quot;+filename    with open(filepath, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:        return json.load(f)\n\n日志可以查看错误提示信息。日志记录系统运行时的信息\n作用：\n\n调试程序\n了解系统程序运行的情况是否正常\n系统程序运行故障分析与问题定位\n用来做用户行为分析和数据统计\n\n日志级别即日志信息的优先级、重要性或严重程度\n\n\n\n日志级别\n描述\n\n\n\nDEBUG\n调试级别，打印非常详细的日志信息，通常用于对代码的的调试\n\n\nINFO\n信息级别，打印一般的日志信息，突出强调程序的运行过程\n\n\nWARNING\n警告级别，打印警告日志信息，潜在错误的情形\n\n\nERROR\n错误级别，打印错误异常信息，该级别的错误可能导致系统的一些功能无法正常执行\n\n\nCRITICAL\n严重错误级别，一个严重错误，系统可能无法继续运行\n\n\n为程序指定一个日志级别后，程序会记录所有日志级别大于或等于指定级别的信息。一般建议只使用DEBUG、INFO、WARNING、ERROR\nlogging模块import logging# 调用指定级别，输入日志信息logging.debug(&quot;this is a debug !&quot;)logging.info(&quot;this is a info&quot;)logging.warning(&quot;this is a warning&quot;)logging.error(&quot;this is a error&quot;)logging.critical(&quot;this is a critical&quot;)\n\n默认设置信息级别是warning\n\n设置日志级别：\nimport logging# 设置级别logging.basicConfig(level=logging.DEBUG)  # DEBUG是给常量，debug是方法# 调用指定级别，输入日志信息logging.debug(&quot;this is a debug !&quot;)logging.info(&quot;this is a info&quot;)logging.warning(&quot;this is a warning&quot;)logging.error(&quot;this is a error&quot;)logging.critical(&quot;this is a critical&quot;)\n\n\n设置日志格式import logging# 设置格式fmt=&quot;%(asctime)s %(levelname)s [%(name)s] [%(filename)s%(funcName)s:%(lineno)d] - %(message)s&quot;# 设置级别、格式logging.basicConfig(level=logging.DEBUG,format=fmt)  # DEBUG是给常量，debug是方法# 调用指定级别，输入日志信息logging.debug(&quot;this is a debug !&quot;)logging.info(&quot;this is a info&quot;)logging.warning(&quot;this is a warning&quot;)logging.error(&quot;this is a error&quot;)logging.critical(&quot;this is a critical&quot;)\n\n\n保存到文件# 设置级别、格式、保存到指定文件logging.basicConfig(level=logging.DEBUG,format=fmt,filename=&#x27;..\\log\\log01.log&#x27;)\n\n\n","tags":["test"]},{"title":"web应用","url":"/2024/03/30/web%E5%BA%94%E7%94%A8/","content":"网络体系计算机网络是用通信设备和线路将分散在不同地点的有独立功能的多个计算机系统互相连接起来，并按照网络协议进行数据通信，实现资源共享的计算机集合。\n网络分类范围划分\n局域网LAN（local area network）\n范围较小，几公里作用，一栋楼房或者一个单位\n\n广域网WAN（wide area network）\n\n范围通常为几十~几千公里，也称为远程网\n\n\n域域网或市域网（metropolitan area network）\n范围在广域网和局域网之间，例如一个城市\n\n\n拓扑结构划分\n星型\n总线型\n环型\n树形\n网状\n\n协议为进行数据交换而建立的规则、标准或约定。协议庞大且复杂但不绝对可靠\n网络分层\n\n优点：\n1、使复杂系统简化\n2、易于维护、系统的更新\n3、某层功能变化不会影响系统的其他部分\n缺点：\n1、有些功能可能在不同层次重复出现\n2、某层的功能可能需要仅存在其他某层的信息\n物理层网线\n强制解调器即猫，它能把计算机的数字信号翻译成可沿普通电话线传送的模拟信号，而这些模拟信号又可被线路另一端的另一个调制解调器接收，并译成计算机可懂的语言。这一简单过程完成了两台计算机间的通信。\n数据链路层mac二层交换机：工作于OSI模型的第二层的交换机，故称为二层交换机，可以识别数据包中的mac地址信息，根据mac地址进行转发，并将这些mac地址与对应的端口记录在自己内部的一个地址表中。\n网络层协议：IP协议\nip（Internet Protocol）分类是能使连接到网上的所有计算机网络实现互相通信的一套规则，只要遵守IP协议就可以与因特网互联通。ip具有唯一性，根据用户性质的不同分为5类。\n\n传输层TCP协议\n（Transmission Control Protocol）传输控制协议，基于连接的协议- 建立连接：三次握手- 第一次握手：客户端发送syn包给服务器，询问是否可以连接\n- 第二次握手：服务器接受请求，发送syn+ack给客户端确认可以连接\n- 由客户端发送ack给服务器，确认连接，建立起连接\n\n\n断开连接：四次挥手\n第一次挥手：客户端发送fin包给服务器，请求关闭连接\n第二次挥手：服务器端对请求关闭连接进行确认\n第三次挥手：服务器主动发送关闭连接的请求给客户\n第四次挥手：客户端发送确认关闭连接给服务器端，服务器客户端连接关闭\n\n\n\n\n\nUDP协议\n（User Data Protocol）用户数据报协议，基于非连接的协议\n\n两者区别\nTCP比UDP复杂，资源占用损耗大一些，信息准备，稳定性好\n文件传输、邮件发送，网页浏览一般使用TCP\n\n\nUDP性能损耗少，资源占用少，稳定性差，只适用于一次只传送少量数据，对可靠性要求不高的应用环境。\n电话、直播使用udp\n\n\n\n会话层建立或解除端对端之间的联系\n表示层对数据进行处理加密\n应用层文件传输、电子右键、文件服务…\n协议\n文件传输：FTP、TFTP、NFS\n电子邮件：SCHP、POP3\nWWW应用：HTTP\n远程登陆：Telnet、rlogin\n网络管理：SNMP\n名字管理DNS\n\n","tags":["network"]},{"title":"sql基础","url":"/2024/04/04/sql%E5%9F%BA%E7%A1%80/","content":"表由行和列组成的二维表格\n\n行，又叫记录\n列，又叫字段\n\nSQL语言（structured query language)SQL语言主要分为:\n\nDQL：数据查询语言，如select\nDDL：数据定义语言，进行数据库、表的管理等，如create、drop\nDML：数据操作语言，增删改查，如insert、uupdate、delete\nTPL：事务处理语言，如begin transaction、commit、rollback\n\n注释\n单行注释：– 注释内容\n多行注释：&#x2F;*     *&#x2F;\n\nMySQL常用数据类型\n整形 int\n小整数tinyint\n小数decimal：如decimal(5,2)表示共存5位数，小数占2位，不能超过2位；整数占3位\n字符串varchar：如varchar(3)表示最多存3个 字符，一个中文或一个字母都占一个字符\n日期实际datetime\n\n表、字段、记录\n表：数据库中存储数据的基本单位字段（列）–field      记录（行）–record\n\n创建表 CREATE TABLEcreate table 表名(\t字段名 数据类型;\t字段名 数据类型\t...)CREATE TABLE a(NAME VARCHAR(10)); -- 指定varchar长度为10CREATE TABLE b(\tNAME VARCHAR(10),\tHEIGHT DECIMAL(5,2)   -- 数字五位，两位小数);CREATE TABLE c(\tid INT,\tNAME VARCHAR(20),\tage TINYINT UNSIGNED);\n\n\nINSERT插入记录#值的顺序与字段顺序对应insert into 表名 values (...);INSERT INTO c VALUES(1,&#x27;张飞&#x27;,30);\n\n\n #部分字段设值，值的顺序与给出的字段顺序对应#INSERT INTO 表名 (字段名,字段名) values (值,值)INSERT INTO c (id,NAME) VALUES (2,&#x27;老房子&#x27;); \n\n\n#插入多条记录，insert语句用分号隔开INSERT INTO c VALUES(6,&#x27;周瑜&#x27;,24);INSERT INTO c (NAME) VALUES (&#x27;诸葛亮&#x27;);INSERT INTO c (id,NAME) VALUES (7,&#x27;黄忠&#x27;);\n\n\n#一条insert语句插入多条记录INSERT INTO c VALUES (10,&#x27;张三&#x27;,10),(12,&#x27;王五&#x27;,20),(11,&#x27;赵六&#x27;,31);\n\n\n#一条insert语句插入指定字段值INSERT INTO c (id,NAME) VALUES (14,&#x27;hua&#x27;),(15,&#x27;yu&#x27;),(16,&#x27;rain&#x27;);\n\n\nSELECT 简单查询SELECT * from 表名;#*表示全部的字段\n\n\n#查询指定字段SELECT id from c;#查询id字段SELECT id FROM c;SELECT id,age FROM c;SELECT id,age,NAME FROM c;\n\n\nUPDATE 修改数据update 表名 set 字段1=值1,字段2=值2 where 条件；UPDATE c SET age=50;\n\n\n#设置条件修改UPDATE c SET NAME=&#x27;di&#x27;,age=20 WHERE id =2;UPDATE c SET NAME=&#x27;zhangfei&#x27; WHERE NAME =&#x27;张飞&#x27;;\n\n\n#让id大于10的age都加一岁UPDATE c SET age=age+1 WHERE id &gt;10 ;\n\n\nDELETE删除表的记录delete from 表名 where 条件;DELETE FROM c WHERE id=6;DELETE FROM c WHERE NAME=&#x27;诸葛亮&#x27;;\n\n\nTEUNCATE删除表的所有数据，保留表结构truncate table 表名;\n\n\nDELETE与TRUNCATE区别\n速度上，turncate&gt;delete\n如果只想删除部分数据用delete，带上where子句\n如果想保留表而将所有数据删除，自增长字段恢复从1开始，用truncate,delete会从删除前的最大值开始增长\n\nDROP TABLE删除表drop table 表名;DROP TABLE a;-- 如果表a存在，就删除表a，如果不存在，就什么都不做DROP TABLE if EXISTS a;\n\n\n\n字段的约束常用的约束\n主键（primary key）：值不能重复，auto_increment代表值自动增长；\n非空（not null）：此字段不参与空值；\n唯一（unique）：此字段的值不允许重复\n默认值（default）：当不填写此值时会使用默认值，如果填写时以填写为准\n\n主键创建带约束字段的表：\ncreate  table 表名(\t字段名 数据类型 约束,\t字段名 数据类型 约束\t...)CREATE TABLE d(\tid INT UNSIGNED PRIMARY KEY auto_increment, \t\tname VARCHAR(10),\tage TINYINT UNSIGNED);INSERT INTO d (name,age) VALUES (&#x27;liu&#x27;,12);INSERT INTO d (name,age) VALUES (&#x27;wan&#x27;,22);\n\n\nINSERT INTO d (id,name,age) VALUES (6,&#x27;www&#x27;,12);INSERT INTO d (name,age) VALUES (&#x27;ll&#x27;,14);SELECT * FROM d;\n\n\n-- 如果不指定字段，主键自增长的字段可以用占位符0或nullINSERT INTO d VALUES (0,&#x27;wl&#x27;,55);INSERT INTO d VALUES (null,&#x27;sssdw&#x27;,123);SELECT * FROM d;\n\n\n非空CREATE TABLE e(\tid INT UNSIGNED,\tname VARCHAR(10) not null,\tage INT UNSIGNED);INSERT INTO e VALUES (1,&#x27;lbw&#x27;,38);\n\n\nINSERT INTO e (id,age) VALUES (2,22);\n\n\n唯一此字段的值不允许重复\nCREATE TABLE f(\tid INT UNSIGNED PRIMARY KEY auto_increment,\tname VARCHAR(10) UNIQUE,\tage INT UNSIGNED);INSERT INTO f VALUES(1,&#x27;ana&#x27;,3);INSERT INTO f VALUES(2,&#x27;lily&#x27;,5);SELECT * FROM f;\n\n\nINSERT INTO f VALUES(3,&#x27;ana&#x27;,5);\n\n\n默认值CREATE TABLE g(\tid INT UNSIGNED PRIMARY KEY auto_increment,\tname VARCHAR(10) UNIQUE,\tage INT UNSIGNED DEFAULT 30);INSERT INTO g VALUES(1,&#x27;zs&#x27;,20);INSERT INTO g (id,name) VALUES(2,&#x27;lily&#x27;);INSERT INTO g VALUES(3,&#x27;ana&#x27;,0);INSERT INTO g VALUES(NULL,&#x27;www&#x27;,NULL);INSERT INTO g VALUES(NULL,&#x27;w5&#x27;,22);\n\n\nINSERT INTO g VALUES(NULL,&#x27;w5&#x27;,22);INSERT INTO g VALUES(NULL,&#x27;w6&#x27;,32);SELECT * FROM g;-- 因为约束数据没有录入，但是自增长的值会继续增长\n\n\n条件查询数据准备drop table if exists students;/* 创建学生表students */ create table students (\tstudentNo varchar(10) primary key, /*学号，主键，值不能重复*/ \tname varchar(10), /*姓名*/\tsex varchar(1), /*性别*/\thometown varchar(20), /*家乡*/\tage tinyint, /*年龄*/\tclass varchar(10), /*班级*/ card varchar(20) /*身份证号码*/);/* 向学生表students插入数据 */insert into students values(&#x27;001&#x27;, &#x27;王昭君&#x27;, &#x27;女&#x27;, &#x27;北京&#x27;, &#x27;30&#x27;, &#x27;1班&#x27;, &#x27;110101199003157654&#x27;),(&#x27;002&#x27;, &#x27;诸葛亮&#x27;, &#x27;男&#x27;, &#x27;上海&#x27;, &#x27;29&#x27;, &#x27;2班&#x27;, &#x27;310102199104262354&#x27;), (&#x27;003&#x27;, &#x27;张飞&#x27;, &#x27;男&#x27;, &#x27;南京&#x27;, &#x27;30&#x27;, &#x27;3班&#x27;, &#x27;320102199003047654&#x27;), (&#x27;004&#x27;, &#x27;白起&#x27;, &#x27;男&#x27;, &#x27;安徽&#x27;, &#x27;35&#x27;, &#x27;4班&#x27;, &#x27;340202198505177654&#x27;), (&#x27;005&#x27;, &#x27;大乔&#x27;, &#x27;女&#x27;, &#x27;天津&#x27;, &#x27;28&#x27;, &#x27;3班&#x27;, &#x27;120101199204067654&#x27;), (&#x27;006&#x27;, &#x27;孙尚香&#x27;, &#x27;女&#x27;, &#x27;河北&#x27;, &#x27;25&#x27;, &#x27;1班&#x27;, &#x27;130502199506137654&#x27;), (&#x27;007&#x27;, &#x27;百里玄策&#x27;, &#x27;男&#x27;, &#x27;山西&#x27;, &#x27;39&#x27;, &#x27;2班&#x27;, &#x27;140102198107277654&#x27;), (&#x27;008&#x27;, &#x27;小乔&#x27;, &#x27;女&#x27;, &#x27;河南&#x27;, &#x27;25&#x27;, &#x27;3班&#x27;, null),(&#x27;009&#x27;, &#x27;百里守约&#x27;, &#x27;男&#x27;, &#x27;湖南&#x27;, &#x27;31&#x27;, &#x27;1班&#x27;, &#x27;&#x27;),(&#x27;010&#x27;, &#x27;妲己&#x27;, &#x27;女&#x27;, &#x27;广东&#x27;, &#x27;24&#x27;, &#x27;2班&#x27;, &#x27;440701199607147654&#x27;), (&#x27;011&#x27;, &#x27;李白&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;, &#x27;30&#x27;, &#x27;4班&#x27;, &#x27;110202199005017754&#x27;), (&#x27;012&#x27;, &#x27;孙膑&#x27;, &#x27;男&#x27;, &#x27;新疆&#x27;, &#x27;36&#x27;, &#x27;3班&#x27;, &#x27;650102198401297655&#x27;)\n\n查询SELECT * FROM students;\n\n\nSELECT `NAME` FROM students;SELECT name FROM students;SELECT NAME FROM students;-- mysql中大小写不敏感\n\n\n别名字段的别名：\nSELECT card as 身份证,name as 姓名,sex as 性别 FROM students;-- as可以省略SELECT card  身份证,name 姓名,sex 性别 FROM students;\n\n表的别名：\nSELECT * FROM students as stu;SELECT * FROM students  stu;\n\n\n去除重复distinct-- distinct可以过滤除select查询结果中重复的记录SELECT DISTINCT sex from students;\n\n\nSELECT sex,class from students;\n\n\nSELECT DISTINCT sex,class from students;\n\n\nwhere子句SELECT * from students WHERE studentNO=&#x27;001&#x27;;\n\n\nSELECT name,class from students WHERE age=30;\n\n\n\nselect控制查询返回什么样的列（字段)\nwhere控制查询返回什么样的行（记录）\n\n比较运算符\n等于：&#x3D;\n大于：&gt;\n大于等于：&gt;&#x3D;\n小于：&lt;\n小于等于：&lt;&#x3D;\n不等于：!&#x3D;或&lt;&gt;\n\n逻辑运算符\n与and\n\n或or\n\n非not\n\n模糊查询\n\nlike，表示模糊查询\n\n%表示任意多个字符\n\n下划线表示任意一个字符\n\n\n-- 查询姓名以孙开头的学生信息SELECT * FROM students WHERE name like &#x27;孙%&#x27;;\n\n\n-- 查询姓名以孙开头,且名字只有一个字的学生信息SELECT * FROM students WHERE name like &#x27;孙_&#x27;;\n\n\n-- 查询名中带乔的学生信息SELECT * FROM students WHERE name like &#x27;%乔&#x27;;\n\n\n-- 查询姓名中有白的学生信息SELECT * FROM students WHERE name like &#x27;%白%&#x27;;\n\n\n-- 查询姓名为两个字的学生记录SELECT * FROM students WHERE name like &#x27;__&#x27;;-- 查询姓白且年龄大于30的学生记录SELECT * FROM students WHERE name like &#x27;白%&#x27; AND age &gt; 30;-- 查询学号以1结尾的学生记录SELECT * FROM students WHERE studentNO like &#x27;%1&#x27;;\n\n\n范围查找\nin：表示在一个非连续的范围内\n\nSELECT * FROM students WHERE hometown IN (&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;广东&#x27;);\n\n\n\nbetween…and…：表示在一个连续的范围内\n\nSELECT * FROM students WHERE age BETWEEN 25 AND 30;\n\n\n-- 查询age年龄在20或25或30的女生记录SELECT * FROM students WHERE age in (20,25,30) AND sex=&#x27;女&#x27;;-- 查询age年龄25到30以外的学生记录SELECT * FROM students WHERE age NOT BETWEEN 25 AND 30;\n\n\n空判断在 SQL 中，NULL 代表未知值或缺失值，它与任何其他值（包括它自己）的比较结果都是未知的。因此，在 SQL 中，你不能使用 = 运算符来判断一个值是否为 NULL，因为任何值与 NULL 进行比较的结果都是未知的，包括自己与自己进行比较。\n\n判断空：is null\n\nSELECT * FROM students WHERE card is NULL;\n\n\n\n判断非空：is not null\n\nSELECT * FROM students WHERE card is NOT NULL;\n\n\nwhere在update和deleteUPDATE students SET class = &#x27;2班&#x27; WHERE age = 25 AND name=&#x27;孙尚香&#x27;;\n\n\nDELETE FROM students WHERE class = &#x27;1班&#x27; and age &gt;30;\n\n\nUPDATE students SET class = &#x27;1班&#x27; WHERE name like &#x27;孙%&#x27;;\n\n\nDELETE FROM students WHERE (age BETWEEN 20 and 30) and sex = &#x27;男&#x27;;\n\n\n排序 order byselect * from 表名order by 字段1 asc |desc,字段2 asc|desc,...\n\nSELECT * from students ORDER BY age; -- 默认为升序asc\n\n\nSELECT * from students ORDER BY age DESC;\n\n\n-- 按年龄从大到小排序，年龄相同时按学号从小到大排序-- 优先级前面的字段在前面SELECT * from students ORDER BY age DESC,studentNO;\n\n\n-- where出现在oder by前面SELECT * from students WHERE sex = &#x27;男&#x27; ORDER BY class,studentNO desc;\n\n\n聚合函数count总记录数count(*) 表示总记录数，括号中写 * 与字段名、结果是相同的。字段记录有null时不同\nSELECT COUNT(*) FROM studentsSELECT COUNT(name) FROM students\n\n\n-- 统计班级数SELECT COUNT(DISTINCT class) FROM students\n\n\n-- 统计女同学的数量SELECT COUNT(*) FROM students WHERE sex=&#x27;女&#x27;;\n\n\nmax最大值max(字段)表示求此字段的最大值\nSELECT MAX(age) FROM students;\n\n\nSELECT MAX(age) FROM students WHERE sex=&#x27;女&#x27;;\n\n聚合函数不能用在where子句中\nselect name from students where age = max(age); -- 错误\n\nmin最小值min(字段)表示求此字段的最小值\nSELECT MIN(age) FROM students WHERE sex=&#x27;女&#x27;;select name from students where age = min(age); -- 错误\n\n\nsum求和SELECT sum(age) FROM students WHERE sex=&#x27;女&#x27;;\n\n\navg平均年龄avg会忽略null\nSELECT avg(age) FROM students WHERE sex=&#x27;女&#x27;;\n\n\nmod()取余MOD(dividend, divisor)-- dividend 是被除数，即要计算余数的数字。-- divisor 是除数，即要除以的数字。\n\n\n\n数据分组select 聚合函数 from 表名 where 条件 group by 字段;select 聚合函数 from 表名 group by 字段;SELECT COUNT(*) FROM students GROUP BY sex;\n\n\nSELECT sex,COUNT(*) FROM students GROUP BY sex;\n\n\nSELECT sex,COUNT(*) FROM students WHERE class=&#x27;1班&#x27; GROUP BY sex;\n\n\nSELECT class,COUNT(*) 总数,avg(age),MAX(age) ,min(age) FROM students GROUP BY class\n\n\nSELECT class,COUNT(*) 总数,avg(age),MAX(age) ,min(age) FROM students WHERE NOT class=&#x27;3班&#x27; GROUP BY class ORDER BY class DESC;\n\n\n分组后进行筛选select 字段1, 字段2, 聚合.. from 表名group by 字段1，字段2，字段3...having 字段1，...聚合...-- 没有group by不能用having--  where先筛选复合条件的记录，再聚合统计SELECT COUNT(*) FROM students WHERE sex=&#x27;男&#x27;;-- having先分组统计，在统计的结果中筛选SELECT COUNT(*) from students GROUP BY sex HAVING sex=&#x27;男&#x27;;\n\n\n-- 求班级人数大于2的班级SELECT class FROM students GROUP BY class HAVING COUNT(*)&gt;2;\n\n\n-- 查询班级总人数大于2人的班级名称及班级对应的总人数SELECT class,COUNT(*) FROM students GROUP BY class HAVING COUNT(*)&gt;2;\n\n\n-- 查询平均年龄大于30岁的班级名称和班级总人数SELECT class,COUNT(*) FROM students GROUP BY class HAVING AVG(age)&gt;30;\n\n\n对比where和having\nwhere是对from后面指定的表进行筛选，是对原始数据进行筛选；\nhaving是对group by的结果进行筛选；\nhaving后面的条件可以用聚合函数，where后面的条件不可以使用聚合函数\nWHERE 用于筛选行，它指定了对哪些行进行聚合操作。WHERE 子句筛选出满足条件的行，并将其传递给 GROUP BY 子句进行分组。\nGROUP BY 用于对行进行分组，并对每个组应用聚合函数（如 COUNT、SUM、AVG 等）。GROUP BY 子句指定了按照哪些列对行进行分组，聚合函数将在每个组上计算。\n\n数据分页显示limit 开始行,获取行数;\nselect * from 表名 start,count -- start默认第一行SELECT * FROM students LIMIT 0,3;\n\n\n-- 查询从第四条记录开始的三条记录SELECT * FROM students LIMIT 3,3;\n\n\n-- limit总是出现在select语句的最后select * from 表名 where 条件 group by 字段 oder by 字段 limit start,count;-- 获取年龄最大的同学的相关信息SELECT * FROM students ORDER BY age DESC LIMIT 1;\n\n\n-- 查询年龄最小的女同学信息SELECT * FROM students WHERE sex =&#x27;女&#x27; ORDER BY age  LIMIT 1;\n\n\n分页已知每页显示m条数据，求：查询第n页的数据\nselect * from students limit(n-1)*m ,m-- 每页显示4条记录，查询第3页的数据select * from students limit 8,4;-- 查询students表，每页显示5条记录，求总页数1. 查询记录总条数 a；2. 使用a除以每页的条数5，得到b；3. 如果b为整数，b为总数\n\n多表查询通过连接运算实现\n\n内连接\n左连接\n右连接\n\n数据准备/* 创建学生表students */create table students (  studentNo varchar(10) primary key, /*学号，主键，值不能重复*/  name varchar(10), /*姓名*/  sex varchar(1), /*性别*/  hometown varchar(20), /*家乡*/  age tinyint, /*年龄*/  class varchar(10), /*班级*/  card varchar(20) /*身份证号码*/);/* 向学生表students插入数据 */insert into students values(&#x27;001&#x27;, &#x27;王昭君&#x27;, &#x27;女&#x27;, &#x27;北京&#x27;, &#x27;30&#x27;, &#x27;1班&#x27;, &#x27;110101199003157654&#x27;),(&#x27;002&#x27;, &#x27;诸葛亮&#x27;, &#x27;男&#x27;, &#x27;上海&#x27;, &#x27;29&#x27;, &#x27;2班&#x27;, &#x27;310102199104262354&#x27;),(&#x27;003&#x27;, &#x27;张飞&#x27;, &#x27;男&#x27;, &#x27;南京&#x27;, &#x27;30&#x27;, &#x27;3班&#x27;, &#x27;320102199003047654&#x27;),(&#x27;004&#x27;, &#x27;白起&#x27;, &#x27;男&#x27;, &#x27;安徽&#x27;, &#x27;35&#x27;, &#x27;4班&#x27;, &#x27;340202198505177654&#x27;),(&#x27;005&#x27;, &#x27;大乔&#x27;, &#x27;女&#x27;, &#x27;天津&#x27;, &#x27;28&#x27;, &#x27;3班&#x27;, &#x27;120101199204067654&#x27;),(&#x27;006&#x27;, &#x27;孙尚香&#x27;, &#x27;女&#x27;, &#x27;河北&#x27;, &#x27;25&#x27;, &#x27;1班&#x27;, &#x27;130502199506137654&#x27;),(&#x27;007&#x27;, &#x27;百里玄策&#x27;, &#x27;男&#x27;, &#x27;山西&#x27;, &#x27;39&#x27;, &#x27;2班&#x27;, &#x27;140102198107277654&#x27;),(&#x27;008&#x27;, &#x27;小乔&#x27;, &#x27;女&#x27;, &#x27;河南&#x27;, &#x27;25&#x27;, &#x27;3班&#x27;, null),(&#x27;009&#x27;, &#x27;百里守约&#x27;, &#x27;男&#x27;, &#x27;湖南&#x27;, &#x27;31&#x27;, &#x27;1班&#x27;, &#x27;&#x27;),(&#x27;010&#x27;, &#x27;妲己&#x27;, &#x27;女&#x27;, &#x27;广东&#x27;, &#x27;24&#x27;, &#x27;2班&#x27;, &#x27;440701199607147654&#x27;),(&#x27;011&#x27;, &#x27;李白&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;, &#x27;30&#x27;, &#x27;4班&#x27;, &#x27;110202199005017754&#x27;),(&#x27;012&#x27;, &#x27;孙膑&#x27;, &#x27;男&#x27;, &#x27;新疆&#x27;, &#x27;36&#x27;, &#x27;3班&#x27;, &#x27;650102198401297655&#x27;);/* 如果课程表courses存在，删除课程表courses */drop table if exists courses;/* 创建课程表courses */create table courses (courseNo int unsigned primary key auto_increment, /*课程号 主键，值不能重复，且自增长*/coursename varchar(10) /*课程名称*/);/* 向课程表courses插入数据 */insert into courses (coursename) values(&#x27;数据库&#x27;),(&#x27;html&#x27;),(&#x27;linux&#x27;),(&#x27;系统测试&#x27;),(&#x27;单元测试&#x27;),(&#x27;测试过程&#x27;),(&#x27;python&#x27;);/* 如果成绩表scores存在，删除课程表scores */drop table if exists scores;/* 创建scores表 */create table scores (id int unsigned primary key auto_increment,/*主键，值不能重复，且自增长*/courseNo int unsigned, /*课程号，与courses表中courseNo关联*/studentNo varchar(10), /*学号，与students表中studentNo关联*/score tinyint /*成绩*/);/* 向scores表插入数据 */insert into scores (courseNo, studentNo,score) values(1, &#x27;001&#x27;, 90),(1, &#x27;002&#x27;, 75),(2, &#x27;002&#x27;, 98),(3, &#x27;001&#x27;, 86),(3, &#x27;003&#x27;, 80),(4, &#x27;004&#x27;, 79),(5, &#x27;005&#x27;, 96),(6, &#x27;006&#x27;, 80);/* 如果区域表areas存在，删除areas */drop table if exists areas;/* 创建区域表areas */create table areas(id int primary key,name varchar(20),pid int);/* 向区域表areas插入数据 */insert into areasvalues (&#x27;130000&#x27;, &#x27;河北省&#x27;, NULL),(&#x27;130100&#x27;, &#x27;石家庄市&#x27;, &#x27;130000&#x27;),(&#x27;130400&#x27;, &#x27;邯郸市&#x27;, &#x27;130000&#x27;),(&#x27;130600&#x27;, &#x27;保定市&#x27;, &#x27;130000&#x27;),(&#x27;130700&#x27;, &#x27;张家口市&#x27;, &#x27;130000&#x27;),(&#x27;130800&#x27;, &#x27;承德市&#x27;, &#x27;130000&#x27;),(&#x27;440000&#x27;, &#x27;广东省&#x27;, NULL),(&#x27;440300&#x27;, &#x27;深圳市&#x27;, &#x27;440000&#x27;),(&#x27;440100&#x27;, &#x27;广州市&#x27;, &#x27;440000&#x27;),(&#x27;440500&#x27;, &#x27;汕头市&#x27;, &#x27;440000&#x27;),(&#x27;440600&#x27;, &#x27;佛山市&#x27;, &#x27;440000&#x27;),(&#x27;440200&#x27;, &#x27;韶关市&#x27;, &#x27;440000&#x27;);\n\n内连接查询的结果只显示两个表中满足连接条件的部分，即A∩B\nselect * from 表1inner join 表2 on 表1.字段=表2.字段DROP TABLE if EXISTS a;CREATE TABLE a(id INT, name VARCHAR(10));INSERT INTO a VALUES (&#x27;1&#x27;,&#x27;张三&#x27;),(&#x27;2&#x27;,&#x27;李四&#x27;),(&#x27;3&#x27;,&#x27;王五&#x27;);DROP TABLE if EXISTS b;CREATE TABLE b(id INT, score int);INSERT INTO b VALUES (&#x27;1&#x27;,&#x27;30&#x27;),(&#x27;1&#x27;,&#x27;40&#x27;),(&#x27;2&#x27;,&#x27;50&#x27;),(&#x27;2&#x27;,&#x27;60&#x27;);SELECT * FROM a INNER JOIN b ON a.id=b.id;\n\nid(1)为别名\nSELECT * FROM students INNER JOIN scores ON students.studentNo=scores.studentNo;\n\n\nSELECT name,courseNo,score FROM students,scores WHERE students.studentNo=scores.studentNo;-- 使用表的别名SELECT name,courseNo,score FROM students st,scores sc WHERE st.studentNo=sc.studentNo;-- 别名--SELECT name 姓名,courseNo 课程编号,score 成绩 FROM students st INNER JOIN scores sc ON st.studentNo=sc.studentNo;--SELECT name 姓名,courseNo 课程编号,score 成绩 FROM students st,scores sc WHERE st.studentNo=sc.studentNo;\n\n连接courses表和scores表\n-- SELECT * FROM scores INNER JOIN courses on scores.courseNo=courses.courseNo;--SELECT * FROM scores s INNER JOIN courses c on s.courseNo=c.courseNo;\n\n\nSELECT name,courseNo,score FROM students s1 INNER JOIN scores s2 on s1.studentNo=s2.studentNo WHERE s1.name=&#x27;王昭君&#x27;;\n\n\nSELECT name,score FROM students s1 INNER JOIN scores s2 on s1.studentNo=s2.studentNo WHERE s1.name=&#x27;王昭君&#x27; AND s2.score&lt;90;\n\n\n隐式内连接-- 隐式内连接select * from 表1,表2 where 表1.字段=表2.字段;\n\n多表内连接SELECT * FROM students s1 INNER JOIN scores sc on s1.studentNo=sc.studentNo INNER JOIN courses s2 on sc.courseNo=s2.courseNo;\n\n查询学生的linux成绩：\nSELECT  name,score,coursename FROM students s1 INNER JOIN scores sc on s1.studentNo=sc.studentNo INNER JOIN courses s2 on sc.courseNo=s2.courseNo where s2.coursename=&#x27;linux&#x27;;\n\n查询成绩最高的男生的信息\nSELECT  name,score,coursename FROM students s1 INNER JOIN scores sc on s1.studentNo=sc.studentNo INNER JOIN courses s2 on sc.courseNo=s2.courseNo where s1.sex=&#x27;男&#x27; ORDER BY sc.score DESC LIMIT 1;\n\n\n左连接用于从左表中选择所有的行，并且对于右表中没有匹配的行，返回 NULL 值。\n在 LEFT JOIN 中，左表是指位于 JOIN 关键字左侧的表，右表是指位于 JOIN 关键字右侧的表。LEFT JOIN 会返回左表的所有行，以及与左表中的行匹配的右表的行。如果右表中没有与左表中的行匹配的行，则会在结果中将右表的列设置为 NULL。\n左连接适用于以下情况：\n\n你想要保留左表的所有行，并将与左表中的行匹配的右表的行加入结果集。\n左表是主表，右表是从表，你想要基于主表的内容来扩展结果集。\n\nselect * from 表1left join 表2 on 表1.字段=表2.字段--SELECT * FROM students LEFT JOIN scores ON students.studentNo=scores.studentNo;\n\n\n右连接与左连接类似，不同之处在于它会返回右表的所有行，以及与右表中的行匹配的左表的行。如果左表中没有与右表中的行匹配的行，则会在结果中将左表的列设置为 NULL。\n右连接适用于以下情况：\n\n你想要保留右表的所有行，并将与右表中的行匹配的左表的行加入结果集。\n右表是主表，左表是从表，你想要基于主表的内容来扩展结果集。\n\nselect * from 表1right join 表2 on 表1.字段=表2.字段--SELECT * FROM scores right JOIN courses ON scores.courseNo=courses.courseNo;\n\n\n自关联\n表中的相同字段所表示的含义不同\n自关联是同一张表做连接查询\n自关联下，一定要找到同一张表可关联的不同字段\n\n\n-- 查询有多少个省SELECT COUNT(*) FROM areas WHERE pid IS NULL;\n\n\n-- 查询多少个市SELECT COUNT(*) FROM areas WHERE pid IS NOT NULL;\n\n\n-- 查询广东省所有的城市SELECT * FROM areas a1 INNER JOIN areas a2 ON a1.id=a2.pid WHERE a2.pid=&#x27;440000&#x27;;SELECT * FROM areas a1 INNER JOIN areas a2 ON a1.id=a2.pid WHERE a1.name=&#x27;广东省&#x27;;\n\n\n子查询\n一条select语句中，嵌入了另一个select语句，那么嵌入的select语句称之为子查询。\n\n外层的第一条select语句为主查询\n\n\n子查询和主查询的关系\n子查询嵌入到主查询中\n\n子查询是辅助主查询的，要么充当条件，要么充当数据源；\n\n子查询是可以独立存在的语句，是一条完整的select语句\n-- 查询大于平均年龄的学生记录SELECT * FROM students WHERE age&gt;(SELECT AVG(age) FROM students);\n\n\n\n标量子查询：子查询返回的结果只有一个值（一行一列），在主查询的条件中一般用比较运算符\n\n-- 查询30岁学生的成绩SELECT score FROM scores WHERE studentNo IN(SELECT studentNo FROM students WHERE age =30)\n\n\n\n列子查询：子查询返回的结果是一列（一列多行），条件中一般用in\n\n\n\n-- 查询所有女生的信息和成绩-- 内连接：select * from students inner join scores on students.studentNo=scores.studentNo where sex=&#x27;女&#x27;;--   where为子查询的条件SELECT * FROM (SELECT * FROM students WHERE sex =&#x27;女&#x27;) femalestu INNER JOIN scores sc ON femalestu.studentNo=sc.studentNo\n\n\n\n表级子查询：子查询的结果返回一张表（多行多列），一般和其他表联合查询\n\n数据准备drop table if exists departments; /* 创建部门表 */ create table departments ( \tdeptid int(10) primary key, /* 部门编号， 与 employees 表 deptid 关联 */ \tdeptname varchar(20) not null /* 部门名称 */ ); /* 向部门表插入数据 */ insert into departments values (&#x27;1001&#x27;, &#x27; 市场部 &#x27; ); insert into departments values (&#x27;1002&#x27;, &#x27; 测试部 &#x27; ); insert into departments values (&#x27;1003&#x27;, &#x27; 开发部 &#x27; ) ; drop table if exists employees; /* 创建员工表 */ create table employees ( \tempid int primary key, /* 职工编号 */ \tempname varchar(20) not null, /* 姓名 */ -- 姓名 \tsex varchar(4) default null, /* 性别 */ -- 性别 \tdeptid int default null, /* 部门编号， 与 departments 表 deptid 关联 */ \tjobs varchar(20) default null, /* 岗位名称 */ \tpoliticalstatus varchar(20) default null, /* 政治面貌 */ \tleader int default null /* 上级领导的职工编号 */ ); /* 向员工表插入数据 */ insert into employees values (&#x27;1&#x27;, &#x27; 王昭君 &#x27; , &#x27; 女 &#x27; , &#x27; 1003&#x27;, &#x27; 开发 &#x27; , &#x27; 群众 &#x27; , &#x27;9&#x27;); insert into employees values (&#x27;2&#x27;, &#x27; 诸葛亮 &#x27; , &#x27; 男 &#x27; , &#x27; 1003&#x27;, &#x27; 开发 &#x27; , &#x27; 群众 &#x27; , &#x27;9&#x27;); insert into employees values (&#x27;3&#x27;, &#x27; 张飞 &#x27; , &#x27; 男 &#x27; , &#x27; 1002&#x27;, &#x27; 测试 &#x27; , &#x27; 团员 &#x27; , &#x27;4&#x27;); insert into employees values (&#x27;4&#x27;, &#x27; 白起 &#x27; , &#x27; 男 &#x27; , &#x27; 1002&#x27;, &#x27; 测试经理 &#x27; , &#x27; 党员 &#x27; , null); insert into employees values (&#x27;5&#x27;, &#x27; 大乔 &#x27; , &#x27; 女 &#x27; , &#x27; 1002&#x27;, &#x27; 测试 &#x27; , &#x27; 党员 &#x27; , &#x27;4&#x27;); insert into employees values (&#x27;6&#x27;, &#x27; 孙尚香 &#x27; , &#x27; 女 &#x27; , &#x27; 1001&#x27;, &#x27; 市场 &#x27; , &#x27; 党员 &#x27; , &#x27; 12&#x27;); insert into employees values (&#x27;7&#x27;, &#x27; 百里玄策 &#x27; , &#x27; 男 &#x27; , &#x27; 1001&#x27;, &#x27; 市场 &#x27; , &#x27; 团员 &#x27; , &#x27; 12&#x27;); insert into employees values (&#x27;8&#x27;, &#x27; 小乔 &#x27; , &#x27; 女 &#x27; , &#x27; 1002&#x27;, &#x27; 测试 &#x27; , &#x27; 群众 &#x27; , &#x27;4&#x27;); insert into employees values (&#x27;9&#x27;, &#x27; 百里守约 &#x27; , &#x27; 男 &#x27; , &#x27; 1003&#x27;, &#x27; 开发经理 &#x27; , &#x27; 党员 &#x27; , null); insert into employees values (&#x27;10&#x27;, &#x27; 妲己 &#x27; , &#x27; 女 &#x27; , &#x27; 1003&#x27;, &#x27; 开发 &#x27; , &#x27; 团员 &#x27; , &#x27;9&#x27;); insert into employees values (&#x27;11&#x27;, &#x27; 李白 &#x27; , &#x27; 男 &#x27; , &#x27; 1002&#x27;, &#x27; 测试 &#x27; , &#x27; 团员 &#x27; , &#x27;4&#x27;); insert into employees values (&#x27;12&#x27;, &#x27; 孙膑 &#x27; , &#x27; 男 &#x27; , &#x27; 1001&#x27;, &#x27; 市场经理 &#x27; , &#x27; 党员 &#x27; , null); insert into employees values (&#x27;13&#x27;, &#x27; 周瑜 &#x27; , &#x27; 男 &#x27; , &#x27; 1001&#x27;, &#x27; 市场 &#x27; , &#x27; 群众 &#x27; , &#x27; 12&#x27;); drop table if exists salary; /* 创建工资表 */ create table salary ( \tsid int primary key, \tempid int not null, /* 职工编号 , 与 employees 表 empid 关联 */ \tsalary int not null /* 工资 */ ); /* 向工资表插入数据 */ insert into salary values (&#x27;1&#x27;, &#x27;7&#x27;, &#x27;2100&#x27;); insert into salary values (&#x27;2&#x27;, &#x27;6&#x27;, &#x27;2000&#x27;); insert into salary values (&#x27;3&#x27;, &#x27;12&#x27;, &#x27;5000&#x27;); insert into salary values (&#x27;4&#x27;, &#x27;9&#x27;, &#x27;1999&#x27;); insert into salary values (&#x27;5&#x27;, &#x27;10&#x27;, &#x27;1900&#x27;); insert into salary values (&#x27;6&#x27;, &#x27;1&#x27;, &#x27;3000&#x27;); \n\n\n查询练习\n\n-- 列出男职工的总数和女职工的总数SELECT sex,count(*) FROM employees GROUP BY sex;\n\n\n-- 列出非党员职工的总数SELECT count(*) FROM employees WHERE NOT politicalstatus = &#x27; 党员 &#x27;\n\n\n-- 列出所有职工工号、姓名以及所在部门名称SELECT empid,empname,deptname FROM employees emp INNER JOIN departments dp ON emp.deptid=dp.deptid-- 想要部门相同的一起列出在后面加oder by deptname\n\n\n-- 列出所有职工工号、姓名和对应工资SELECT emp.empid,empname,salary FROM employees emp INNER JOIN salary s ON emp.empid=s.empid ORDER BY emp.empid;-- left join，没有工资的员工也显示SELECT emp.empid,empname,salary FROM employees emp LEFT JOIN salary s ON emp.empid=s.empid ORDER BY emp.empid;\n\n\n\n-- 列出领导岗的姓名以及所在部门名称SELECT empname,deptname FROM (SELECT * FROM employees WHERE leader is NULL) l INNER JOIN departments d ON l.deptid=d.deptid-- 方法2select empname,deptname from employees e inner join departments d on e.depid =d.depid where leader is null;\n\n\n-- 列出职工总人数大于4的部门号和总人数SELECT deptid,COUNT(*) FROM employees GROUP BY deptid HAVING count(*)&gt;4 \n\n\n-- 列出职工总人数大于4的部门号和部门名称SELECT e.deptid,deptname FROM departments d INNER JOIN employees e ON d.deptid=e.deptid GROUP BY e.deptid HAVING COUNT(*)&gt;4;\n\n\n-- 列出开发部和测试部的职工号，姓名SELECT e.empid,e.empname FROM employees e INNER JOIN departments d ON e.deptid=d.deptid WHERE deptname IN(&#x27; 开发部 &#x27;,&#x27; 测试部 &#x27;)\n\n\n-- 列出市场部所有女职工的姓名和政治面貌SELECT e.empname,e.politicalstatus FROM employees e INNER JOIN departments d ON e.deptid=d.deptid WHERE deptname=&#x27; 市场部 &#x27; AND sex=&#x27; 女 &#x27;\n\n\n-- 显示出所有职工姓名和工资，包括没有工资的职工姓名SELECT e.empname,salary FROM employees e LEFT JOIN salary s ON e.empid=s.empid\n\n\n-- 求不姓孙的所有职工的工资总和SELECT SUM(salary) FROM salary s INNER JOIN employees e ON s.empid=e.empid WHERE empname NOT LIKE &#x27; 孙% &#x27;\n\n\nMySQL常用内置函数字符串函数\n拼接字符串concat(str1,str2...)\n\n-- 把12,34，&#x27;ab&#x27;拼接为一个字符串&#x27;1234ab&#x27;CONCAT(12,34,&#x27;ab&#x27;)\n\n\n\n计算字符串中字节个数length(str) \n\nSELECT LENGTH(&#x27;abc&#x27;);SELECT LENGTH(&#x27;我&#x27;);\n\n\n-- 查询名字为3个字的学生信息SELECT * FROM students WHERE LENGTH(name)=9;\n\n\n\n获取字符串中的字符数char_length()\n截取字符串\nleft(str,len)返回字符串str左端的len个字符,中文和英文字母一样\nright(str,len)返回字符串str右端的len个字符\nsubstring(str,pos,len)返回字符串str的位置pos起len个字符，pos从1开始计数\n\n\n\nSELECT left(&#x27;我和你们&#x27;,3)\n\n\nSELECT right(&#x27;我和你abc&#x27;,4)\n\n\nSELECT substring(&#x27;我和你abc&#x27;,2,2)\n\n\n-- 查询所有学生信息，按年龄从大到小排序SELECT * FROM students ORDER BY SUBSTRING(card,7,8)\n\n\n\n去除空格\nltrim(str)返回删除左侧空格的字符串\nrtrim(str)返回删除右侧空格的字符串\ntrim(str)去除两侧空格\n\n\n\nSELECT LTRIM(&#x27;                 abcd                     &#x27;);SELECT RTRIM(&#x27;                 abcd                     &#x27;);SELECT TRIM(&#x27;                 abcd                     &#x27;);\n\n\n\n数学函数\n求四舍五入值round(n,d),n表示原数，d表示小数位数，默认为0\n\nSELECT ROUND(1.653)\n\n\nSELECT ROUND(1.653,2)\n\n\n-- 求学生的平均年龄并保留2位小数SELECT ROUND(AVG(age),2) FROM students;\n\n\n\n随机数rand()产生从0到1.0的随机浮点数\n\nSELECT RAND();\n\n\n-- 随机排序SELECT * FROM students ORDER BY RAND();\n\n\n\n-- 随机抽取一名学生SELECT name FROM students ORDER BY RAND() LIMIT 1;\n\n\n日期时间函数\n当前日期current_date()\n\nSELECT CURRENT_DATE\n\n\n\n当前时间current_time()\n\nSELECT CURRENT_TIME\n\n\n\n当前时间（具体）now()\n\nSELECT NOW()\n\n\n-- 记录当前时间，比如下单时间CREATE table a (id INT,indate DATETIME);INSERT INTO a VALUE(1,NOW());SELECT * FROM a;\n\n\n存储过程存储过程procedure，即存储程序，是一条或者多条SQL语句的集合。\n-- 语法create procedure 存储过程名称(参数名称)beginsql 语句end\n\n-- 创建存储过程CREATE PROCEDURE stu()BEGIN\tSELECT * FROM students;END\n\n\n-- 调用存储过程stu()，用CALLCALL stu();\n\n\n-- 删除存储过程drop procedure 存储过程;drop procedure if exists 存储过程;-- 删除时不用括号DROP PROCEDURE stu;DROP PROCEDURE IF EXISTS stu;\n\n\n视图视图（View）是一种虚拟的表，它是由一个或多个表的行数据经过某种逻辑组合而形成的，它本身并不存储数据，只是对查询结果的一种抽象表示。通过视图，我们可以将复杂的查询、逻辑和数据组织进行封装，以简化数据访问和管理。视图的本质就是对查询的封装。\n\n虚拟性：视图本身不存储数据，它只是对查询结果的一种逻辑表示。\n透明性：使用视图的应用程序无需关心视图的底层实现，可以像访问普通表一样访问视图。\n安全性：视图可以隐藏底层表的部分列或行，只向用户暴露需要的数据，从而提高数据安全性。\n简化复杂性：通过视图，可以将复杂的查询逻辑封装起来，使用户可以通过简单的查询访问数据。\n重用性：视图可以被多个查询或应用程序共享，提高了代码的重用性。\n\n-- 创建视图create view 视图名称 as select 语句;CREATE VIEW boys as SELECT * FROM students WHERE sex=&#x27;男&#x27;;\n\n\n-- 查看视图SELECT * FROM boys WHERE age&gt;30;\n\n\n注意：视图的表是只读的。需要注意的是，视图中的数据是动态的，当基础表中的数据发生变化时，视图中的数据也会相应地更新。\n-- 视图和表进行内连接操作SELECT * FROM boys INNER JOIN scores ON boys.studentNo=scores.studentNO\n\n\n-- 删除视图drop view 视图名称;drop view if exists 视图名称;DROP VIEW boys;\n\n事务事务是多条更改数据操作的sql语句集合，是一个操作序列，这些操作要么都执行，要么都不执行，是一个不可分割的工作单位\n\n开启事务\n\nbegin：开启事务后执行修改UPDATE或者删除DELETE记录语句，变更会写到缓存中而不会立刻生效\n\n回滚事务\n\nrollback：放弃修改\n\n提交事务\n\ncommit：将修改的事务写入实际的表中\nBEGIN;DELETE FROM students WHERE studentNo=&#x27;001&#x27;;SELECT * FROM students;DELETE FROM scores WHERE studentNo=&#x27;001&#x27;;\n\n\n\n-- 回滚操作ROLLBACK;SELECT * FROM students;SELECT * FROM scores;\n\n\n\n如果开启了一个事务，之后没有rollback也没有commit，系统出现了错误，会默认rollback\n-- 开启事务，删除学生信息和成绩，提交事务使两个表的删除同时生效BEGIN;DELETE FROM students WHERE studentNo=&#x27;001&#x27;;DELETE FROM scores WHERE studentNo=&#x27;001&#x27;;COMMIT;-- 一旦提交事务，两个删除操作同时生效SELECT * FROM students;SELECT * FROM scores;\n\n\n\n索引可以加快select查询的速度，但是会降低更新表的速度，因为在保存文件的同时会同时保存索引文件。可以在更改记录前先删除索引\n创建索引create index 索引名称 on 表名(字段名称(长度))-- 如果指定字段是字符串，需要指定长度，建议长度与定义字段时长度一致-- 字段类型如果不是字符串，可以不填写长度部分\n\n\n-- 为students表的age字段创建索引，名为age_indexCREATE INDEX age_index ON students (age);-- 为students表的name字段创建索引，名为name_indexCREATE INDEX name_index ON students (name(10));-- varchar(10)\n\n\n-- where条件后面的字段，数据库系统会自动查找是否有索引-- 自动调用age_indexSELECT * FROM students WHERE age=30;-- 自动调用name_indexSELECT * FROM students WHERE name=&#x27;李白&#x27;-- 不会调用任何索引，因为没有创建索引，会全表一个个查找SELECT * FROM students WHERE name=&#x27;李白&#x27;\n\n\n\n查看索引show index from 表名SHOW INDEX FROM students\n\n\n系统会为主键自动创建索引\n删除索引drop index 索引名 on 表名;DROP INDEX age_index ON students;\n\n\n使用命令行使用数据库-- 登录mysql -h[主机名] -u 用户名 -p-- -u的意思是用户名-- -h，当登录的mysql不在本机上，后跟主机ip地址\n\n\nmysql -u root -p\n\n\n-- 查看数据库show databases;\n\n\n-- 打开数据库use mydb;\n\n-- 查看数据库中的表show tables;\n\n\n-- 查询内容select * from students;\n\n\n可以使用chcp 65001将命令行编码方式改为utf-8\n-- 查看表的结构desc students;\n\n\n\n-- 创建数据库create database 数据库名 default charset[默认字符集];create database test1 default charset utf8;\n\n\n-- 删除数据库drop database test1;\n\n\n修改用户密码grant all on 数据库名 to 用户名@&#x27;登录主机&#x27; indentified by &#x27;密码&#x27; with grant option;\n\n\ngrant all on:代表为用户赋权；\n数据库名：可以是*，代表所有数据库；\n表名：可以是*，代表所有表，\nto 用户名：指定要创建用户的名称\n@&#39;登录主机&#39; :@localhost代表只能在本机登录，@’%‘代表可以远程\n\n","categories":["database"],"tags":["sql"]},{"title":"小白搭建博客教程","url":"/2021/07/17/%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","content":"安装准备安装博客前，电脑需要安装node.js，git。并且要在GitHub上建立一个仓库\n\n如图所示，yourname是你的名字，要和你的GitHub名字完全一样，比如我是wrinta，我的Repository name那里填的就是wrinta.github.io，下面的Add a README file也要记得勾选，然后就可以创建仓库了\n\n进入刚刚我们新建的仓库，点击Settings，找到Pages，点击Choose a theme随便选择一个主题，过一会他会提示你可以通过域名访问啦\n\n点击那个链接，出现的页面效果就是你刚刚随意选择的主题样式。觉得丑没关系，我们后面可以配置自己喜欢的主题。\n开始安装安装Hexo在自己想要存放自己博客相关文件的目录下新建一个文件夹，如 D:\\study\\blog，进入目录，右键Git Bash Here，打开git的控制台窗口（以后我们的操作都在git控制台中进行）\n在该目录下输入 npm i hexo-cli -g 安装Hexo，会有几个报错，不用管它，安装完后输入 hexo -v 验证Hexo是否成功安装\n输入 hexo init 初始化文件，有一些npm的插件可以在后面需要时按需安装。\n输入 hexo g 生成静态网页，输入 hexo s 打开本地的服务器，浏览器打开http://localhost:4000     就可以看到博客啦。后面配置文件和主题时，可以通过同样的方式先在本地预览哟。预览完成后可以通过ctrl +c关闭本地的服务器。\n连接GitHub和本地打开 git bash ，输入下面的命令：\ngit config --global user.name &quot;username&quot;git config --global user.email &quot;user email&quot;\n\n生成SSH key，中间一直回车就好了，记得出现y&#x2F;n时输入y再回车：\nssh-keygen -t rsa -C &quot;user email&quot;\n\n查看SSH key，复制内容：\ncat ~/.ssh/id_rsa.pub\n\n打开GitHub，在头像下面点settings，再点击SSH and GPG keys，新建一个SSH，取一个自己喜欢的名字，将刚刚复制的内容粘进去，然后保存。\n输入：\nssh -T git@github.com\n\n如果如下图所示，出现了你的用户名，那就成功啦！\n\n还差一步，打开博客根目录下的_config.yml文件，这个是博客的配置文件，修改deploy\ndeploy:  type: &#x27;git&#x27;  repository: git@github.com:wrinta/wrinta.github.io.git  #这里把名字改成你的名字  branch: main #分支改成自己的分支名，比如master\n\n发布文章首先在博客的根目录下面打开git bash，安装扩展 npm i hexo-deployer-git\n打开博客根目录的配置文件_config.yml，将 post_asset_folder改成true，如图所示：\n\n输入 hexo new post “article title”，新建一篇文章，在博客的根目录下，进入&#x2F;source&#x2F;_posts，可以看到刚刚新建的文件，其中.md文件是你写博客内容的地方，文件夹用来放你在同名.md文件里要用的图片。\n编写完后，输入 hexo g 生成静态文件，可以输入 hexo s 本地预览，然后输入 hexo d 。\n如果 hexo d 后报错 ERROR Deployer not found: git 输入：\nnpm install --save hexo-deployer-git\n\n","categories":["hexo"],"tags":["blog build"]},{"title":"接口测试","url":"/2024/04/14/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/","content":"接口接口是系统或组件（组成某个系统的部件之一）之间的交互点，通过这些交互点可以进行数据的交互。\n接口的类型按划分形式，大致分为3类\n\n按协议分，协议不同，接口类型不同。HTTP、TCP、UDP、FTP、USB\n\n按语言分类。Java、Python、C++、PHP\n\n按范围划分。系统之间和程序内部\n\n系统之间，内部系统之间、内部系统和外部系统之间\n\n程序内部，方法（函数）和方法（函数）之间、类和类之间、模块和模块之间\n\n\n\n\n\n接口测试对系统或组件之间的接口进行测试，主要是校验数据的交换、传递和控制管理过程，以及相互依赖关系。\n数据是否正确？逻辑依赖关系是否正确？\n原理模拟客户端向服务器发送请求，服务器接受请求后进行相应的业务处理，并向客户端返回响应数据，检查响应数据是否符合预期。\n\n数据（预期结果）\n从用户需求来\n\n\n怎样校验\n借助工具、代码模拟客户端，组织数据（没有前端也可以完成）\n\n\n\n特点\n测试可以提前介入，提早发现Bug，符合质量控制前移的理念\n可以发现一些页面操作发现不了的问题\n接口测试低成本高收益（底层的一个Bug可以引发上层8个左右Bug，接口测试可以实现自动化）\n从用户的角度对系统全方面进行全面的检测\n\n实现方式\n使用接口测试工具实现：JMeter、Fiddler、Postman\n通过编写代码来实现：Python+Requests+Unittest\n依赖断言去判断\n\nHTTP协议HTTP（Hyper Text Transfer Protocol）：超文本传输协议，是一个基于请求与响应模式的、应用层的协议，也是互联网上最为广泛的一种协议\n特点\n支持客户端&#x2F;服务器模式\n简单快速\n灵活\n无连接\n无状态\n\nURLURL（Uniform Resource Locator）统一资源定位符，是互联网上标准资源的地址。HTTP使用URL来建立连接和传输数据。\nURL格式http://www.itcast.cn:8080/news/index.html?uid=123&amp;page=1\nhttp：协议\nwww.itcast.cn：域名（ip），定位网络环境中的一台主机\n8080：端口号，在网络主机上定位一个应用。没有指定端口号，默认跟随协议。\nnews/index.html：资源路径，对应网页的源代码或网络中的一个数据资源。\nuid=123&amp;page=1：查询参数，可以有多个，用&amp;分割\n\n端口：\nhttp协议默认端口：80\nhttps协议默认端口：443\nmysql默认端口：3306\nredis缓存数据库默认端口：6379\nOracle默认端口：1521\n\n\n资源路径：\n资源路径可以为空（没有），相当于”&#x2F;“\n如果没有查询参数，资源路径从域名（端口）之和\n如果有查询参数，资源路径为?之前，域名（端口）之和的所有内容\n\n\n查询参数：传参给网页源代码\n\nHTTP请求\n由客户端发送给服务器\n规定了数据的语法格式\n\n由四部分组成：请求行、请求头、空行、请求体\n\n\n请求行\n作用：指定请求方法、请求资源\n语法格式：请求方法（空格）URL（空格）协议版本（\\n\\r）\n请求方法：\nGET：查询，没有请求体\nPOST：新增，有请求体，登录注册主要使用\nPUT：修改，有请求体\nDELETE：删除，无请求体\n\n\nURL：数据资源的定位符。协议:&#x2F;&#x2F;域名:端口&#x2F;资源路径?查询参数&amp;…\n协议版本：\nhttp1.1&#x2F;http1.2&#x2F;http2.0\n主要使用http1.1\n\n\n\n请求头\n作用：向服务器描述客户端（浏览器）的基本信息\n\n语法：k: v\n\nUser-Agent：向服务器描述浏览器的类型\nContent-Type：向服务器描述请求体的数据类型\n\n\n\n\n请求体\nGET、DELETE请求方法没有请求体\nPOST、PUT请求方法有请求体\n请求体的数据类型，收请求头中的Content-Type的值影响\n\nHTTP相应\n作用：由服务器回发给客户端\n规定了服务器回发给客户端的数据语法格式\n\n组成：响应行（状态行）、响应头、空行、响应体。整体称为响应包&#x2F;响应报文\n\n\n响应行\n语法格式：响应版本（空格）状态码（空格）状态码描述\\r\\n\n协议版本：http1.0&#x2F;http1.1&#x2F;http2.0\n状态码：针对http请求响应的状态\n第一个数字定义了响应的类别\n1xx：指示信息，表示请求已接受，继续处理，请求需要进一步访问\n100 Continue\n101 Switching Protocols\n\n\n2xx：成功，表示请求已被成功接受、理解、接受\n200 OK\n201 Created\n202 Accepted\n203 Non-Authoritative Information\n204 No Content\n205 Reset Content\n206 Partial Content\n\n\n3xx：重定向，要完成请求必须进行更进一步的操作\n300 Multiple Choices \n301 Moved Permanently\n302 Found\n303 See Other\n304 Not Modified\n305 Use Proxy\n307 Temporary Redirect\n\n\n4xx：客户端错误，请求有语法错误或请求无法实现\n400 Bad Request\n401 Unauthorized\n402 Payment Required\n403 Forbidden（请求的文件&#x2F;资源存在，但是没有访问权限）\n404 Not Found（请求的资源&#x2F;文件不存在）\n405 Method Not Allowed\n406 Not Acceptable\n407 Proxy Authentication Required\n408 Request Timeout\n409 Conflict\n410 Gone\n411 Length Required\n412 Precondition Failed\n413 Request Entity Too Large\n414 Request-URI Too Long\n415 Unsupported Media Type\n416 Requested Range Not Satisfiable\n417 Expectation Failed\n\n\n5xx：服务器端错误，服务器未能实现合法请求 \n500 Internal Server Error\n501 Not Implemented\n502 Bad Gateway\n503 Service Unavailable\n504 Gateway Timeout\n505 HTTP Version Not Supported\n\n\n\n\n\n\n状态描述：对状态码的说明\n\n响应头\n作用：向客户端（浏览器）描述服务器的基本信息\n\n语法：k: v\nContent-Type：向客户端（浏览器）描述响应体的数据类型\n\n\n响应体\nhttp的响应报文大多数有响应体，重定向没有响应体\n响应体的数据类型，受响应头中Content-Type的值的影响\n常见的类型：\njson类型\n表单类型\n图片类型\n\n\n\n传统风格接口对用户进行操作的相关接口，包括增删改查\n\n\n使用GET、POST实现所有数据的增删改查操作\n针对用户的某一个操作，URL不唯一，同一个用户操作对应不同的URL\n状态码统一使用200\n\n优点：\n\n对开发的技术要求低。只需要GET、POST方法\n\n代码实现灵活\n\n\n缺点：相同功能的实现代码不唯一\nRESTful风格接口一种软件架构风格、设计风格，不是标准。提供了一组设计原则和约束条件\nREST（Representational State Transfer）的缩写，表现层状态转化。如果一个架构符合REST原则，称它为RESTful架构\n\n使用GET&#x2F;POST&#x2F;PUT&#x2F;DELETE分别表示增、查、改、删\n使用一个url对应一个唯一的资源\n状态码根据实际操作请求加以区分。（实际操作中都返回200，在响应体中描述成功&#x2F;失败）\n\n\n界定RESTful风格接口\n请求方法：使用get、post、delete、put对应查、增、删、改\n数据资源的定位符（url）是否唯一\n在url中不使用动词，替换使用名词。结合请求方法，界定具体操作\n\nRESTful架构特点\n每一个URL代表一种资源\n客户端和服务器之间传递这种资源的某种表现层\n客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转化：\n接口之间传递的数据最常用的格式为json\n\n接口测试流程\n需求分析，依据需求文档\n接口文档解析，一般由开发人员编写接口文档\n设计测试用例\n执行测试用例：工具&#x2F;代码\n接口缺陷管理与跟踪\n生产测试报告\n接口自动化持续集成（可选），一般是项目发布上线前大批量回归测试使用，或者新版本迭代使用\n\n接口文档又称API文档，一般由开发编写，用来描述系统所提供接口信息的文档。大家都根据这个接口文档进行开发，并需要一直维护和遵守。\n作用：\n\n方便前端和后端在开发的时候进行对接\n在人员更迭时，方便新人快速接手项目\n方便测试人员编写接口测试用例\n\n展现形式\n在线文档（html）\n离线文档\nword\nxmind\npdf\nexcel\n\n\n\n结构\n基本信息：\n接口描述\nURL：（协议+域名）+资源路径\n请求方法\n\n\n请求参数\n请求头\n请求体（GET、DELETE没有）\n\n\n返回结果\n状态码、状态描述\n响应体\n\n\n\n接口文档解析http请求\n\n请求行\n\n请求方法\nURL\n协议版本：默认http&#x2F;1.1\n\n\n\n请求头\n\nContent-Type\n\n\n请求体\n\n\nhttp应答：\n\n响应行\n状态码、状态描述\n\n\n响应头\n响应体\n\n接口设计用例\n为什么写？\n防止漏测\n管理当前工作进度，评估工作量\n\n\n\n接口测试点功能测试\n单接口功能：手工测试中的单个业务模块，一般对应一个接口。借助工具、代码绕开前端界面，组织接口所需要的数据展开接口测试\n登录业务–&gt;登录接口\n加入购物车业务–&gt;加入购物车接口\n登录业务–&gt;登录接口\n订单业务–&gt;订单接口\n支付业务–&gt;支付接口\n\n\n业务场景功能：安装用户实际使用场景，梳理接口业务场景。组织业务场景时一般只做正向测试即可（与手工一致）。一般建议用最少的用例覆盖最多的业务场景。\n登录——搜索商品——加购物车——下单——支付\n\n\n\n性能测试\n响应时长\n吞吐量：TPS，单位时间内当前接口能处理的事务数\n并发数\n服务器资源使用率\n\n安全测试\n攻击安全：由专业安全测试工程师完成\n业务安全\n敏感数据是否加密\nSQL注入\n\n\n\n设计方法与思路与手工设计相同之处接口用例设计的测试点与手工页面业务功能的测试点几乎完全一样\n\n手工功能测试用例设计要点\n\n测试页面布局、控件的位置是否精准\n\n针对用户名的编辑框中的数据值展开测试\n​\t正确手机号、手机号由特殊字符、手机不足11位…\n针对密码的编辑框中的数据值展开测试\n​\t正确密码、错误密码…\n针对验证码的编辑框的数据值展开测试\n​\t正确验证码、错误验证码…\n\n\n\n接口用例设计要点\n\n手工页面中的用户名编辑框，对应接口中key为username的value值。针对username的值展开测试\n手工页面中的密码编辑框，对应接口中key为password的value值。针对password的值展开测试\n手工页面中的用户名编辑框，对应接口中key为verify_code的value值。针对verify_code的值展开测试\n\n\n\n\n与手工设计不同之处\n手工测试写入到输入框数据是否正确，接口测试测参数对应的参数值是否正确\n不单单只能对参数值进行测试，还针对参数进行测试\n正向参数\n必选参数：所有的必须（必填）都包含\n组合参数：所有的必选+任意一个&#x2F;多个可选参数\n全部参数：所有的必选+所有的可选参数\n\n\n反向参数\n多惨：多出一个&#x2F;多个必选参数（可以任意指定）\n少参：缺少一个&#x2F;多个必选参数\n无参：没有必选参数\n错误参数：参数名输入错误\n\n\n\n\n\n单接口测试用例手工测试中每个业务功能，在接口测试中就对应唯一的一个接口。针对 该接口展开测试\n接口测试用例文档要素：\n编号、标题、用例名称、模块、优先级、预置条件、请求方法、URL、请求头、请求体（请求数据）\n登录测试点：\n\n数值正向\n登录成功\n\n\n数据反向\n手机号为空\n手机号有特殊字符\n手机号不足11位\n手机号超出11位\n手机号未注册\n密码错误\n密码为空\n密码有特殊字符\n密码1位\n密码100位\n\n\n参数正向\n必选参数（全部参数）\n\n\n参数反向\n多参\n少参\n无参\n错误参数\n\n\n\n业务场景功能对应手工测试的业务流程，即接口调用的先后顺序，按照调用顺序展开接口测试。\n\n业务场景尽量遵循用户实际使用的场景，按顺序调用接口进行测试\n\n尽量设计最少的测试用例去覆盖最多的业务场景\n\n登录成功——添加员工——查询员工——修改员工——再查询——删除员工——查询员工列表\n\n\n一般情况下，只需要测试正向的业务场景即可。\n\n依赖关系：\n\n登录成功返回的token，被添加、查询、修改、删除所依赖\n添加员工成功，返回员工id，被查询、修改、删除依赖\n\n\n\nPostman用法管理用例集Postman断言Postman的断言使用js编写，写在Tests标签页里。Tests中的脚本在发送请求后执行，会把断言的结果最终显示在TestResults中\n\n断言响应状态码Status code: Code is 200\npm.test(&quot;Status code is 200&quot;, function () &#123;    pm.response.to.have.status(200);&#125;);// pm:Postman的一个实例// test()：Postman实例的一个方法，有两个参数。\t参数1：&quot;Status code is 200&quot; 断言完成后给出的提示信息    参数2：function()&#123;&#125;匿名函数的调用    pm.response.to.have.status(200);Postman的响应结果中，有状态码200\n\n断言响应体是否包含某个字符Response body: Contains string\npm.test(&quot;Body matches string&quot;, function () &#123;    pm.expect(pm.response.text()).to.include(&quot;string_you_want_to_search&quot;);&#125;);// pm:Postman的一个实例// test()：Postman实例的一个方法，有两个参数。\t参数1：&quot;Body matches string&quot; 断言完成后给出的提示信息    参数2：function()&#123;&#125;匿名函数的调用    pm.expect(pm.response.text()).to.include(&quot;string_you_want_to_search&quot;);Postman实例预期结果包含&quot;string_you_want_to_search&quot;字符串\n\n断言响应体是否等于某个字符串（对象）Response body: is equal to a string\npm.test(&quot;Body is correct&quot;, function () &#123;    pm.response.to.have.body(&quot;response_body_string&quot;);&#125;);\n\n断言json数据Response body: JSON value check\npm.test(&quot;Your test name&quot;, function () &#123;    var jsonData = pm.response.json();    pm.expect(jsonData.value).to.eql(100);&#125;);// var jsonData = pm.response.json();定义变量jsonData，值为json格式的响应体数据// pm.expect(jsonData.value).to.eql(100);\tvalue指的是json中的值的key，eql()为对应的值    value的值对应：success、code、message、data    to.eql()的值对应：true、10000、&quot;操作成功&quot;、&quot;7ea56147-acf3-4527-a603-060a8ec52f34&quot;\n\n断言响应头Response headers: Content-Type header check\npm.test(&quot;Content-Type is present&quot;, function () &#123;    pm.response.to.have.header(&quot;Content-Type&quot;);&#125;);// pm.response.to.have.header(&quot;Content-Type&quot;)\tPostman响应结果中响应头有&quot;Content-Type&quot;\n\n增加value\npm.test(&quot;Content-Type is present&quot;, function () &#123;    pm.response.to.have.header(&quot;Content-Type&quot;,&quot;application/json;charset=UTF-8&quot;);&#125;);\n\nPostman全局变量&amp;环境变量\n全局变量：全局唯一的，不可重复定义的变量\n环境变量：\n一个变量只能属于某个环境，在某一个环境中变量不可重复定义\n在环境与环境之间可以定义重复的变量\n一个环境可以包含多个环境变量\n常见的环境分类：开发环境、测试环境、生产环境\n\n\n\n设置变量全局变量\n手动设置\n代码设置pm.globals.set(&quot;var_name&quot;,value);\n\n环境变量\n手动设置\n代码设置pm.environment.set(&quot;var_name&quot;,value);\n\n获取变量值全局变量\n请求参数（查询参数、请求头、请求体）中获取：\n代码中获取：var value = pm.globals.get(&quot;var_name&quot;)\n\n环境变量\n请求参数中获取：\n代码中获取：var value = pm.environment.get(&quot;var_name&quot;)\n\nPostman请求前置脚本假设一种场景：调某接口时，要输入时间戳（从1970.1.1 00：00：00~写在所经历的秒数），如果输入的时间戳的绝对值超过标准时间10分钟，不允许调用。\n请求前置脚本在http请求发送之前会先执行。书写在“Pre-request Script”。在请求发送之前自动运行其中的代码。\n携带时间戳向百度服务器发送请求。\n\n\n\n\n内部过程\n\nPostman关联用来解决接口和接口之间调用的依赖关系，需要借助全局变量、环境变量来实现关联问题\nA接口返回的数据供B接口使用：\n\n组织A接口http请求数据，发送A接口请求\n获取A接口返回的响应数据，写入全局、环境变量中\n组织B接口http请求，从变量中获取A返回的数据\n\n从天气接口获取城市\n\n\n\n\n测试报告执行测试使用newman命令，运行导出的测试集脚本，打开cmd输入：\nnewman run 测试脚本文件 -e 环境变量文件 -d 测试数据文件 -r html --reporter-html-export report.html\n","categories":["test"],"tags":["test"]},{"title":"测试点设计","url":"/2024/03/25/%E6%B5%8B%E8%AF%95%E7%82%B9%E8%AE%BE%E8%AE%A1/","content":"对穷举场景设计测试点等价类划分法说明|分类|步骤一种典型的、重要的黑盒测试方法，是指某个输入域的子集合，在该子集合中，所有的输入数据对于揭露软件中的错误都是等效的。\n\n\n有效等价只取其一，每个无效集合取1个\n设计一个新的测试用例，使其尽可能多的覆盖尚未被覆盖的有效等价类，重复这一步直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步直到所有的无效等价类都被覆盖为止\n\n适用场景\n通过等价类把穷尽测试转化为有限的有效测试\n举例\n用户名长度6~18，必须以字母数字下划线两者或两者以上组合\n微信红包\n按数据范围划分：不超过两位小数的值\n\n\n\n对限定边界规则设计测试点边界值分析法边界范围节点内点一般取居中的点最多7条\n边界值法设计用例步骤\n案例优化\n适用场景单个输入框，常用的方式：边界+等效类\n对多条件依赖关系设计测试点因果图法使用场景：当需求中存在多个条件，不同条件中存在不同的结果，就会使用因果图法。\n分别列出需求中的因子（条件）和结果\n判定表法\n等价类边界值分析法主要关注单个输入类条件的测试\n并未考虑输入条件之间的各种组合、输入条件于输出结果之间有相互制约关系的测试\n判定表法要求多个条件之间有依赖或制约关系\n\n判定表定义及组成部分判定表&#x3D;条件桩（需求中的因子）+动作桩（需求中的结果）+条件项（不同因子的组合）+动作项（不同因子造成结果的组合） \n\n判定表法设计用例步骤\n使用场景如果条件超过4个，就不适合覆盖所有条件，应采用正交法来解决。\n正交实验法利用因果图设计测试用例时，作为输入条件的原因和输出结果之间的因果关系，有时候很难从软件需求规格说明中得到。往往因果关系非常庞大，提取的用例数目多的惊人，则可以采用正交实验设计方法。\n正交表$$L_n(m^k)$$\n\nn是表的行数，也就是需要测试组合的次数\n\nk是表的列数，表示控件的个数（因素的个数，或因子个数）\n\nm是每个控件包含的取值个数（各因素的水平数，即各因素的状态数）\n\n如$$L_9(3^4)$$有4个控件\n每个控件有3个取值\n9为需要测试的组合个数\n\n\n\n对于项目业务设计测试点场景法对项目的业务流程功能用例的设计基于场景法来进行设计\n通过场景描述的业务流程（业务逻辑），也包括代码实现逻辑，设计用例来遍历场景（路径），验证软件系统功能的正确性\n正常流&#x2F;基本流：从起点开始，通过各个路径，在最后的节点结束。模拟用户正常操作的流程\n异常流&#x2F;错误流&#x2F;备选流：从起点开始，可能在某个节点结束或者会返回上一节点，模拟用户错误的操作的流程。\n流程图业务流程图是基于场景法设计测试用例的依据，由产品去提供业务流程图\n\n\n覆盖业务测试需要使用流程图法\n先测试业务、再测试单功能、单模块、单页面\n\n使用场景业务用例必须先测案例3-1：\n错误推测法（反推法）\n通过经验推测程序中所有可能出现的问题，主要依靠经验、知识、直觉\n根据经验列举出可能出现问题的清单，根据清单分析问题可能原因，推测发现缺陷。\n探索性测试\n\n\n场景\n\n当项目用例都执行完毕且BUG修复完成，离上线还有一段时间，在这段时间中可以使用错误推测法复测主要业务或未测试的功能\n\n白盒测试\n语句覆盖：可执行语句至少被执行一次；\n判定覆盖：每个判断的取真分支和取假分支至少经历一次；\n条件覆盖：每个条件的可能取值一次；\n判定条件覆盖：每个判定真假各一次，每个判定中的条件各取一次\n条件组合覆盖：每个条件的所有可能都至少出现一次，并且判定结果至少出现一次 ；与条件覆盖的区别：他不是简单要求每个条件出现“真”和“假”两种结果，而是要求这些结果所有可能至少出现一次；判定中所有条件的总和\n路径测试：执行所有可能的执行路径；\n基本路径测试（判断&#x2F;条件覆盖）： 路径测试执行了每个路径，每个判定的结果肯定经历过一次\n循环测试：是一种测试方法，其核心思想是多次重复执行相同或类似的测试用例，以发现软件系统在长时间运行或多次执行下的稳定性、性能、内存管理等方面的问题。循环测试通常用于评估软件系统在长时间运行或重复执行下的表现，并且可以帮助识别潜在的内存泄漏、资源泄漏、性能下降等问题。\n\n用例评审设计完用例后要进行用例评审，评审要检测用例的覆盖率和检查是否错写测试用例。评审分为组内和组外评审用例评审通过之后进行用例归档，再进入用例执行阶段。\n笔试面试题\n用例需要评审么？紧急情况用例也需要评审么？\n需要评审，紧急情况也需要评审，可能不通过会议进行评审，会通过邮件发给相关人员\n\n如果被测项目很紧急，来不及写用例，怎么办？\ncheck list，使用xmind列出测试点，根据检查点进行测试，测试完之后时间足够的时候补充用例——后期要进行回归测试，也可以知道当时是怎么覆盖的\n\n遇到隐形需求如何写用例（需求不明确）\n熟悉当前的功能，参考成熟产品，站在用户角度挖掘需求，去和产品沟通\n\n用例有没有优先级？如果一定要有优先级，依据什么来确定呢？\n有，根据功能，使用的场景是不是重要的，核心的\n\n如何去编写测试用例？（以项目为基础来讲一个小模块用例设计，手机号）\n\n编写测试用例会用到什么方法？\n先去了解项目的业务流程，对于业务流程的用例使用场景法写，针对某些输入功能用等价类边界值来进行设计，需求里面存在多个条件多个组合，使用因果图判定表设计\n\n\nweb测试测试点：前端页面发布上线之前需要检查（描述不恰当的文字出现）所有注释或去除注释img图片必须要有title属性（悬停和未加载显示）按钮测试点：统一使用value赋值\n","categories":["software test"]},{"title":"用例执行及缺陷","url":"/2024/03/25/%E7%94%A8%E4%BE%8B%E6%89%A7%E8%A1%8C%E5%8F%8A%E7%BC%BA%E9%99%B7/","content":"用例执行执行结果与用例的期望结果不一致（含义），为缺陷，需要进行缺陷管理\n测试计划一份描述测试工作计划的测试文档，对测试工作进行统筹计划安排\n测试计划编写者：测试主管&#x2F;leader\n测试计划的查阅者：测试人员、测试主管&#x2F;leader、产品、开发、销售人员\n面试题\n测试计划包含哪些内容？（测试人员会查阅评审测试计划）\n5W1H—&gt;目的（why）、测试范围（what）、时间安排（when）、测试环境（where）、测试人员（who），怎么去测试（how 测试方法、测试工具）\n测试风险评估，一般存在风险（需求变更&#x2F;需求做增加），测试的时间会增加—&gt;方案：测试时间拉长，人员调配，协调，加班，做计划的时候，时间安排做一些需求变更的预留。测试人员的变动—&gt;人员调配、协调、加班\n\n在测试阶段，如何保证用例的覆盖率？\n先做测试需求分析，进行评审，防止错测和漏测。进行用例设计的时候结合不同的设计，用到不同的设计方法，尽可能的去模拟用户所有的测试数据及测试场景，把对应的测试点全部进行覆盖。写完用例之后也会进行评审。\n\n测试的工作量占整个项目的时间比例多少\n测试30%&#x2F;40%,开发70%60%\n\n\n缺陷\n软件在使用过程中存在的任何问题都叫软件的缺陷，简称bug。广义概念除此之外还包括测试工程师或用户所发现和提出软件可改进的细节、或与需求文档存在差异的功能实现\n\n缺陷的判定标准 \nbug的类型\n代码（功能）错误：功能错误、性能、安全\n界面优化：界面、易用性测试\n设计缺陷：建议优化的bug\n\nbug的等级bug等级越高，修复的优先级也越高，问题越严重数字越小\n（1）致命错误（blocker）：\n\n常规操作引起的系统崩溃、死机、死循环、闪退\n造成数据泄露的安全性问题，比如恶意攻击造成的账户私密信息泄露\n涉及金钱计算（延时不算致命）\n阻断性测试，所有测试工作进行不下去（冒烟测试）\n\n（2）严重错误（critical）：\n\n重要功能不能实现\n错误的波及面广，影响到其他重要功能正常实现（次要功能影响到关联的核心功能）\n非常规操作导致的程序崩溃、死机、死循环、闪退\n外观（界面）难以接受的缺陷\n密码明文显示（界面+数据库）\n偶现的致命性bug（记录复现率）\n\n（3）一般错误（major）：\n不影响产品的运行、不会成为故障起因，但对产品外观和下道工序影响较大的缺陷\n\n次要功能不能正常实现\n操作界面的错误（包括数据窗口内列名定义、含义不一致）\n查询错误，数据显示错误\n简单的输入限制未放在前端进行控制\n删除操作未给出提示\n偶现的严重性bug\n\n（4）细微错误（minor）：\n\n界面方面的问题\n描述错误、错别字\n\n（5）改进建议（enhancement）\n缺陷产生的原因\n\n需求文档\n架构设计\n编码实现\n环境（硬件、软件）\n\n软件缺陷生命周期\n软件缺陷的核心内容\n缺陷提交要素\n测试报告内容包括测试范围、测试环境、数据统计（bug数据、bug状态、bug类型统计、按功能模块统计）、测试总结（测试用例数、执行率、成功率【用例通过率】、缺陷的关闭率、遗留bug情况【一二级修复情况，遗留bug等级，及情况说明】，结论是ST测试通过&#x2F;不通过）\n软件缺陷类型\n\n工作流程\n\n\n设计用例-&gt;执行用例（执行测试）-&gt;缺陷（提交、验证、关闭）\n缺陷定义：任何问题Bug\n缺陷标准；多功能、少功能、错误、缺少隐形功能、易用性\n项目中缺陷管理流程：提交、验证、关闭\n描述缺陷：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注\n提交缺陷信息：指派人、缺陷等级、修复优先级、类型、状态（统计）\n\n缺陷编写缺陷编写示例\n缺陷的跟踪流程\n提交缺陷注意事项当发现缺陷后，首先应该保证缺陷的可复现，确定是bug再提交。提交时，要检查缺陷是否已存在\n缺陷编写规范\n缺陷标题分析\n描述测试数据+实际结果（预期结果）：标题15位纯数字结果合法（期望：不合法）\n测试数据描述+预期结果（实际结果）：标题15位纯数字预期不合法（实际：合法）\n测试数据描述+实际结果（需求）：标题15位纯数字结果合法（需求：标题为15位字符）\n\n项目管理流程\n","categories":["software test"]},{"title":"认识软件及测试","url":"/2024/03/25/%E8%AE%A4%E8%AF%86%E8%BD%AF%E4%BB%B6%E5%8F%8A%E6%B5%8B%E8%AF%95/","content":"什么是软件测试什么是软件？控制计算机硬件工作的工具，分为：\n\n应用软件：计算机用户为了解决某些具体问题而购买、开发或研制的各种程序或软件包\n\nC&#x2F;S架构：client-server，需要安装客户端才能够使用的软件，每次更新都需要更新服务端和客户端\nB&#x2F;S架构：browser-server，只需要更新服务器，通过浏览器访问\n\n\n系统软件：生成、准备和执行其他程序所需要的一组文件和程序。\n\n\n软件基本组成软件是计算机程序、程序所用的数据及相关文档资料。\n软件&#x3D;程序+数据+文档\n\n软件的产生过程：\n\n什么是软件测试？使用人工和自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。\n\n软件测试的目的\n为了发现程序（软件）存在的代码或业务逻辑错误（找到bug）\n为了检验产品是否符合用户需求（提升质量）\n为了提供用户的体验（提高用户体验）\n\n\n测试的主流技能\n功能测试：根据文档执行，将反馈结果与预期结果比较。功能测试主要验证程序的功能是否满足需求\n自动化测试：使用代码或工具代替手工，对项目进行测试\n接口测试：使用代码或工具对服务端提供的接口进行测试，验证程序中的接口是否访问正常。\n性能测试-工具实现：模拟多人使用软件，查找服务器缺陷\n负载测试（Load Testing）：模拟实际用户的使用情况，测试系统在不同负载下的性能表现。\n压力测试（Stress Testing）：通过逐渐增加负载，测试系统的极限性能，以确定系统在超负荷情况下的表现及其响应能力。\n容量测试（Capacity Testing）：评估系统在预期负载下的性能，并确定系统是否能够满足预期的容量需求。\n性能基准测试（Performance Benchmarking）：与已知标准或竞争对手进行比较，评估系统的性能表现。\n稳定性测试（Stability Testing）：在长时间负载下测试系统的稳定性，以检测潜在的内存泄漏、资源泄漏或其他性能问题。\n\n\n\n常见的测试分类按测试阶段划分\n\n单元测试：为了确保各单元模块被正确的编译，比如有具体到模块的测试，也有具体到类、函数、方法的测试。bug太多，修复率太低，开发人员自测\n\n集成测试（接口测试）：单元测试后，将各单元组合成完整的体系，测试单位之间的接口是否正确、数据能否正常传递。\n\n组件整合：将各个独立开发的模块或组件整合到一个系统中，并测试它们在集成后的行为。\n接口测试：验证模块之间的接口是否正确地传递数据和调用功能。\n功能测试：确保整个系统的功能按照规格说明书的要求正常工作。\n异常处理：测试系统在异常条件下的行为，例如错误输入或非预期操作。\n性能测试：在集成环境中评估系统的性能，包括响应时间、吞吐量和资源利用率等方面。\n\n集成测试通常分为两种策略：\n\n自下而上（Bottom-Up）：从最底层的模块开始测试，逐步向上测试到系统的顶层。这种方法可以尽早发现低层模块的问题，但需要模拟高层模块的行为。\n自上而下（Top-Down）：从系统的顶层开始测试，逐步向下测试到最底层的模块。这种方法可以更早地测试到系统整体的行为，但需要使用模拟或桩程序替代尚未开发完成的低层模块。\n\n\n系统测试：把软件系统搭建起来，按照软件规格说明书中所要求，测试软件其性能功能是否和用户需求相符合，在系统运行中是否存在漏洞。看做整体进行测试，除功能以外，需求、兼容性也需要考虑。\n\n功能测试：验证系统的功能是否符合规格说明书中的要求，包括正常功能和边界情况下的功能。\n性能测试：评估系统在正常和负载条件下的性能表现，包括响应时间、吞吐量、资源利用率等指标。\n兼容性测试：测试系统在不同操作系统、浏览器、设备和网络环境下的兼容性。\n安全性测试：评估系统的安全性，包括数据保护、身份验证、授权和防范潜在攻击的能力。\n可靠性测试：验证系统在长时间运行和异常条件下的稳定性和可靠性。\n易用性测试：评估系统的用户界面和交互设计是否符合用户的期望，以及系统是否易于使用和理解。\n\n\n验收测试（Acceptance Testing）：软件开发生命周期的最后一项测试活动，也是在软件交付给最终用户之前的最后一道关卡。其目的是确保软件系统满足最终用户的需求，并且符合预期的使用情境和业务流程。验收测试通常由最终用户、客户或业务代表来执行，因为他们最了解软件系统应该如何满足业务需求。\n\n确认需求满足：验证软件系统是否满足了最初的用户需求和业务规格。\n功能完整性：确保系统的所有功能都按照规格说明书和用户期望的方式运行。\n用户体验：评估系统的易用性、用户界面设计、交互流程等，确保用户能够轻松地使用系统。\n业务流程：验证系统是否支持所需的业务流程，并且在真实的业务环境中能够正常运行。\n性能：确认系统在预期负载条件下的性能表现是否符合要求。\nα测试：在开发者环境中由客户或最终用户进行测试。测试环境受开发方控制，测试人员不多，测试时间比较集中。执行者：测试人员、用户、公司内部人员\nβ测试：在真实的生产环境中由一组选择的最终用户进行测试。\n合同验收测试：在合同规定的时间和地点由客户和供应商共同进行的测试。\n一般先做α测试再做β测试\n\n\n\n按代码可见度划分\n\n黑盒测试（Black Box Testing）：是一种软件测试方法，它着眼于测试软件的功能性而不考虑其内部结构或实现细节。在黑盒测试中，测试人员不需要了解软件的内部逻辑、算法或源代码，而是将软件看作一个黑盒子，只关注输入与输出之间的关系。针对功能、兼容性进行测试。对应系统测试\n在黑盒测试中，测试人员根据软件的需求规格说明书、用户文档和设计文档等外部文档来设计和执行测试用例，以验证软件的功能是否按照预期工作。测试人员主要关注以下几个方面：\n\n功能测试：验证软件的功能是否符合规格说明书和用户需求。\n界面测试：测试软件的用户界面是否符合设计要求，以及用户是否可以轻松地与软件进行交互。\n用户体验测试：评估软件的易用性、可理解性和用户满意度。\n输入验证：检查软件对于各种输入的响应是否正确，包括合法输入、非法输入和边界值输入。\n状态转换测试：测试软件在不同状态下的行为，例如登录状态、注销状态等。\n错误处理：验证软件对于异常情况的处理是否正确，例如错误输入、系统故障等。\n\n\n白盒测试（White Box Testing）：又称为结构测试或透明盒测试，是一种软件测试方法，旨在评估软件系统的内部结构和逻辑，以验证其是否按照预期进行操作。白盒测试的重点在于测试软件的内部工作方式，包括代码覆盖率、路径覆盖率以及逻辑覆盖率等方面。\n白盒测试的主要特点包括：\n\n了解内部结构：测试人员需要深入了解软件的内部结构和源代码，以便设计和执行测试用例。\n代码覆盖：白盒测试通常包括评估测试用例覆盖的代码范围，例如语句覆盖、分支覆盖、路径覆盖等。\n逻辑测试：验证软件系统的逻辑是否正确，包括条件语句、循环语句和异常处理等。\n数据流分析：评估软件中的数据流和变量的使用，以确保数据的正确性和一致性。\n性能测试：评估系统的性能和资源利用率，包括内存使用、处理时间和吞吐量等方面。\n安全测试：评估系统的安全性和防御机制，包括对潜在的安全漏洞和攻击面的分析。\n\n白盒测试通常由具有开发或编程经验的测试人员来执行，因为他们需要深入理解软件的内部工作原理和代码结构。白盒测试通常在软件开发的早期阶段进行，以便及早发现和解决潜在的问题，并在软件发布前提供更高的质量保证。\n白盒测试与黑盒测试相辅相成，可以共同确保软件系统的质量。白盒测试主要关注软件内部的正确性和结构，而黑盒测试则关注软件的外部功能和用户需求是否得到满足。\n\n灰盒测试（Gray Box Testing）：是介于白盒测试和黑盒测试之间的一种软件测试方法。在灰盒测试中，测试人员部分了解软件的内部结构和实现细节，但不需要深入到源代码的层面。灰盒测试旨在结合黑盒测试的功能性测试和白盒测试的结构性测试，以提高测试覆盖率和效率。\n在灰盒测试中，测试人员通常可以访问一些关于系统内部的信息，例如数据库结构、应用程序框架或部分源代码。这种了解使得测试人员可以更有效地设计测试用例，并更好地理解系统的内部运行机制，以便更有针对性地进行测试。\n灰盒测试通常涉及以下几个方面：\n\n功能测试：类似于黑盒测试，验证系统的功能是否按照规格说明书和用户需求工作。\n接口测试：验证系统的不同模块之间的接口是否正确，以及数据传递是否正常。\n性能测试：评估系统在不同负载条件下的性能表现，包括响应时间、吞吐量和资源利用率等指标。\n安全性测试：评估系统的安全性，包括身份验证、授权、数据保护等方面。\n代码覆盖率分析：通过部分了解系统内部结构，测试人员可以评估测试覆盖率，并确定哪些部分需要更多的测试。\n\n由于灰盒测试结合了黑盒测试和白盒测试的优点，因此可以更全面地测试软件系统，并发现更多的潜在问题。然而，灰盒测试可能需要测试人员具备更多的技术知识和理解能力，以便更好地利用系统内部信息进行测试。\n\n\n被测对象是否运行\n动态测试：运行被测试系统而进行的测试\n静态测试：不需要运行被测试系统而进行的测试（界面检查、文档检查、代码走查）\n\n包含内容划分\n功能测试\n界面测试\n易用性测试\n性能测试（负载测试、压力测试）\n安全测试\n\n其他测试\n冒烟测试：硬件测试中产生的概念。在进行正式测试前对主要核心功能进行的测试，一般由开发或者测试主管来负责。不通过会发回给开发\n回归测试：开发对存在问题的功能进行修改后再一次进行的测试，也需要验证相关功能\n探索性测试&#x2F;自由测试：根据项目经验进行的随意测试\n\n软件的生命周期SDLCSystems Development Life Cycle指的是软件从概念阶段到终止阶段的完整过程。它描述了软件开发团队在设计、开发、测试、部署和维护软件产品时所遵循的步骤和阶段。\nSDLC通常包括以下阶段：\n\n需求分析（Requirements Analysis）：在这个阶段，团队和利益相关者确定软件系统的功能、性能、安全性等方面的需求，并将其记录在需求规格说明书中。\n设计（Design）：在这个阶段，基于需求分析的结果，设计团队开始制定软件系统的结构、组件和界面等，通常包括高级设计（High-Level Design）和详细设计（Detailed Design）。\n实现（Implementation）：在这个阶段，开发团队开始根据设计文档编写和测试代码，创建软件系统的各个功能模块，并逐步集成和测试这些模块。\n测试（Testing）：在这个阶段，测试团队对软件系统进行功能测试、性能测试、安全测试等，确保系统符合预期的功能和质量标准。\n部署（Deployment）：在这个阶段，将已经测试通过的软件系统部署到生产环境中，并进行最后的验证和配置。\n维护（Maintenance）：在这个阶段，团队负责维护软件系统，修复已知的缺陷、更新和升级系统，以确保系统的稳定性和安全性。\n\n瀑布型生命周期\n特点：自上而下、有顺序性\n缺点：回测成本比较高、测试周期比较长\nW模型\nW 模型是一种经典的软件开发和测试模型，它将软件开发和测试分为两个主要阶段：左侧的开发阶段和右侧的测试阶段。在开发阶段，软件需求被转化为软件设计、编码和集成，而在测试阶段，各种测试活动，如单元测试、集成测试、系统测试和验收测试，与相应的开发阶段相对应。\nW 模型强调了测试活动与开发活动的对应关系，同时在测试活动的各个阶段都可以进行相应的验证和确认，以确保软件质量。它适用于大型软件项目和要求高质量的软件开发过程。\n活动串行：测试与开发同步进行，在V模型的基础上增加了在开发阶段的同步测试\n局限：不支持迭代，减少了一定错误发生率，但是需按照流水线进行设计、编码和测试\n\n\nV模型\nV 模型是一种与 W 模型相似的软件测试模型，它强调了软件开发阶段与相应的测试阶段之间的对应关系。与 W 模型不同的是，V 模型将每个开发阶段都与一个相应的测试阶段直接相对应，形成了一个”V”字形的结构。\nV 模型强调了测试活动与开发活动之间的紧密关系，每个开发阶段的产物都可以直接对应一个相应的测试活动，以确保每个阶段的质量控制。它适用于需求明确、项目周期较短的软件开发项目。\n局限：仅仅把测试过程作为编码之后的一个阶段\n\n\n需求分析阶段会产生需求规格说明书（SRS），测试根据这个编写测试用例。\nV模型开发中，测试在需求阶段就已经介入了，可以降低测试成本，缩短开发周期。\n传统、周期长的项目使用V模型\nH模型\nH 模型是一种将软件开发和测试交错进行的测试模型，它将软件开发过程和软件测试过程在时间上交错进行，以加快软件交付的速度。在 H 模型中，软件开发和测试活动是同时进行的，并且它们之间会有多次的交互和反馈。\nH 模型强调了软件开发和测试的并行进行，测试活动可以早早地介入到软件开发过程中，及时发现和修复问题。它适用于需要快速迭代和交付的敏捷开发项目。\n活动并行：过程活动完全独立，贯穿于整个产品的周期，与其他流程并发地进行，某个测试点准备就绪时，就可以从测试准备阶段进行到测试执行阶段；软件测试可以进行尽早的进行；软件测试可以根据被测物的不同而分层次进行。\n\nX模型\nX 模型是一种将软件开发和测试活动交叉进行的测试模型，它强调了开发和测试活动之间的协作和合作。在 X 模型中，开发和测试活动是并行进行的，并且它们之间会有多次的交互和沟通。\nX 模型强调了团队协作和质量管理，在软件开发和测试的过程中，开发团队和测试团队可以紧密合作，共同推动软件的开发和测试工作。它适用于迭代开发和敏捷开发项目。\n单独的单元设计开发测试，测试完成后凭借接口集成在一起。支持探索性测试。\n支持需求不断变化，并且加入探索性测试，便于发现测试计划之外，发现更多的缺陷。\n\n\n敏捷模型\n强调以人文本，把一个大项目分为多个相互联系但也可以独立运行的小项目并分别完成，在这个过程中软件一直处于可使用状态。\n开发与测试并行，项目周期快，模块提交快，测试时比较有压力；注重团队沟通，测试人员几乎要参加整个项目组的讨论决策会议；独立完成各项测试计划，测试执行工作；\n具备良好的自动化测试框架支持进行快速测试；\n在活动中关注产品需求，产品设计，解读源代码。\n特点：快，迭代周期短。弱化文档，通过人与人的沟通实现需求\n\n\n软件生命周期的各阶段问题的定义及规划主要确定软件的开发目的及其可行性，制定项目总体开发计划\n需求分析在确定软件开发可行的情况下，对软件需要实现的各个功能进行详细分析，明确客户的需求，输出需求规格说明书终版（原型图），提交评审\n设计把需求分析得到的结果转换为软件结构和数据结构，形成系统架构\n概要设计：主要是架构的实现，指搭建架构、表述各模块功能、模块接口连接和数据传递的实现等项事务\n详细设计：对概要设计中表述的各模块进行深入分析等，其中需要包含数据库设计说明\n编码按照详细设计好的模块功能表，编程人员编写出计算机可运行的程序代码\n测试单元测试、集成测试、系统测试、验收测试\n运行维护是软件生命周期中持续时间最长的阶段，在软件开发完成并投入使用之后，由于多方面的原因，软件不能继续适应用户的需求。要延续软件的使用寿命，就必须对软件进行维护。软件的维护主要包括纠错性维护和改进性维护两方面。\n质量模型衡量一个优秀软件的纬度\n\n功能性：\n性能：\n兼容性：\n易用性：\n安全：\n可靠性：\n可维护性：核心代码要有说明，该独立的要独立\n可移植性：\n\n软件测试流程\n在什么条件下可以发布？剩余bug数量很少，达到一定的用例执行覆盖率\n发布流程：开发打包—&gt;运维&#x2F;运营&#x2F;开发—&gt;部署到生产环境（用户的使用环境）\n\n开发环境：开发人员写代码的环境\n\n测试环境：测试人员进行测试的环境（1个或一个以上）\n\n预发布环境（UAT环境）：验收测试（UAT测试）进行的环境。\n\n生产环境：真实用户使用环境\n\n\n测试方式\n灰度测试（Gray Testing）：是软件测试中一种渐进式的测试方法，也被称为渐进式部署测试或金丝雀测试。在灰度测试中，新版本的软件系统被部署到一小部分用户或用户群体中进行测试，而不是立即对所有用户进行全面的部署。灰度测试的主要目的是逐步引入新版本的软件系统，以确保其在真实环境下的稳定性和可靠性。通过将新版本的软件系统部署到一小部分用户中进行测试，可以及早发现和解决潜在的问题，减少对全体用户的影响。\n\nA&#x2F;B测试：A&#x2F;B测试是一种在在线环境中常用的实验设计方法，用于比较两个或多个版本的产品或服务，以确定哪个版本能够更好地实现预期的目标。在A&#x2F;B测试中，将用户随机分成多个组，每个组将被暴露于不同的版本中，并记录用户的行为数据，最后分析数据以确定哪个版本更有效。\n\n\n二者区别灰度测试（Gray Testing）和 A&#x2F;B 测试是两种不同的测试方法，虽然它们都涉及将用户分成不同的组来比较不同版本的产品或服务，但在实践中有着不同的应用场景和目的。\n\n目的和应用场景：\n灰度测试通常用于验证新版本的软件系统在真实生产环境中的稳定性和可靠性。它通过逐步将新版本应用于一小部分用户来测试系统的性能和用户反馈，以减少对整个用户群体的风险。灰度测试的主要目的是确保新版本的软件系统在全面部署之前已经经过了充分的测试和验证。\nA&#x2F;B 测试主要用于比较两个或多个不同版本的产品或服务，并确定哪个版本能够更有效地实现预期的目标。它通常在在线环境中使用，例如网站、移动应用或电子邮件营销中，通过将用户随机分成多个组，向不同组展示不同版本，并收集用户行为数据来确定哪个版本更有效。\n\n\n用户分组方式：\n在灰度测试中，用户通常被随机分成不同的组，但是每个组中的用户都暴露于相同的版本。灰度测试的目标是在一小部分用户中测试一个版本的性能，而不是比较不同版本之间的差异。\n在 A&#x2F;B 测试中，用户也被随机分成不同的组，但是每个组中的用户将暴露于不同的版本。例如，一个组将看到版本 A，而另一个组将看到版本 B。A&#x2F;B 测试的目标是比较不同版本之间的差异，并确定哪个版本更有效。\n\n\n测试内容和指标：\n灰度测试通常关注新版本的软件系统在生产环境中的性能、稳定性和用户反馈等方面的指标。\nA&#x2F;B 测试通常关注不同版本的产品或服务在用户行为、转化率、点击率等方面的指标。\n\n\n\n流程\n各个阶段的输出需求分析——根据需求规格说明书输出项目需求分析测试点列表\n用例设计——测试用例文档\n执行测试——bug\n评估测试——测试报告的输出\n\n\n需求评审\n\n\n参与角色：产品经理、开发、测试\n目的：需求一致、在各角度对需求进行查漏补缺、知道被测项目有哪些功能模块\n\n\n测试计划\n\n\n测什么、谁来测、怎么测\n\n\n用例设计 针对穷举进行设计\n用例执行\n缺陷管理\n测试报告\n\n测试需求分析解决测什么的问题，一般来自需求规格说明书中原始需求。测试需求应全部覆盖已定义的业务流程，以及功能和非功能方面的需求。\n功能：业务流程\n非功能：界面、文档、兼容性、易用性、性能、安全性\n根据需求规格说明书明确的测试的内容提取测试点，测试点是软件的最小单元\n测试需求分析的目的\n测试需求分析是编写测试用例的依据\n有助于保证测试的质量与进度\n测试需求是衡量测试覆盖率的重要指标\n\n需求分析的步骤\n查阅需求规格说明书（原型图），初步熟悉被测软件的核心的业务流程\n针对某个功能，细化需求，列出测试点\n根据业务逻辑的先后顺序来进行分析按钮，一般按钮存在（什么条件）操作成功，（什么条件）操作失败，验证操作结果（验证交互功能、即关联功能），验证当前操作的结果的功能\n\n一个页面进行测试需求分析\n进行页面检查，参考原型图，查看界面是否一致\n依次分析每个输入项，从上到下从左到右的顺序进行分析约束限制、是否必填、是否重复、隐形需求（如手机号码的格式验证）。\n\n案例\n面试题\n遇到隐形需求怎么办？\n要充分熟悉产品，参考成熟的同类产品，站在用户的角度去考虑，从而挖掘需求\n\n给你一个带logo的水杯，你会如何去测试？先明确测试的对象，什么样的杯子\n对应功能：能否装水，是否漏水，能否装热水冰水饮料，是否保温\n对应非功能：logo是否与原型图一致，美观，是否掉色，材质是否环保安全\n对应易用性：防滑，防烫，是否带手把，边缘是否光滑，携带是否方便\n兼容性：是否能装其他液体\n安全性：装热水的时候会有毒素吗\n性能：（如果是保温杯的化可以保温多久），是否防摔，挤压被子会不会坏，容不容易被水泡软\n\n你会如何测试朋友圈，购物车等熟知的软件产品（支付，优惠券，二维码）\n\n\n\n需求评审需求分析完成后要对需求进行评审，评审是否存在漏测和错测的测试点。\n参与人员：测试人员、组内人员、测试主管&#x2F;组长、产品、开发\n测试用例什么是用例？用例：用户使用的案例\n什么是测试用例？测试用例：为项目需求而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序是否满足客户需求。每一个测试点的数据设计和步骤设计\n测试用例的作用\n防止漏测\n实施测试的标准\n\n用例格式标准用例执行的八大要素| 用例编号 | 项目&#x2F;模块  | 用例标题 | 优先级 | 前置条件 | 测试步骤 | 测试数据 | 预期结果 |\n\n用例编号：项目简称_模块简称_编号，产品名-测试阶段（it、st、uat）-测试项-xxx（英文）或者项目+编号\n\n项目&#x2F;模块：所属项目或模块\n\n用例标题：主要描述测试的目的，输入内容＋结果，用例标题不要重复\n\n优先级：表示用例重要程度或者影响力P0~P4（P0最高，用户使用频率最高为核心功能）。高（主要核心业务功能，冒烟用例）中（错误异常的测试点，如注册失败）低（兼容性、界面错误）\n\n前置条件&#x2F;预置条件：要执行此条用例，有哪些前置操作。可以用来简化步骤。如果用例不需要其他条件，可以无条件\n\n测试步骤：执行用例步骤\n\n\n路径\n具体数据\n操作动作\n\n\n\n\n测试数据：操作的数据，没有的话可以为空（可以和操作步骤分开）\n\n预期结果：按照操作步骤，应该有什么结果，分为一对一（一个步骤对一个结果）和多对一（多个步骤对一个结果）用例执行结果+不同角色隐形结果\n\n实际结果：通过、不通过、阻塞（当前用例无法执行）\n\n（备注）：bugid&#x2F;测试无法执行原因\n\n（测试版本）\n\n（用例设计者）\n\n（测试时间）\n\n\n用例是根据测试点进行编辑，但并不是针对每个测试点编辑一条用例，否则会造成重复测试\n软件测试八大原则\n所有的软件测试都应追溯到用户需求\n应当把“尽早地和不断地进行软件测试”作为软件测试者的座右铭（在需求阶段介入是最好的）（重复测试挖掘更多bug）\n完全测试是不可能的，测试需要终止\n测试无法显示软件潜在的缺陷\n充分注意测试中的群集现象（80%的bug出现在20%的模块中）\n开发工程师应避免测试自己的程序\n尽量避免测试的随意性（容易出现漏测）\n测试的抗药性\n\n","categories":["software test"]},{"title":"项目实战演练","url":"/2024/04/07/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83/","content":"\n  f58a0006b15efc4af1859defe635348894f92579ba7dd8952c6dd5f6d61ab193848cd94d18010a2d65b9141b0f47184430ace0360ef4c11f206d05d3f7c5954b9bceff237a8ebe38b5393666faa9312140b66d8a1fa1f586562d63ecd19d8e887a97b7fec059c4bf1a669ba037481b1e33df2ba056136b89e9c60be2ee57eef44e52abdb7bd2ae895d14d5fd53f8a26712d72c893e4fbf5adf630e75fad673c5f1357f036fa8999b715e24da2abf6c7f71aac467f56a70497557bfeb277558c10fe9ce0ec8f99a5eb042cada69096c63b0cd9aeb22d9528f7566f503059732837b508a5ede4d2231d4b32a4330a0e605f38bb2be0f67782106d9e4d7927571fac3f769cb8b6966be9fa2b2fb858348ddd2a78f046e1a136ae55c22e7b39dff68276691f24fdba53edfc5065e61dbe31c42d97e1478f4aa3ca9b40b0e8c8c4136cf38970902a9692d7041311112b7062cf0eccde7d67378b1aef2ea122dc53aacbeaae3d1fbc88dc5d648fd7ce3f5285ba00a0965c068b3d6dfdf3a5f5dc741af5e27669b5fb5af0beebceb3c4fd0dd1480eabec8248576f8ae82248361d0ee5eaf4686a557edddfe8fb994c5d03d4f1c688712078eb9ae9963e55266448862e3b87dd4e13d55c27d54abe4bbceccc2e483e2acf7b145490f91577fb33ca23de059434d81c299424aceafaf10aa864cae0684c0ae1f5ca61995e26b4016ac63336cbf7453d138d1c82bea4dbf78db0c0099fd480cf477eba42341932d8aefaeefb7ab6ae66c71f03ce6305d3092b5449fc841439d2a27bb7ab56c7b1b78621bd2da20baf57f85739b3d01b9832091ee2b792372228ed0eb3dbc34870e5a5e7453208f0adb9ed7a81ed9a8ecf8c7fa8b3025d942a0c00ffcadc4a927d7e9abe8320f7a3d4cf0d8f54a503822eaa5d92170741a259b75064ace183144df406d9958c7ff5529445f19c5828d8c0c370197f937ed587714574d28e71471c7e7c7cb9df936eee33c15168df93ea72951a86b9f3f125d5d695b9bf42817034eb7360fa9becd2c95547c52d07f390e44049f5fbba0df0e9f9e1234b6f8a124cd4e2bcc6ac992955cb8d0583f961b2f7ca33ac6aae3ce22520a5d1f45f17aa3def3eccd6deaa8ca37b122d148040bdd430943b9e6322408129360c5dc38e5f88f28b9a79c1ce7115c8ab84faa8c5bf79746ab8a8485c29ed2c8c1b167ea6afc85a1328ee6adc0d8bb3d94f048c5d81cf096ef1cd418f15d1a49666ae98b951172c2ba1796f219acc579b7727dcb8fe2d99d06dda84b6140f0505db2bfb60afb66d3e262e943a0fb0940383ca88a73734b57473b7cd95774c97fc51db506f05536f9bda589bd04e7e5c1af86d77093cdaa5c29841268bc0c96c9b75bcbd0e154b493ff859b7c86d51eb1d66b31415e00dcd000180baf1ed9c092a53b66fb9ecb9577981b05ef5c72a3fea2e3e22d30c0149e30ab140b02ddcc13d2305fae10f6957de36493d02306a443cf167726ad6b66ca5c6c91538cc4c234c93254064c17b4040fdb0525c8177e4d9834eb28520617e6189ec877bb680b1953d8a17c84054efc011d71b68d9cf7a83c7770bb5c529c6ae33752d42af5a60eaef0386598b3c0f6d55419c5b4df53fd93ad2ce57a9b4325268ecc8ccb633e50fe59fb037b06e8ea56fa5f468a8cf204716a8e6fae94dad2d57021e02332e0110867c233201cc639b7781740eb558234322690509f51f22f73c1c608332a9c378359d7e3bcdfac467feb41bfad54cb49fc23d24e5b6c44bd65967a42938c41d04c3838ae03405f5264d19eae49fffdd5dd3210648e994c14498de360299bea9eeb826578abd782d648894ce57680baad28422196eeab322fd61bd7f0bc54123e8d25b0a711c2833d8dee2299cd07a0497bdf6d43bbd3e453cad32b8119d1e05c0823e19dc2493b87642f0b66d857fcff01d33b0803eb714b809afef73bdfbf89c3924b2be0abb9567e1acfd65bf6949ae4e20abfd8b720d7f87dcb6e87f72482a246e91d9ad3e0477192b6825ebed29616c6b2862de9974479d26c6a1632768073255d8fdbf8c7047cb40441f153607536333ba3204d1ad804192300d0b0aa9e4eaba5a198d12dd8c1a7700f0763af9b19906a3e963bd2801647c35a7e408757d6c3ef345d7cdada00463178130feb768f3ed2040c9c3c4466ba1a162de228b9a6916b858218b94594da55b15b94ac08b990a1e912ee39ac92097a7309203680ae6674c0c6fc8d591ee9ebedc09c821db9e4e2ff511db243b9c304193b824d43d292a2e1853d5256fad7ee599d0075fcce8e84c679ec66ea5721bc933bec2197794109df94dc1dd9f0738a7903b42ef0a03a6d4d6ef02400d64371534240ba14099307c2b3266d1f1205e7044eb07f05ad2b4b938b88c64d07fc2f1b8736c078279cc5453aa1d77d50a3e36fdbb5b7c8934700a79d6baf8d4b93a0c5986d89c70710b2532a0ec186018e9c\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["software test"]}]