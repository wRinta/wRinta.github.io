[{"title":"C program language","url":"/2021/07/17/C-program-language/","content":"\n  52b957e64bf07e3f6f387f83f112f606a00cbcea95df80b68037ad6e34ae86b2d71d3c81abcbc1175f2502d364c86477724137c24bc6337b2efafea60055572eaf49b76785aa4e0152bc0668da97f4b374a505e4926c0c47f4e7561600d714405ed3ea923de8946130422aa8d4193a8f0e09ce84fba5ab603392e109f447c14ca87fce276bfb4830484f7934a6521592e1131eab2430a46fdd6d37f7610544d5dee4bad730e8d6c16d3018f178ebe3dc22185d97a44f273cc47c3264bbe2f312a4e18cce55b86973a06113a4814978c8fcaea5d2f32551fbe06a0d36c9882105e7fda1c3ce0c4fdc158b29a84466fe19e6f2f667465d917b1dfea961de4de39b9edef8ede2018cecfe93ffc359208b57bcf3ae205927987a957c0b04e29d6f3fad2a7a5c4103552150d79f7045f33e3aed581b38618f5eb8706b165a1e1c3bc1aae70de2459b1d816815aee98db1817da50134a5eb0c305a02cc71b650d2c945e23eccc38251b83a5550d0c4e89aa1d00c39edb71720ded59e85930094388e63c4a48dcf6ab65fc29b1d5ecc710029ef01f4780500f2bbda5da1494aa8108a6bbe604c7cb3a4340de5cf2ccda5e925858108903544a316738141f3ccbf2bf560bfe2ef95ba03e912f2ec3de0a2befa3c401bd269de3fb590293e27433393aaf9aa195d83271d1eb3bba2272418c4d73dd012e39aa5ed3bc65f8f8c8f15656b85dc5c248eca217aadaa28c8e9576cbba80b525c14b2909f68cf4260231905314657c3899df5cd2bbc97f60b6699068b9883c5b6d23d425e4f7b8827f2b9da46453eeecfcef45fa92db069d988aa1997ff8a4da560c4c84220bb975828d87dfdd50b9b26bc5243086ae1541a43f60c569bc4074d5d906b3e0e38608ef600214e0245caffc0a45105fec70d245954fb646484f93946307ee90d8464c147826e976f3e6f57ba4b9d8dd5063f69f1ab33c2ce644363656ff79c56259b9c94cdcd7f37b4647c18f11547e998b85067d641579e2acbf82123f39e410497d0131e9747cd0aacd2bef1390ac94e0d8cef4cf254eb42b89b35e5b2f258bc3982811bce8f053844fe549de4b4a29c1934742d6534f211268503ae79051ce7e233ef863d8eec6f8bfd6ebfd92f668e697d87fc42c9110d5369943883f371afce164b45b0c0c266d87b5931a4746e069012bd128c32fab42cf540bb93e8507156246a59ee1b12cf91f4fe0d0fa927ae9a36466354304ad317724c85d69e25b6db7e06bd09772956913584721909039eaced79e67d5d600d4105c53f8651bcd82318575d220b143044c90b061a06eb178a021962545d37b918967ce6beaad684df9548107cdff0d7afed2994c8085e069512af0e2225f02bfb04009794a0b465b6af135064ebc1699e07b54a234c0b13888197a73c2a4bd663ec2d456a6d9857c432f862392c1c2a35f39f4c58e7a7a9096e64997554fea70a5e432524ec2cc2f50570871ffde35c580bfc9772c08a3f3b8615b06cab95cfa8d39e14a52a0ee1266ac5472957aa5e6877b60532553b8a0c5e94b66ad7fa8f98493a2891af96bdc86141a8490762f5c14e5940725941cba79b7e2e490b3d53e2ffa8ba9a25b830da10ba1e2e00137416fa5c6693e5319dce0dde17945723596495661616ef3e5f5427427dc19ba84f28a80521cfbfaf58d1380dbf4af7b2077d67dbbc59426b6f13e41c63d9af8b9236daccd566134cf416d13cc00a29da0a648fa07e71e124a2b023cdd14fed87be67f4445193fdfba97094b6018c72daec606337e23254d56b133aa559ad44cfbb222e551df47763b4842ae36452c4e9478c30f24325baf16598925bd5d8b08bcd7874de2d2d9c82f053cf29cd04109ee3845053bea962207a174e471734c40d148edba5492eea3c22e1d1402a0d267d7c4e24ceff0c73405afa7ed6649a2f288d519fafbc15067dea8e3c0150ea4a9c183a29e9ee61f502c5249bbc28f758624b18dd08f8c37c3f77bdf0d2bb9fb528d172f140af6a1f638fcdb3c7723679badf2e0ce35f51fd5aaf030c6f44ae31862ada8f3f492e6c854add8f1b50d8886984aa68182cfe9abbc0e6ef1c002c1289f3b886a05544b6fbe52b81304330b72ff5ec2b0928309b30ebc9157e41394c06d74627edf1c90f65fdd566f4b88375fd8479fef40a685b4f755f5e677dc72c974ed422eef1a92dd5cf83834192657337fea23b152af1225fd74bd1e21c6e77e010f00412ffeb8f5fd31366d8245872de92ac188586e21878380891b2aac929623856cb2438a882d46c4fc3c1b7a6012f34696127fa4236c794ee48c940131558292fe5e7cded196f571f68e58ecf377c97bb1603b2f4b0b529027e868f311f5ebb1f1cb549087f09a73cce10b392c328f19eb918539fbabb58f73a7262266e227d213801c63609ab33f079ac870c2c7bf327d777f0122bd8f8863e902ec9891ad0bfe5a78dfdbbd1f4ceeaf33b1d8ffdd9c67d320c0f33d35e577640de3b377f6518983607eff1bdbb696d227df39c5491f4b68e461e8ef335c938ad4f0372d3fabb7898284942477aa5d45beec09e498915324369d6cc334a741a8046a0a114c93dd2918f66cd07a45928b6d6de2cb1b08e497096b32ee6cf84e91b67c8a9593fe7cbf3cd434742b9fda629423ec438f755945561024e4c07f3b91f4085d110173c24be266a0abd06500acec0a7143c9a793590b8c9da738c1faccf52a0b2ea5d58f2aafc4eff521586d7ee11bc83efb9093048caed6ca3af638bb40958e23c38fe472dda9ec0ec0626893a79ae91b6f0d68a143e7b2f18f75eb0d9b203d2ce34cfdcd9704a279507e7209268bfa52e3d0fd04ed5c24ec46f09ec0fd5e38d3ae1ff5f4aeafd8fb8dd98f05f6542805f5549fd2a0c649109d8fe3161661ad4a48245ee1f6290f64129d9e06ca0b03e11a4d6dfaf1dbef88a42732477bd25ff9185eec0a7e86c0c77418e9213ed1e742135ef1a98229315c30393765b1c82a598f864e54854d4725caa0bd71ef607517299623c0ff9c15bdf3b1019969e2851a1440ec8950e6c63b903c18f34ef41a19739d47d02fa470b94210ed7ce1f888c8df9fe289ecbfed137e41270fd144cc0de18936fb6c7690f4e2e6349ada5cdd1f5e57ed21e0a0ff2b634c6fd3911c3fb1b8ab47f3d16526658678b635c6c1c3b51f58c62b3f3b2397b5c4144f4feb98c80d7cff1a5905e9b0e04dfff9cd26941fdd3b5946bcfaa7a8c5437e29ad223a29cba5d493eb14151b8e0eb9c0533c5ae80b30027d2c7c81435dd5d6790c66d15e88a07e6109eca447396078a50264d65d884076efa7a78576dd36e3df66bcf81e6848a14e293770eaeeb36f4b9f124a982d8b62392c4d0e45f11c728cba594131a4f9223554effe44dfacb37b4822f7623fd1eb73377b6b2237713ad199c750f1db9f2204ac9c1db36e9d144ee708c19abd566395640ffcab22d5d0deb971c8f3b217f4b1002735b589e4dc59891ba81fcfbdd43370b46f50b12d2e1d4bc5ddb2af131ff5d784dcb7b9d2c7ffdb377aa77b78c2204ec0d769920729420ac736e3e2f945affa069954f3268aa5137224e1958d9604267be7a93849a9c6aaa285e9eb2b05a2e9e63c059753c58d30906d3b32315656e3932685190a51a75fc9cb9c7b44a5139cba8a51ce51df3f941c19a60e9dd5b24a54e1d024aaf5ecfa0d4fdda6577bd52df8c86a56cf9768091056a1448ea65e04b75114173be6b005ac9ef79e22ddadd224b6b7e96137f4d1c14e87e4124ea66f42cdfcf79c848bc87373907a49f56efb9072b34677f62fdb39740b120d55413c8a88cb5e91706ca0f4b0dec68074cb50291fc952237d6a8bd1fa9061b272f036606ff3c02c1464f42923829bb58844a945d9569de94c928a1d2fae5f91bcccbb7a71ab476072fc3c94f7b3eb83a28d89f53cdd9d29c2c30f4e80238ce6833599f14328142c047fd7ef95dd6a27ea6fbaca051379df160c94cff6ca203a0d530152d70c7ea4bc017140ed311\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["reviews"],"tags":["C"]},{"title":"JQuery对列表的增删改以及遍历","url":"/2021/07/16/JQuery%E5%AF%B9%E5%88%97%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E4%BB%A5%E5%8F%8A%E9%81%8D%E5%8E%86/","content":"问题描述使用JQuery对html中的ul进行li的增删改以及遍历查看\n代码html部分&lt;div&gt;        &lt;ul&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;button id=&quot;addItem&quot;&gt;添加元素&lt;/button&gt;    &lt;button id=&quot;deleteItem&quot;&gt;删除元素&lt;/button&gt;    &lt;button id=&quot;traversal&quot;&gt;显示列表&lt;/button&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;输入修改第几项&quot; id=&quot;index&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;修改的值&quot; id=&quot;value&quot;&gt;    &lt;button id=&quot;modifyItem&quot;&gt;改变列表项&lt;/button&gt;    &lt;br&gt;遍历结果：    &lt;p id=&quot;res&quot;&gt;&lt;/p&gt;\n\nscript部分list增加元素：$(&quot;#addItem&quot;).click(function() &#123;                let newItem = &quot;&quot;;                newItem = &quot;&lt;li&gt;&quot; + i + &quot;&lt;/li&gt;&quot;;                i += 1;                $(&quot;ul&quot;).append(newItem);            &#125;);\n\nlist删除元素：$(&quot;#deleteItem&quot;).click(function() &#123;                let tmp = $(&quot;ul&quot;).html().toString();                let location = tmp.lastIndexOf(&#x27;&lt;li&gt;&#x27;);                $(&#x27;ul&#x27;).html(tmp.slice(0, location));                i -= 1;            &#125;);\n\nlist修改特定项的元素：$(&quot;#modifyItem&quot;).click(function() &#123;                let index = $(&quot;#index&quot;).val();                let value = $(&quot;#value&quot;).val();                $(&quot;li&quot;).eq(index - 1).text(value);            &#125;);\n\nlist遍历：$(&quot;#traversal&quot;).click(function() &#123;                let res = [];                for (j = 0; j &lt; $(&quot;li&quot;).length; j++) &#123;                    res.push($(&quot;li&quot;).eq(j).text())                &#125;                $(&quot;#res&quot;).text(res);            &#125;);\n\n全部代码&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        $(document).ready(function() &#123;            let n = 6,                i = 1;            let text = &quot;&quot;;            for (i; i &lt; n; i++) &#123;                text += &quot;&lt;li&gt;&quot; + i + &quot;&lt;/li&gt;&quot;;            &#125;            $(&quot;ul&quot;).append(text);            $(&quot;#addItem&quot;).click(function() &#123;                let newItem = &quot;&quot;;                newItem = &quot;&lt;li&gt;&quot; + i + &quot;&lt;/li&gt;&quot;;                i += 1;                $(&quot;ul&quot;).append(newItem);            &#125;);            $(&quot;#deleteItem&quot;).click(function() &#123;                let tmp = $(&quot;ul&quot;).html().toString();                let location = tmp.lastIndexOf(&#x27;&lt;li&gt;&#x27;);                $(&#x27;ul&#x27;).html(tmp.slice(0, location));                i -= 1;            &#125;);            $(&quot;#traversal&quot;).click(function() &#123;                let res = [];                for (j = 0; j &lt; $(&quot;li&quot;).length; j++) &#123;                    res.push($(&quot;li&quot;).eq(j).text())                &#125;                $(&quot;#res&quot;).text(res);            &#125;);            $(&quot;#modifyItem&quot;).click(function() &#123;                let index = $(&quot;#index&quot;).val();                let value = $(&quot;#value&quot;).val();                $(&quot;li&quot;).eq(index - 1).text(value);            &#125;)        &#125;)    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;July 16th&lt;/p&gt;    &lt;div&gt;        &lt;ul&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;button id=&quot;addItem&quot;&gt;添加元素&lt;/button&gt;    &lt;button id=&quot;deleteItem&quot;&gt;删除元素&lt;/button&gt;    &lt;button id=&quot;traversal&quot;&gt;显示列表&lt;/button&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;输入修改第几项&quot; id=&quot;index&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;修改的值&quot; id=&quot;value&quot;&gt;    &lt;button id=&quot;modifyItem&quot;&gt;改变列表项&lt;/button&gt;    &lt;br&gt;遍历结果：    &lt;p id=&quot;res&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n","categories":["HTML"],"tags":["JQuery"]},{"title":"Java入门(一)","url":"/2022/03/26/Java%E5%85%A5%E9%97%A8-%E4%B8%80/","content":"JDK、JRE、JVMJDK：Java Development Kit，包含了JRE和JVM，扩充了开发工具\nJRE：Java Runtime Environment，运行环境\nJVM：Java Virtual Machine，可以用软件或硬件来实现，模拟了一个小巧的CPU处理JAVA。跨平台的核心，屏蔽底层系统的差别。\nHello World\n新建一个Java文件，文件的后缀名为.java，如Helloworld.java\n\n输入代码\npublic class Helloworld&#123;\tpublic static void main(String[] args)&#123; // 程序通过mai方法执行\t\tSystem.out.print(&quot;Hello,world!&quot;);\t&#125;&#125;\n\n在控制台输入命令进行编译\njavac Helloworld.java #编译成功控制台不输出消息，会在文件夹里生成一个Helloworld类\n\n\n\n在控制台输入命令运行类\njava Helloworld #输出结果会在控制台中显示\n\n\n\n\n\n注意：\n\nJava是大小写敏感的。\n\n所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。\n\n类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass\n\n源文件名和代码里的类名必须保持一致，且首字母大写\n\n主方法入口：所有的 Java 程序由 public static void main(String[] args) 方法开始执行。\n\n\nJava基础语法对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n类：类是一个模板，它描述一类对象的行为和状态。\n方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。\n实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。\nJava程序运行机制Java既有编译型(Complie)的特点，又有解释型(Interpret)的特点。.java的源文件经过Java编译器成为.class文件。.class文件放入虚拟机的类装载器中，类加载进JVM。字节码校验器会检查代码是否出错，最后解释器会将代码解释给操作系统平台。先编译，再解释。\n注释注释并不会被执行\n\n单行注释：\n// 这是单行注释\n\n多行注释：\n/*这是多行注释*/\n\nJavaDoc文档注释：\n/*** @Description Helloworld* @Author Rinta*/\n\n标识符Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。\nJava中的关键字：\n\n\n注意：\n\n所有的标识符应该以字母（A-Z或a-z），美元符（$），或下划线（_）开始\n首字母之后可以是字母（A-Z或a-z），美元符（$），下划线（_）或数字的随意组合\n不能使用关键字作为变量名或方法名\n标识符大小写敏感\n可以使用中文命名，不建议\n\nJava修饰符Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：\n\n访问控制修饰符 : default, public , protected, private\n非访问控制修饰符 : final, abstract, static, synchronized\n\n数据类型Java是强类型语言，要求变量的使用严格符合规定，所有变量必须先定义后才能使用，\n基本类型（primitive type）\n数值类型\n\n整数类型\n\nbyte 一个字节范围：-128 - 127\n\nshort 两个字节范围：-32768 - 32767\n\nint 四个字节范围：-2147483648 - 2147483647\n\nlong 八个字节范围：-9223372036854775808 - 9223372036854775807 \n在数字后面加L，如：long num1 &#x3D; 12344321L;\n\n\n\n浮点类型\n\nfloat 占4个字节\n在数字后面要加F，如：float num2 &#x3D; 22.3f;\n\ndouble 占8个字节\n\n\n\n字符类型 \n\nchar 占2个字节\n\n\n\n\nboolean类型：占1位，值只有true和false\n\n\n类型转换转换的从低到高为：byte,short,char—&gt; int —&gt;long—&gt;float—&gt;double，低（范围）向高转换是自动转换，高到低要强制转换\n注意：\n\n不能对布尔值进行转换\n不能把对象类型转换成不相干的类型\n高到低要用到强制转换\n转换的时候可能存在内存溢出，或者精度问题\n\n引用类型（reference type）\n类\n接口\n数组\n\n拓展\n整数拓展\n\n二进制：0b，八进制：0，十六进制：0x\n\n\n浮点数拓展\n\neg. 银行业务怎么表示？BigDecimal 数学工具类\n\n\n\n最好完全避免用浮点数进行比较\n\n字符类拓展\n\n所有的字符本质上是数字，Unicode编码，从U0000到UFFFF\n\\u 转义字符表示\n\n\n布尔值拓展\n\nboolean flag = true;\nif(falg)&#123;&#125;\n# 变量每个变量必须声明其类型，Java变量是程序中最基本的存储单元，要素包括变量名，变量类型和作用域。Java 中主要有如下几种类型的变量- 局部变量- 类变量（静态变量）- 成员变量（非静态变量）**注意：**- 每个变量都有类型，可以是基本类型，也可以是引用类型- 变量名必须是合法的标识符- 变量声明是一条完整的语句，分号结束## 变量作用域```javapublic class Variable(\tstatic int allClicks = 0;   // 类变量\tString str = &quot;hello world&quot;;  //  实例变量    public void method()&#123;        int i = 0;  //  局部变量    &#125;)\n\n\n\n\n类变量\n关键词：static，从属于类\n\n类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n静态变量除了被声明为常量外很少使用，静态变量是指声明为 public&#x2F;private，final 和 static 类型的变量。静态变量初始化后不可改变。\n静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。\n静态变量在第一次被访问时创建，在程序结束时销毁。\n与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n静态变量可以通过：ClassName.VariableName的方式访问。\n类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。\n\n\n实例变量\n独立于方法之外的变量，类的里面，从属于对象 \n\n实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n\n当一个对象被实例化之后，每个实例变量的值就跟着确定；\n\n实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n\n实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n\n实例变量可以声明在使用前或者使用后；\n\n访问修饰符可以修饰实例变量；\n\n实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n\n实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n\n实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n\n\n局部变量\n类的方法中的变量，必须声明和初始化值。\n\n局部变量声明在方法、构造方法或者语句块中；\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；\n访问修饰符不能用于局部变量；\n局部变量只在声明它的方法、构造方法或者语句块中可见；\n局部变量是在栈上分配的。\n局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\n\n\n\nJava数组数组是储存在堆上的对象，可以保存多个同类型变量。\nJava枚举Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。\n常量初始化后不能再改变值\n// final 常量名=值;final double PI=3.14\n\n\n\nJava运算符关系运算符\n\n\n操作符\n描述\n例子（A&#x3D;10,B&#x3D;20）\n\n\n\n+\n加法 - 相加运算符两侧的值\nA + B 等于 30\n\n\n-\n减法 - 左操作数减去右操作数\nA – B 等于 -10\n\n\n*\n乘法 - 相乘操作符两侧的值\nA * B等于200\n\n\n&#x2F;\n除法 - 左操作数除以右操作数\nB &#x2F; A等于2\n\n\n％\n取余 - 左操作数除以右操作数的余数\nB%A等于0\n\n\n++\n自增: 操作数的值增加1\nB++ 或 ++B 等于 21\n\n\n–\n自减: 操作数的值减少1\nB– 或 –B 等于 19\n\n\n\n前缀自增自减法（++a，–a）：先进行自增或自减运算，再进行表达式运算。\n后缀自增自减法（a++，a–）：先进性表达式运算，再进行自增或自减运算。\n\n关系运算符\n\n\n运算符\n描述\n例子（A&#x3D;10,B&#x3D;20）\n\n\n\n&#x3D;&#x3D;\n检查如果两个操作数的值是否相等，如果相等则条件为真。\n（A &#x3D;&#x3D; B）为假。\n\n\n!&#x3D;\n检查如果两个操作数的值是否相等，如果值不相等则条件为真。\n(A !&#x3D; B) 为真。\n\n\n&gt;\n检查左操作数的值是否大于右操作数的值，如果是那么条件为真。\n（A&gt; B）为假。\n\n\n&lt;\n检查左操作数的值是否小于右操作数的值，如果是那么条件为真。\n（A &lt;B）为真。\n\n\n&gt;&#x3D;\n检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。\n（A&gt; &#x3D; B）为假。\n\n\n&lt;&#x3D;\n检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。\n（A &lt;&#x3D; B）为真。\n\n\n位运算符位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。\n\nA = 0011 1100B = 0000 1101-----------------A&amp;B = 0000 1100A | B = 0011 1101A ^ B = 0011 0001~A= 1100 0011\n\n\n\n\n操作符\n描述\n例子（A&#x3D;60，B&#x3D;13）\n\n\n\n＆\n如果相对应位都是1，则结果为1，否则为0\n（A＆B），得到12，即0000 1100\n\n\n|\n如果相对应位都是 0，则结果为 0，否则为 1\n（A | B）得到61，即 0011 1101\n\n\n^\n如果相对应位值相同，则结果为0，否则为1\n（A ^ B）得到49，即 0011 0001\n\n\n〜\n按位取反运算符翻转操作数的每一位，即0变成1，1变成0。\n（〜A）得到-61，即1100 0011\n\n\n&lt;&lt;\n按位左移运算符。左操作数按位左移右操作数指定的位数。\nA &lt;&lt; 2得到240，即 1111 0000\n\n\n&gt;&gt;\n按位右移运算符。左操作数按位右移右操作数指定的位数。\nA &gt;&gt; 2得到15即 1111\n\n\n&gt;&gt;&gt;\n按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。\nA&gt;&gt;&gt;2得到15即0000 1111\n\n\n当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。\n赋值运算符\n\n\n操作符\n描述\n例子\n\n\n\n&#x3D;\n简单的赋值运算符，将右操作数的值赋给左侧操作数\nC &#x3D; A + B将把A + B得到的值赋给C\n\n\n+ &#x3D;\n加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数\nC + &#x3D; A等价于C &#x3D; C + A\n\n\n- &#x3D;\n减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数\nC - &#x3D; A等价于C &#x3D; C - A\n\n\n* &#x3D;\n乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数\nC * &#x3D; A等价于C &#x3D; C * A\n\n\n&#x2F; &#x3D;\n除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数\nC &#x2F; &#x3D; A，C 与 A 同类型时等价于 C &#x3D; C &#x2F; A\n\n\n（％）&#x3D;\n取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数\nC％&#x3D; A等价于C &#x3D; C％A\n\n\n&lt;&lt; &#x3D;\n左移位赋值运算符\nC &lt;&lt; &#x3D; 2等价于C &#x3D; C &lt;&lt; 2\n\n\n&gt;&gt; &#x3D;\n右移位赋值运算符\nC &gt;&gt; &#x3D; 2等价于C &#x3D; C &gt;&gt; 2\n\n\n＆&#x3D;\n按位与赋值运算符\nC＆&#x3D; 2等价于C &#x3D; C＆2\n\n\n^ &#x3D;\n按位异或赋值操作符\nC ^ &#x3D; 2等价于C &#x3D; C ^ 2\n\n\n| &#x3D;\n按位或赋值操作符\nC | &#x3D; 2等价于C &#x3D; C | 2\n\n\n条件运算符（?:）条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。\nvariable x = (expression) ? value if true : value if false\n\nintanceof运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\n( Object reference variable ) instanceof  (class/interface type)\n\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真。\nString name = &quot;James&quot;;boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n\n如果被比较的对象兼容于右侧类型,该运算符仍然返回true。\nclass Vehicle &#123;&#125; public class Car extends Vehicle &#123;   public static void main(String[] args)&#123;      Vehicle a = new Car();      boolean result =  a instanceof Car;      System.out.println(result);   &#125;&#125;\n\nJava运算符优先级\n\n\n类别\n操作符\n关联性\n\n\n\n后缀\n() [] . (点操作符)\n左到右\n\n\n一元\nexpr++ expr–\n从左到右\n\n\n一元\n++expr –expr + - ～ ！\n从右到左\n\n\n乘性\n* &#x2F;％\n左到右\n\n\n加性\n+ -\n左到右\n\n\n移位\n&gt;&gt; &gt;&gt;&gt;  &lt;&lt;\n左到右\n\n\n关系\n&gt; &gt;&#x3D; &lt; &lt;&#x3D;\n左到右\n\n\n相等\n&#x3D;&#x3D; !&#x3D;\n左到右\n\n\n按位与\n＆\n左到右\n\n\n按位异或\n^\n左到右\n\n\n按位或\n|\n左到右\n\n\n逻辑与\n&amp;&amp;\n左到右\n\n\n逻辑或\n| |\n左到右\n\n\n条件\n？：\n从右到左\n\n\n赋值\n&#x3D; + &#x3D; - &#x3D; * &#x3D; &#x2F; &#x3D;％&#x3D; &gt;&gt; &#x3D; &lt;&lt; &#x3D;＆&#x3D; ^ &#x3D; | &#x3D;\n从右到左\n\n\n逗号\n，\n左到右\n\n\n包机制\n为了更好地组织类，Java提供了包机制，用于区别类的命名空间。\n\n语法格式：\npackage pkg1[. pkg2[. pkg3...]];\n\n一般利用公司域名倒置作为包名\n\n为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包。使用import语句可完成此功能。\nimport package1[.package2...].(classname|*)\n\n*是通配符，会导入这个包下所有的类\n\n\nJavaDoc\njavadoc命令是用来生成自己API文档的，可以将一种自定的注释信息生成帮助文档\n\n参数信息\n\n@author    作者名\n@version    版本号\n@since    指明需要最早使用的jdk版本\n@param    参数名\n@return    返回值情况\n@throws    异常抛出情况\n\n\n可以加在类或方法上面\n\n可以在命令行输入代码生成doc文件\njavadoc -encoding UTF-8 -charset UTF-8 Doc.java\n\n","categories":["Java Learning"],"tags":["Java"]},{"title":"Java入门(二)","url":"/2022/04/02/Java%E5%85%A5%E9%97%A8-%E4%BA%8C/","content":"继承在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。\n利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（sub class）。\n接口在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。\n接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。\nJava对象和类\n对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n类：类是一个模板，它描述一类对象的行为和状态。、\n局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。\n\n\n\n创建对象对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：\n\n声明：声明一个对象，包括对象名称和对象类型。\n实例化：使用关键字 new 来创建一个对象。\n初始化：使用 new 创建对象时，会调用构造方法初始化对象\n\npublic class Puppy&#123;   public Puppy(String name)&#123;      //这个构造器仅有一个参数：name      System.out.println(&quot;小狗的名字是 : &quot; + name );    &#125;   public static void main(String[] args)&#123;      // 下面的语句将创建一个Puppy对象      Puppy myPuppy = new Puppy( &quot;tommy&quot; );   &#125;&#125;\n\n访问实例变量和方法/* 实例化对象 */Object referenceVariable = new Constructor();/* 访问类中的变量 */referenceVariable.variableName;/* 访问类中的方法 */referenceVariable.methodName();\n\n源文件声明规则\n一个源文件中只能有一个 public 类\n一个源文件可以有多个非 public 类\n源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。\n如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。\n如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。\nimport 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\n\n","categories":["Java Learning"],"tags":["Java"]},{"title":"Monster Hunter World","url":"/2022/03/25/Monster-Hunter-World/","content":"秦雁回喝喝\n","tags":["Monster Hunter World"]},{"title":"Markdown语法","url":"/2022/03/25/Markdown%E8%AF%AD%E6%B3%95/","content":"Markdown学习标题标题用 #+标题（中间要有空格）回车生成，有六级标题，一个#是一级标题，六#是六级标题。\n字体在文段内容，两边各加**就可以变成粗体，两边各加*就可以变成斜体，加***就会加粗斜体。在两边各加~~就会有中间划线的效果。\n引用\n引用效果 在开头加 &gt; 空格，表示语句是被引用的。\n\n分割线\n输入三个-再回车\n\n输入三个*再回车\n图片输入![图片的名字](图片的路径) \n  \n超链接wrinta\n[链接的名字](网址)\n列表有序列表输入数字英语句号空格，回车会出下一个。\n\nR\nint\na\n\n无序列表输入-再空格\n\na\nint\nR\n\n表格Typora可以通过鼠标右键的点击直接增加表格。\n通过|符号可以实现表格的生成，打出表头，用|分隔每一栏(开始和结尾也要有|)\n\n\n\n名字\n性别\n生日\n\n\n\n小狗\n男\n2111&#x2F;11&#x2F;1\n\n\n代码插入`&#96;&#96;回车表示要插入代码，右下角可以选择语言\nprintf(&quot;hello world!&quot;);\n\n","tags":["Markdown"]},{"title":"Overwatch","url":"/2021/07/16/overwatch/","content":"Hello Overwatch!\n","tags":["overwatch"]},{"title":"小白搭建博客教程","url":"/2021/07/17/%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","content":"安装准备安装博客前，电脑需要安装node.js，git。并且要在GitHub上建立一个仓库\n\n如图所示，yourname是你的名字，要和你的GitHub名字完全一样，比如我是wrinta，我的Repository name那里填的就是wrinta.github.io，下面的Add a README file也要记得勾选，然后就可以创建仓库了\n\n进入刚刚我们新建的仓库，点击Settings，找到Pages，点击Choose a theme随便选择一个主题，过一会他会提示你可以通过域名访问啦\n\n点击那个链接，出现的页面效果就是你刚刚随意选择的主题样式。觉得丑没关系，我们后面可以配置自己喜欢的主题。\n开始安装安装Hexo在自己想要存放自己博客相关文件的目录下新建一个文件夹，如 D:\\study\\blog，进入目录，右键Git Bash Here，打开git的控制台窗口（以后我们的操作都在git控制台中进行）\n在该目录下输入 npm i hexo-cli -g 安装Hexo，会有几个报错，不用管它，安装完后输入 hexo -v 验证Hexo是否成功安装\n输入 hexo init 初始化文件，有一些npm的插件可以在后面需要时按需安装。\n输入 hexo g 生成静态网页，输入 hexo s 打开本地的服务器，浏览器打开http://localhost:4000     就可以看到博客啦。后面配置文件和主题时，可以通过同样的方式先在本地预览哟。预览完成后可以通过ctrl +c关闭本地的服务器。\n连接GitHub和本地打开 git bash ，输入下面的命令：\ngit config --global user.name &quot;username&quot;git config --global user.email &quot;user email&quot;\n\n生成SSH key，中间一直回车就好了，记得出现y&#x2F;n时输入y再回车：\nssh-keygen -t rsa -C &quot;user email&quot;\n\n查看SSH key，复制内容：\ncat ~/.ssh/id_rsa.pub\n\n打开GitHub，在头像下面点settings，再点击SSH and GPG keys，新建一个SSH，取一个自己喜欢的名字，将刚刚复制的内容粘进去，然后保存。\n输入：\nssh -T git@github.com\n\n如果如下图所示，出现了你的用户名，那就成功啦！\n\n还差一步，打开博客根目录下的_config.yml文件，这个是博客的配置文件，修改deploy\ndeploy:  type: &#x27;git&#x27;  repository: git@github.com:wrinta/wrinta.github.io.git  #这里把名字改成你的名字  branch: main #分支改成自己的分支名，比如master\n\n发布文章首先在博客的根目录下面打开git bash，安装扩展 npm i hexo-deployer-git\n打开博客根目录的配置文件_config.yml，将 post_asset_folder改成true，如图所示：\n\n输入 hexo new post “article title”，新建一篇文章，在博客的根目录下，进入&#x2F;source&#x2F;_posts，可以看到刚刚新建的文件，其中.md文件是你写博客内容的地方，文件夹用来放你在同名.md文件里要用的图片。\n编写完后，输入 hexo g 生成静态文件，可以输入 hexo s 本地预览，然后输入 hexo d 。\n如果 hexo d 后报错 ERROR Deployer not found: git 输入：\nnpm install --save hexo-deployer-git\n\n","categories":["hexo"],"tags":["blog build"]},{"title":"Python","url":"/2024/03/11/Python/","content":"Python介绍\npython常用于回归测试。\npython+selenium web自动化（功能测试转换为代码）\npython+appium 移动端（手机端app）自动化\npython+ requests 接口\n\nPython 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。\nPython 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。\n\nPython 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。\nPython 是交互式语言： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。\nPython 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。\nPython 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。\n\nPython基础代码标识符\n第一个字符必须是字母表中字母或下划线 _ ,不能以数字开头。\n驼峰命名法：\n​\t大驼峰：每个单词首字母大写：MyName\n​\t小驼峰：第一个单词首字母小写，其他大写：myNam\n下划线连接法：每个单词之间用下划线连接my_name\n\n变量一般使用下划线法\n\n标识符的其他的部分由字母、数字和下划线组成。\n\n标识符对大小写敏感。\n\n\n在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。\npython保留字\n&gt;[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]\n\n多行语句Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 ** 来实现多行语句，例如：\ntotal = item_one + \\        item_two + \\        item_three\n\n在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 ****，例如：\ntotal = [&#x27;item_one&#x27;, &#x27;item_two&#x27;, &#x27;item_three&#x27;,        &#x27;item_four&#x27;, &#x27;item_five&#x27;]\n\n数字类型\nint (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。\nbool (布尔), 如 True。\nfloat (浮点数), 如 1.23、3E-2\ncomplex (复数), 如 1 + 2j、 1.1 + 2.2j\n\n输出print()# print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=&quot;&quot;x = &quot;a&quot;y = &quot;b&quot;# 换行输出print(x)print(y)print(&#x27;---------&#x27;)# 不换行输出print(x, end=&quot; &quot;)print(y, end=&quot; &quot;)print()\n\n\n输入inputa = input(&#x27;输入你心中想的内容：&#x27;)print(&quot;你输入的是&quot; + a)print(type(a))\n\n\n输入的内容类型是字符串类型\n类型转换a = input(&#x27;输入你的年龄：&#x27;)b = int(a)print(&quot;你的年龄是&quot;, b)print(&quot;一年后你的年龄是&quot;, int(a) + 1)print(type(a))print(type(b))\n\n\n\nint()可以将其他类型转换成int类型\n​\t可以将float类型转换成整型\n​\t可以将整数类型字符串转换为整型\n\nfloat()可以将其他类型转换成float类型\n\n可以将int类型转换成浮点型\n可以将数字类型字符串（整数、小数）转换为浮点型\n\n\nstr()可以将其他类型转换成字符串类型\n\n任何类型都可以使用str()将其转换成字符串，一般都是直接加引号\n\n\n\n格式化输出print(&quot;%s&quot;,%str) #格式化输出字符串,%s可以填充任意类型的数据print(&quot;%d&quot;,%a) #有符号的的十进制数print(&quot;%06d&quot;,%b) #表示输出的整数显示位数，不足位以0补全，超出位数则原样输出print(&quot;%f&quot;,%c) #浮点数print(&quot;.2f&quot;,%d) #保留2位小数输出（四舍五入），小数默认显示6位print(&quot;%%&quot;) #输出%\n\nname = &#x27;ana&#x27;age = 18height = 1.752print(&quot;her name is %s,her age is %d,her height is %.2fm&quot; % (name, age, height))\n\n\nnum = 90print(&#x27;percentage %d%%&#x27; % num)\n\n\nF-string（f字符串的格式化方法）1. 需要在字符串前面加上f&quot;&quot;或者F&quot;&quot;2. 占位符号统一变为&#123;&#125;3. 需要填充的变量写在&#123;&#125;\n\nstu_num = 1num = 90name = &#x27;ana&#x27;age = 19height = 1.821print(f&#x27;her name is &#123;name&#125;,age is &#123;age&#125;,height is &#123;height:.2f&#125;m,student number is &#123;stu_num:06d&#125;,percentage is &#123;num&#125;%&#x27;)\n\n\nimport与from…import在 python 用 import或者 from...import来导入相应的模块。\n\n将整个模块(somemodule)导入，格式为：import somemodule\n从某个模块中导入某个函数,格式为： from somemodule import somefunction\n从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc\n将某个模块中的全部函数导入，格式为： from somemodule import *\nimport somemodule as alias导入模块指定别名alias\n\npython中的三种波浪线和pep\n红色：表示代码的错误，代码没有写完也会出现\n\n灰色：不会影响代码的正常执行，pep8为代码的书写规范。可以在写完后使用ctrl+alt+L格式化\n\n\n\n\n绿色：在引号中，认为书写的内容不是英文单词时会出现\n\n\nPython基本数据类型Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\n在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。\nPython允许你同时为多个变量赋值。例如：\na = b = c =1a,b,c=1,2,&#x27;hello&#x27;\n\n标准数据类型Python3 中常见的数据类型有：\n\nNumber（数字）\nString（字符串）\nbool（布尔类型）\nList（列表）\nTuple（元组）\nSet（集合）\nDictionary（字典）\n\nPython3 的六个标准数据类型中：\n\n不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；\n可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。\n\n此外还有一些高级的数据类型，如: 字节数组类型(bytes)。\nnumber数字Python3 支持 int、float、bool、complex（复数）。\ntype()和isinstance()内置的 type() 函数可以用来查询变量所指的对象类型。\na,b,c,d=2,3.14,True,3+4jprint(type(a),type(b),type(c),type(d))\n\n\nprint(isinstance(a,int))\n\n\nisinstance 和 type 的区别在于：\n\ntype()不会认为子类是一种父类类型。\nisinstance()会认为子类是一种父类类型。\n\n注意：\n\n数值的除法包含两个运算符：**&#x2F;** 返回一个浮点数，**&#x2F;&#x2F;** 返回一个整数。\n在混合计算时，Python会把整型转换成为浮点数。\n\nString字符串\nPython 中单引号 ‘ 和双引号 “ 使用完全相同。\n使用三引号(‘’’ 或 “””)可以指定一个多行字符串。\n转义符\\。\n反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n 会显示，并不是换行。\n按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。\n字符串可以用 + 运算符连接在一起，用 ***** 运算符重复。\nPython 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。\nPython 中的字符串不能改变。\nPython 没有单独的字符类型，一个字符就是长度为 1 的字符串。\n字符串的截取的语法格式如下：**变量[头下标:尾下标:步长]**，尾下标对应的字符不会输出\n\nword = &#x27;字符串&#x27;sentence = &quot;这是一个句子。&quot;paragraph = &quot;&quot;&quot;这是一个段落，可以由多行组成&quot;&quot;&quot;\n\n\n\n字符串的截取字符串的截取的语法格式如下：\n变量[头下标:尾下标]\n索引值以 0 为开始值，-1 为从末尾的开始位置。\n\nstr = &#x27;abcdefghijk&#x27;print(str)print(&quot;输出字符串第一个字符：&quot; + str[0])print(&quot;输出字符串最后一个字符：&quot; + str[-1])print(&quot;输出字符串第一个到第3个字符：&quot; + str[0:3])print(&quot;输出字符串第一个到倒数第二个个字符：&quot; + str[0:-1])print(&quot;输出字符串第一个到第3个字符：&quot; + str[:3])print(&quot;从字符串倒数第三个字符开始输出：&quot; + str[-3:])print(&quot;字符串的每个字符间隔1个输出（步长为2）：&quot; + str[::2])print(&quot;字符串输出2次：&quot; + str * 2)print(&quot;字符串拼接输出：&quot; + &#x27;你好&#x27; + str)print(&quot;反转字符串：&quot; + str[::-1])print(&#x27;hello\\npython&#x27;)print(r&#x27;hello\\npython&#x27;)\n\n\n相关函数len()len()可以用来获取字符串长度\n\n查找方法find()字符串.find(sub_str,start,end)# 在字符串中查找是否存在sub_str这样的字符串# start默认为0# end默认是len()返回结果：1. 找到了，返回第一次出现的下标（sub_str第一个字符在字符串中的下标）2. 没有找到，返回-1\n\nstr = &#x27;abcdefghijk&#x27;print(str.find(&#x27;abc&#x27;))\n\n\nstr = &#x27;ana and luke and lei&#x27;num = str.find(&#x27;and&#x27;)# 查找第2个and出现的位置print(str.find(&#x27;and&#x27;, num + 1))\n\n\n# 过7游戏for i in range(1, 100):    if i % 7 == 0 or str(i).find(&#x27;7&#x27;) != -1:        print(&quot;过&quot;)    else:        print(i)\n\n\n字符串替换replace()字符串.replace(old_str,new_str,count)# 将old_str替换成new_str# count：替换的次数，默认全部替换# 返回替换之后的完整字符串，原来的字符串没有发生改变\n\n# 将str1中所有的g改为Gstr1 = &#x27;good good study&#x27;str2 = str1.replace(&#x27;g&#x27;, &#x27;G&#x27;)print(&quot;str1=&quot;, str1)print(&quot;str2=&quot;, str2)\n\n\n# 将str1中第一个good改成GOODstr1 = &#x27;good good study&#x27;str2 = str1.replace(&#x27;good&#x27;, &#x27;GOOD&#x27;,1)print(&quot;str1=&quot;, str1)print(&quot;str2=&quot;, str2)\n\n\n# 将str1中第二个good改成GOODstr1 = &#x27;good good study&#x27;str2 = str1.replace(&#x27;good&#x27;, &#x27;GOOD&#x27;, )str3 = str2.replace(&#x27;GOOD&#x27;, &#x27;good&#x27;, 1)print(&quot;str2=&quot;, str2)print(&quot;str3=&quot;, str3)\n\n\n字符串的拆分spilt()字符串.split.(sep,maxsplit)# 将字符串按照sep进行拆分，默认为空白字符（空格，换行\\n，tab键\\t）# max_spilt:分隔次数，默认全部分隔# 返回：将一个字符串拆分成多个存在列表中# 注意：sep不写，想要指定分割次数，写法如：字符串.spilt(maxspilt=n)\n\nstr = &quot;Hello,my name is Elora&quot;list1 = str.split()print(list1)print(str.split(maxsplit=1))\n\n\n字符串的连接join()字符串1.join(列表) # 括号中的内容主要是列表，可以是其他容器# 将字符串插入到列表中每相邻的两个数据之间，组成一个新的字符串# 注意：列表中的数据必须都是字符串类型，否则会报错\n\nlist1 = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;you&#x27;]str1 = &#x27; &#x27;.join(list1)print(str1)str2 = &#x27; and &#x27;.join(list1)print(str2)\n\n\n字符串格式化字符串.format()1. 在需要使用变量的地方使用&#123;&#125;占位2. &#x27;&#123;&#125;,&#123;&#125;...&#x27;.format(变量,变量)...\n\nstu_num = 1num = 90name = &#x27;ana&#x27;age = 19height = 1.821print(&#x27;her name is &#123;&#125;,age is &#123;&#125;,height is &#123;:.2f&#125;m,student number is &#123;:06d&#125;,percentage is &#123;&#125;%&#x27;.format(name, age, height, stu_num, num))\n\n\nbool布尔类型在 Python 中，True 和 False 都是关键字，表示布尔值。\n布尔类型特点：\n\n布尔类型只有两个值：True 和 False。\n布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。\n布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值。\n布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0。\n\n注意: 在 Python 中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 0、空字符串、空列表、空元组等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。\nlist列表\n列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（嵌套）。\n列表是写在方括号 [] 之间、用逗号分隔开的元素列表。\n和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。截取的语法格式：变量[头下标:尾下标]\n\n索引值以 0 为开始值，**-1** 为从末尾的开始位置。\n\nlist1 = list()# 定义一个空的列表# list(容器)将其他容器转换成列表\n\n\n列表的切片list1 = [&#x27;abcd&#x27;, 78910, 2.233333, &#x27;hello&#x27;, 351]tinylist1 = [123, &#x27;abcdefg&#x27;]print(list1)print(tinylist1)print(&quot;打印整个列表:&quot;, end=&#x27; &#x27;)print(list1)print(&quot;打印列表的第一个元素：&quot;, end=&#x27; &#x27;)print(list1[0])print(&quot;打印列表第二到第三个元素（包含第三个元素）:&quot;, end=&#x27; &#x27;)print(list1[1:3])print(&quot;打印列表第二到第三个元素（不包含第三个元素）:&quot;, end=&#x27; &#x27;)print(list1[1:2])print(&quot;打印列表第二个元素:&quot;, end=&#x27; &#x27;)print(list1[1])print(&quot;打印列表第三个元素到末尾:&quot;, end=&#x27; &#x27;)print(list1[2:])print(&quot;打印tiny列表两次&quot;, end=&#x27; &#x27;)print(tinylist1 * 2)print(&quot;打印两个列表&quot;, end=&#x27; &#x27;)print(tinylist1 + list1)print(&quot;打印两个列表合并后第二个到第五个元素&quot;, end=&#x27; &#x27;)print((tinylist1 + list1)[1:6])print(&quot;逆转list&quot;, end=&#x27; &#x27;)print(list1[::-1])\n\n\n列表查询相关操作数据下标index()列表.index(数据,start,end)# 使用和find方法一样# 区别：index()方法，找到返回第一次出现的下标，没有找到直接报错\n\nmylist = [1, 3, 5, 7, 2, 3]num = mylist.index(3)print(&quot;出现3的下标是：&quot;, num)print(&quot;出现4的下标是：&quot;, mylist.index(4))\n\n\n判断是否存在in()数据 in 容器# 存在返回True，不存在返回False\n\n统计出现次数count()列表.count(数据)# 返回数据出现的次数\n\n# 直接更改list元素值list1 = [&#x27;abcd&#x27;, 78910, 2.233333, &#x27;hello&#x27;, 351]list1 = [12321]  # list1=[12321]list1[1:3] = [&#x27;a&#x27;, &#x27;b&#x27;]list1[3:4] = [444]print(list1)\n\n\nlist1 = [&#x27;abcd&#x27;, 78910, 2.233333, &#x27;hello&#x27;, 351]list1[0] = 12321list1[1:3] = [&#x27;a&#x27;, &#x27;b&#x27;]list1[3:4] = [444]print(list1)\n\n\n列表添加数据尾部添加（最常用）列表.append(数据)# 返回：返回的None（关键字，空），一般就不再使用变量保存返回内容# 查看打印列表，表示返回值\n\n指定下标位置添加列表.insert(下标,数据)# 在指定的下标位置添加数据，如果指定的下标位置有数据，原数据后移# 返回：返回的None（关键字，空），一般就不再使用变量保存返回内容# 查看打印列表，表示返回值\n\nmylist = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;and&#x27;]mylist.append(&#x27;you&#x27;)print(mylist)mylist.insert(1, &#x27;Lily&#x27;)print(mylist)mylist.append([&#x27;him&#x27;, &#x27;and&#x27;])print(mylist)mylist.insert(1, [&#x27;Manny&#x27;, &#x27;Sue&#x27;])print(mylist)\n\n\n\n\n列表合并extend()列表1.extend(列表2) # 将列表2中的所有数据逐个添加到列表1的尾部# 返回：返回的None（关键字，空），一般就不再使用变量保存返回内容# 查看打印列表，表示返回值\n\n# list2拆开添加到mylistmylist = [&#x27;我&#x27;, &#x27;爱&#x27;]list2 = list(&#x27;螺蛳粉&#x27;)mylist.extend(list2)print(mylist)#list2作为整体加入mylist中mylist.append(list2)print(mylist)\n\n\n列表删除在列表中删除中间的数据，后面的数据会向前移动\n根据下标删除列表.pop(下标) #删除指定下标对应的数据# 下标不写，默认删除最后的数据# 书写存在的下标，删除对应下标位置的数据# 返回删除的数据del.列表[下标]\n\n根据数据值删除列表.remove(数据) # 返回None# 若删除的数据不存在，会报错# 重复的数据删除第一个，想要删除多个进行循环\n\n清空数据（一般不用）列表.clear()\n\n列表的反转和逆置1. 列表[::-1] # 得到一个新列表，原列表不会改变2. 列表.reverse() # 直接修改原列表，返回reverse\n\n列表的复制# 使用场景，修改列表中的数据与修改之前的原始数据进行对比1. 使用切片变量 = 列表[:]2. 使用copy方法变量 = 列表.copy()列表1 = 列表2 # 是同一个列表，多了个名字\n\n列表的排序列表的排序一般是针对数字进行排序\n列表.sort() # 按照升序排序列表.sort(reverse=True) # 降序排序\n\n列表去重去除列表中重复的数据\n错误示范my_list = [1, 23, 33, 11, 2, 23, 3, 2, 1, &#x27;3&#x27;, 3]for i in my_list:    while (my_list.count(i) &gt; 1):        my_list.remove(i)print(my_list)\n\n\n当检测到列表中该数据需要删除时，列表后方数据会向前移动，所以紧跟在被删除数据后方的元素会不参与遍历\n正确示范思想：放入新容器my_list = [1, 23, 33, 11, 2, 23, 3, 2, 1, &#x27;3&#x27;, 3]new_list=[]for i in my_list:    if i not in new_list:        new_list.append(i)    else:        continueprint(new_list)\n\n\n利用集合set特点\n缺点：不能保证数据在原列表中的顺序（一般不考）\n元组tuple\nPython 的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号 **( )**，列表使用方括号 **[ ]**。\n\n元组一般在函数的传参或者返回值中使用，保证数据不会被修改\n\n\nmytuple = tuple(list) #将列表转化为元组mytuple1 = tuple(str) #将字符串转化为元组\n\n元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用：\ntuple1 = (1)tuple2 = (1,)print(type(tuple1), tuple1)print(type(tuple2), tuple2)\n\n\n元组的常用方法\n没有修改方法\n元组中可以使用下标和切片获取数据\n元组中存在index方法\n元组中存在count方法\n可以使用in操作\n\n字典\n字典是另一种可变容器模型，且可存储任意类型对象。\n字典的每个键值 key&#x3D;&gt;value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示：\n\n变量 = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;\n\n\n键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，键一般是字符串，可以是数字，不能是列表。\n字典不能转化成列表、元组和字符串\n\n# 创建空的字典dict1dict1 = &#123;&#125;print(type(dict1), dict1)# 创建空的字典dict2dict2 = dict()print(type(dict2), dict2)dict3 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: &#x27;32&#x27;, &#x27;height&#x27;: &#x27;1.78&#x27;, &#x27;is married&#x27;: True, &#x27;hobbies&#x27;: [&#x27;painting&#x27;, &#x27;music&#x27;]&#125;print(dict3)print(len(dict3))\n\n\n字典的增加修改字典[键]=数据值1. 如果键已经存在，就是修改数据值2. 如果键不存在，就是添加数据（即添加键值对）\n\ndict1 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: 32, &#x27;height&#x27;: &#x27;1.78&#x27;, &#x27;is married&#x27;: True, &#x27;hobbies&#x27;: [&#x27;painting&#x27;, &#x27;music&#x27;]&#125;print(dict1)dict1[&#x27;gender&#x27;] = &#x27;female&#x27;print(dict1)dict1[&#x27;age&#x27;] = 33print(dict1)dict1[&#x27;hobbies&#x27;].append(&#x27;studying&#x27;)print(dict1)\n\n\nlist1 = []for i in range(0, 3):    dict1 = &#123;&#125;    dict1[&#x27;name&#x27;] = input(&quot;请输入姓名&quot;)    dict1[&#x27;age&#x27;] = input(&quot;请输入年龄&quot;)    list1.append(dict1)print(list1)\n\n\n字典的删除\n删除指定的键值对\n\ndel 字典[键]字典.pop(键)\n\ndict1 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: &#x27;32&#x27;, &#x27;height&#x27;: &#x27;1.78&#x27;, &#x27;is married&#x27;: True, &#x27;hobbies&#x27;: [&#x27;painting&#x27;, &#x27;music&#x27;],         &#x27;gender&#x27;: &#x27;female&#x27;&#125;del dict1[&#x27;gender&#x27;]print(dict1)dict1.pop(&#x27;age&#x27;)print(dict1)dict1[&#x27;hobbies&#x27;].pop(0)print(dict1)dict1[&#x27;hobbies&#x27;].remove(&#x27;music&#x27;)print(dict1)dict1.clear()print(dict1)\n\n\n\n清空\n\n字典.clear()\n\n字典的查询字典中没有下标，要获取数据需要使用键来获取\n\n使用字典[键]\n# 字典[键]# 如果键存在，返回对应数据值# 如果键不存在，报错\n\n\n\n使用字典.get(键)\n字典.get(键,数据值)# 数据值一般不写，默认None# 如果键存在，返回对应数据值# 如果键不存在，返回括号中书写的数据值（None）\n\ndict1 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: &#x27;32&#x27;, &#x27;height&#x27;: &#x27;1.78&#x27;, &#x27;is married&#x27;: True, &#x27;hobbies&#x27;: [&#x27;painting&#x27;, &#x27;music&#x27;]&#125;print(dict1[&#x27;name&#x27;])print(dict1.get(&#x27;name&#x27;))print(dict1.get(&#x27;gender&#x27;))print(dict1.get(&#x27;gender&#x27;, &#x27;secret&#x27;))print(dict1[&#x27;hobbies&#x27;][0])print(dict1.get(&#x27;hobbies&#x27;)[0])\n\n字典的遍历对字典的键进行遍历1. for 变量 in 字典:\tprint(变量) #变量为字典的key2. for 变量 in 字典.keys():  # 字典.keys()可以获取字典中所有的键\tprint(变量)\n\n对值进行遍历for 变量 in 字典.values():  # 字典.values()可以获取字典中所有的值    print(变量)\n\n对键值对进行遍历for 变量1, 变量2 in 字典.items(): # 字典.items()可以获取字典中所有键值对# 变量1是key，变量2是value\n\ndict1 = &#123;&#x27;name&#x27;: &#x27;Marry&#x27;, &#x27;age&#x27;: &#x27;32&#x27;, &#x27;height&#x27;: &#x27;1.78&#x27;&#125;# 遍历字典的键for k in dict1:    print(k)for k in dict1.keys():    print(k)# 遍历字典的值print(&#x27;-&#x27; * 30)for v in dict1.values():    print(v)print(&#x27;-&#x27; * 30)for k, v in dict1.items():    print(k, v)\n\n\n容器总结\n字符串，列表，元组支持加法运算\n字符串、列表、元组支持乘上一个整数\nlen()在容器中都可以使用\nin 在容器中都可以使用，在字典中判断字典的key是否存在\n\nmy_list = [&#123;&#x27;id&#x27;: 1, &#x27;money&#x27;: 10&#125;, &#123;&#x27;id&#x27;: 2, &#x27;money&#x27;: 20&#125;,&#123;&#x27;id&#x27;: 3, &#x27;money&#x27;: 30&#125;,&#123;&#x27;id&#x27;: 4, &#x27;money&#x27;: 40&#125;]def func():    for element in my_list:        if element[&#x27;id&#x27;] % 2 == 0:            element[&#x27;money&#x27;] += 10        else:            element[&#x27;money&#x27;] += 20func()print(my_list)\n\n\nmy_dict = &#123;&#x27;登录&#x27;: [&#123;&#x27;desc&#x27;: &#x27;正确的用户名密码&#x27;, &#x27;username&#x27;: &#x27;admin&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;, &#x27;expect&#x27;: &#x27;登录成功&#x27;&#125;,                    &#123;&#x27;desc&#x27;: &#x27;错误的用户名&#x27;, &#x27;username&#x27;: &#x27;root&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;, &#x27;expect&#x27;: &#x27;登录失败&#x27;&#125;,                    &#123;&#x27;desc&#x27;: &#x27;错误的密码&#x27;, &#x27;username&#x27;: &#x27;admin&#x27;, &#x27;password&#x27;: &#x27;123123&#x27;, &#x27;expect&#x27;: &#x27;登录失败&#x27;&#125;,                    &#123;&#x27;desc&#x27;: &#x27;错误的用户名和密码&#x27;, &#x27;username&#x27;: &#x27;aaa&#x27;, &#x27;password&#x27;: &#x27;123123&#x27;, &#x27;expect&#x27;: &#x27;登录失败&#x27;&#125;],           &#x27;注册&#x27;: [&#123;&#x27;desc&#x27;: &#x27;注册1&#x27;, &#x27;username&#x27;: &#x27;abcd&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;&#125;,                    &#123;&#x27;desc&#x27;: &#x27;注册1&#x27;, &#x27;username&#x27;: &#x27;xyz&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;&#125;]&#125;opt = input(&quot;请输入信息：登录/注册&quot;)  # 获取测试人员的信息info_list = []if opt == &#x27;登录&#x27;:    print(&quot;获取登录数据&quot;)    for i in my_dict.get(&#x27;登录&#x27;):        my_tuple = (i.get(&#x27;username&#x27;), i.get(&#x27;password&#x27;), i.get(&#x27;expect&#x27;))        info_list.append(my_tuple)    print(info_list)elif opt == &#x27;注册&#x27;:    print(&quot;获取注册数据&quot;)    for i in my_dict.get(&#x27;注册&#x27;):        my_tuple = (i.get(&#x27;username&#x27;), i.get(&#x27;password&#x27;))        info_list.append(my_tuple)    print(info_list)else:    print(&quot;输入错误&quot;)\n\n\n\nPython运算符算术运算符以下假设变量 a&#x3D;10，变量 b&#x3D;21：\n\n\n\n运算符\n描述\n实例\n\n\n\n+\n加 - 两个对象相加\na + b 输出结果 31\n\n\n-\n减 - 得到负数或是一个数减去另一个数\na - b 输出结果 -11\n\n\n*\n乘 - 两个数相乘或是返回一个被重复若干次的字符串\na * b 输出结果 210\n\n\n&#x2F;\n除 - x 除以 y（返回浮点类型）\nb &#x2F; a 输出结果 2.1\n\n\n%\n取模 - 返回除法的余数\nb % a 输出结果 1\n\n\n**\n幂 - 返回x的y次幂\na**b 为10的21次方\n\n\n&#x2F;&#x2F;\n取整除 - 往小的方向取整数\n&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5\n\n\n优先级：() &gt; ** &gt; * &#x2F; &#x2F;&#x2F; % &gt; + -\n比较运算符以下假设变量 a 为 10，变量 b 为20：\n\n\n\n运算符\n描述\n实例\n\n\n\n&#x3D;&#x3D;\n等于 - 比较对象是否相等\n(a &#x3D;&#x3D; b) 返回 False。\n\n\n!&#x3D;\n不等于 - 比较两个对象是否不相等\n(a !&#x3D; b) 返回 True。\n\n\n&gt;\n大于 - 返回x是否大于y\n(a &gt; b) 返回 False。\n\n\n&lt;\n小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。\n(a &lt; b) 返回 True。\n\n\n&gt;&#x3D;\n大于等于 - 返回x是否大于等于y。\n(a &gt;&#x3D; b) 返回 False。\n\n\n&lt;&#x3D;\n小于等于 - 返回x是否小于等于y。\n(a &lt;&#x3D; b) 返回 True。\n\n\n逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:\n\n\n\n运算符\n逻辑表达式\n描述\n实例\n\n\n\nand\nx and y\n布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。当第一个条件为False时，第二个条件不判断\n(a and b) 返回 20。\n\n\nor\nx or y\n布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。当第一个条件为True，第二个条件不再判断\n(a or b) 返回 10。\n\n\nnot\nnot x\n布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。\nnot(a and b) 返回 False\n\n\n当数字不是0时，都表示True\n赋值运算符以下假设变量a为10，变量b为20：\n\n\n\n运算符\n描述\n实例\n\n\n\n&#x3D;\n简单的赋值运算符\nc &#x3D; a + b 将 a + b 的运算结果赋值为 c\n\n\n+&#x3D;\n加法赋值运算符\nc +&#x3D; a 等效于 c &#x3D; c + a\n\n\n-&#x3D;\n减法赋值运算符\nc -&#x3D; a 等效于 c &#x3D; c - a\n\n\n*&#x3D;\n乘法赋值运算符\nc *&#x3D; a 等效于 c &#x3D; c * a\n\n\n&#x2F;&#x3D;\n除法赋值运算符\nc &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a\n\n\n%&#x3D;\n取模赋值运算符\nc %&#x3D; a 等效于 c &#x3D; c % a\n\n\n**&#x3D;\n幂赋值运算符\nc * *&#x3D; a 等效于 c &#x3D; c ** a\n\n\n&#x2F;&#x2F;&#x3D;\n取整除赋值运算符\nc &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a\n\n\n:&#x3D;\n海象运算符，这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。Python3.8 版本新增运算符。\n在这个示例中，赋值表达式可以避免调用 len() 两次:if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)\n\n\n成员运算符\n\n\n运算符\n描述\n实例\n\n\n\nin\n如果在指定的序列中找到值返回 True，否则返回 False。\nx 在 y 序列中 , 如果 x 在 y 序列中返回 True。\n\n\nnot in\n如果在指定的序列中没有找到值返回 True，否则返回 False。\nx 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。\n\n\n条件控制if elif elseif condition_1:    statement_block_1elif condition_2:    statement_block_2else:    statement_block_3\n\nage = input(&#x27;输入你的年龄：&#x27;)if int(age) &gt;= 18:    print(&quot;满18岁了可以去网吧&quot;)else:    print(&quot;未成年不能进入网吧&quot;)\n\n\nname = input(&#x27;输入你的用户名：&#x27;)if name == &#x27;admin&#x27;:    print(&quot;admin登录成功！&quot;)elif name == &#x27;test&#x27;:    print(&quot;test登录成功！&quot;)else:    print(&quot;登陆失败！&quot;)name = input(&#x27;输入你的用户名：&#x27;)if name == &#x27;admin&#x27; or name == &#x27;test&#x27;:    print(&quot;%s登陆成功！&quot; % name)else:    print(&quot;登陆失败！&quot;)\n\n\ndate = input(&quot;输入今天是星期几：&quot;)if date == &#x27;1&#x27;:    print(&quot;今天要去上班&quot;)elif date == &#x27;2&#x27;:    print(&quot;才上了一天班呢&quot;)elif date == &#x27;3&#x27;:    print(&quot;到周中了&quot;)elif date == &#x27;4&#x27;:    print(&quot;今天是疯狂星期四&quot;)elif date == &#x27;5&#x27;:    print(&quot;明天就放假了！&quot;)elif date == &#x27;6&#x27;:    print(&quot;放假第一天&quot;)elif date == &#x27;7&#x27;:    print(&quot;明天就上班了&quot;)else:    print(&quot;你输入错误了&quot;)\n\n\nif嵌套num = int(input(&quot;请输入一个整数&quot;))if num % 2 == 0:    if num % 3 == 0:        print(&quot;数字%d可以整除2和3&quot; % num)    else:        print(&quot;数字%d可以整除2，不能整除3&quot; % num)else:    if num % 3 == 0:        print(&quot;数字%d可以整除3，不能整除2&quot; % num)    else:        print(&quot;数字%d既不能整除2也不能整除3&quot; % num)\n\n\nmatch…casematch subject:    case &lt;pattern_1&gt;:        &lt;action_1&gt;    case &lt;pattern_2&gt;:        &lt;action_2&gt;    case &lt;pattern_3&gt;:        &lt;action_3&gt;    case _:        &lt;action_wildcard&gt;\n\ndef http_error(status):    match status:        case 400:            return &quot;Bad request&quot;        case 404:            return &quot;Not found&quot;        case 418:            return &quot;I&#x27;m a teapot&quot;        case 401 | 403 | 404:            return &quot;Not allowed&quot;        case _:            return &quot;Something&#x27;s wrong with the internet&quot;mystatus=int(input(&#x27;输入状态码&#x27;))print(http_error(mystatus))\n\n\n猜拳游戏import randomwhile True:    player = input(&quot;剪刀石头布，你出什么，想要退出输入0&quot;)    if player == &#x27;0&#x27;:        break    randomid = random.randint(0, 2)  # 产生0-2之间的随机整数，包含0和2    listcom = [&#x27;剪刀&#x27;, &#x27;石头&#x27;, &#x27;布&#x27;]    computer = listcom[randomid]    match computer:        case &#x27;剪刀&#x27;:            print(&quot;电脑出的是%s&quot; % computer)            print(&quot;你出的是%s&quot; % player)            match player:                case &#x27;剪刀&#x27;:                    print(&quot;平局！&quot;)                case &#x27;石头&#x27;:                    print(&quot;你赢了！&quot;)                case &#x27;布&#x27;:                    print(&quot;你输了！&quot;)                case _:                    print(&quot;出错了！&quot;)        case &#x27;石头&#x27;:            print(&quot;电脑出的是%s&quot; % computer)            print(&quot;你出的是%s&quot; % player)            match player:                case &#x27;剪刀&#x27;:                    print(&quot;你输了！&quot;)                case &#x27;石头&#x27;:                    print(&quot;平局！&quot;)                case &#x27;布&#x27;:                    print(&quot;你赢了！&quot;)                case _:                    print(&quot;出错了！&quot;)        case &#x27;布&#x27;:            print(&quot;电脑出的是%s&quot; % computer)            print(&quot;你出的是%s&quot; % player)            match player:                case &#x27;剪刀&#x27;:                    print(&quot;你赢了！&quot;)                case &#x27;石头&#x27;:                    print(&quot;你输了！&quot;)                case &#x27;布&#x27;:                    print(&quot;平局！&quot;)                case _:                    print(&quot;出错了！&quot;)\n\n\n循环语句while循环while 判断条件(condition)：    执行语句(statements)……\n\n死循环和无限循环\n死循环：bug造成的\n无限循环：while true,故意设计的。应用场景：书写循环时，不确定循环要执行多少次。无限循环的使用一般会在循环中添加if判断，当if条件成立，使用关键字break终止循环\n\nwhile# 1到100的数字之和i = 1sum = 0while (i &lt;= 100):    sum = sum + i    i = i + 1print(sum)\n\n\n# 1到100的之间的偶数之和i = 2sum = 0while (i &lt;= 100):    sum = sum + i    i = i + 2print(sum)# if判断计算1到100的之间的偶数之和i = 1sum = 0while (i &lt;= 100):    i = i + 1    if i % 2 == 0:        sum = sum + iprint(sum)\n\n\nwhile…else如果 while 后面的条件语句为 false 时，则执行 else 的语句块。如果循环由break中断，不执行else中的语句\n语法格式如下：\nwhile &lt;expr&gt;:    &lt;statement(s)&gt;else:    &lt;additional_statement(s)&gt;\n\ncount = 0while count &lt; 5:    print(count, &quot; 小于 5&quot;)    count = count + 1else:    print(count, &quot; 大于或等于 5&quot;)\n\n\ncount = 0while count &lt; 5:    print(count, &quot; 小于 5&quot;)    count = count + 1    if count == 3:        breakelse:    print(count, &quot; 大于或等于 5&quot;)\n\n\nfor循环for 循环可以遍历容器中的数据，容器：字符串、列表、元组、字典\nfor循环的一般格式如下：\nfor &lt;variable&gt; in &lt;sequence&gt;:    &lt;statements&gt;else:    &lt;statements&gt;\n\nfor … in …\n容器中有多少个数据，循环执行多少次\n每次循环会将容器中的数据取出，保存到in前面的变量中\n\n# 遍历列表中的元素sites = [&quot;Baidu&quot;, &quot;Google&quot;, &quot;chrome&quot;, &quot;Taobao&quot;]for site in sites:    print(site)\n\n\nword = &#x27;Google&#x27;for letter in word:    print(letter, end=&#x27; &#x27;)\n\n\nfor range()整数范围值可以配合 range() 函数使用：\nfor number in range(1, 6):    print(number,end=&#x27;&#x27;)\n\n\nfor … else在 Python 中，for…else 语句用于在循环结束后执行一段代码。\n语法格式如下：\nfor item in iterable:    # 循环主体else:    # 循环结束后执行的代码\n\n当循环执行完毕（即遍历完 iterable 中的所有元素）后，会执行 else 子句中的代码，如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句。\nfor x in range(6):    print(x,end=&#x27; &#x27;)else:    print(&quot;Finally finished!&quot;)\n\n\nrange()函数\nrange() 函数会生成数列，range(n)，可以生成0到n（不包含n）的数字。循环循环n次\nrange(a,b)生成从a到b（不含b）的数列\nrang(a,b,c)c为步长（增量），可以为负数\n\n# 获取列表索引list1 = [&#x27;hello&#x27;, 234, 56, &#x27;wer&#x27;, 0, &#x27;wqqe&#x27;]for i in range(len(list1)):    print(i, list1[i])\n\n\n\n\n还可以使用 range() 函数来创建一个列表\nlist(range(5))[0, 1, 2, 3, 4]\n\nbreak和continue\nbreak：终止循环，循环立即结束\ncontinue：跳过本次循环，本次循环剩下的代码不再执行，进行下一次循环\nbreak 语句可以跳出 for 和 while 的循环体。else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，如果从 for 或 while 循环中被break终止，任何对应的循环 else 块将不执行。\ncontinue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。\n\n\nstr = input(&quot;输入一个字符串并打印,当输入i的时候i不打印，当输入%的时候结束打印&quot;)for i in str:    if i == &#x27;i&#x27;:        continue    if i == &#x27;%&#x27;:        break    print(i, end=&#x27;&#x27;)else:    print(&quot;打印完成！&quot;)\n\n\n\npass语句pass是空语句，是为了保持程序结构的完整性。\npass 不做任何事情，一般用做占位语句\n函数函数的定义\n函数必须先定义后调用\n\ndef functname():    code    ...# 1. def是关键字，用来定义函数的# 2. 函数名需要遵守标识符的规则# 3. 处于def缩进中的代码称为函数体# 4. 函数定义的时候，函数体中的代码不会执行，调用的时候才会执行\n\n函数的调用functname()# 1. 函数调用的时候会执行函数体中的代码# 2. 函数调用的代码要写在函数体外面\n\n文档注释本质上是注释，只是书写的位置和作用比较特殊\n\n书写位置：在函数名的下方使用，三对双引号进行注释\n作用：告诉别人函数如何使用\n查看，在调用的时候，将光标放到函数名上使用ctrl+q\nctrl+b会转到函数的声明（按住ctrl鼠标左键点击）\n\n\n函数的嵌套调用在一个函数定义中调用另一个函数\n注意：\n\n函数定义不会调用函数体中的代码\n函数调用会执行函数体中的代码\n函数体中代码执行结束会回到函数被调用的地方继续向下执行\n\n函数参数\n在函数定义的时候，使用变量代替具体的数据（进行占位），称为形参，在调用函数的时候，传递具体的数值，称为实参\n函数的传参传递的是引用\n\n函数传参的方式位置传参在函数调用的时候，按照形参的顺序，将实参值传递给形参\n关键字传参在函数调用的时候，指定数据值给到那个形参\n混合使用\n关键字传参必须写在位置传参的后面\n不能给一个形参传递多个数据\n\n# 求和函数def my_sum(a, b):    return a + bnum1 = int(input(&#x27;输入第一个数字&#x27;))num2 = int(input(&#x27;输入第一个数字&#x27;))print(my_sum(num1, num2))\n\n\n缺省参数缺省参数即默认参数\n# 在函数定义的时候，给形参一个默认的数据值，这个形参就变为缺省参数# 缺省参数的书写要放在普通参数的后边# 缺省参数在函数调用的时候可以传递实参值，也可以不传递实参值# 传参即为实参值，不传即为缺省值def functname(para1,para1=&#x27;value&#x27;)\n\n多值参数（不定长参数）比如print()函数，可以有多个参数\n在书写函数不确定参数个数的时候，可以使用不定长参数（多值参数）\n\n不定长位置参数（不定长元组参数）\n\n在普通参数的前面加上一个*，这个参数就变为不定长位置参数\n这个形参可以接受任意多个位置的传参\n形参的类型是元组\n不定长位置参数写在普通参数的后面\n一般写法，不定长位置参数的名字为args，即(*args)\n\n\n\n\n不定长关键字参数（不定长字典参数）\n\n在普通参数的前面加上两个**，这个参数就变为不定长关键字参数\n这个形参可以接受任意多个关键字的传参\n形参的类型是字典\n不定长位置参数写在所有参数的后面\n一般写法，不定长关键字参数的名字为kwargs，即(**kwargs)\n\n\n\n\n\ndef my_sum(*args, **kwargs):    num = 0    for i in args:        num += i    for j in kwargs.values():        num += j    print(num)my_sum(1, 2, a=4, b=5, c=6)\n\n\ndef my_sum(*args, **kwargs):    num = 0    for i in args:        num += i    for j in kwargs.values():        num += j    print(num)mylist = [1, 2, 3, 4]mydict = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;# 将列表(元组)中的数据分别作为位置参数进行传参，需要对列表进行拆包操作my_sum(*mylist)  # my_sum(1,2,3,4)# 将字典中的数据作为关键字传参，需要使用**对字典进行拆包my_sum(**mydict)  # my_sum(a=1,b=2,c=3,d=4)my_sum(*mylist, **mydict)\n\n\n完整的参数顺序def functname (普通参数, *args, **kwargs):    pass\n\ndef func(*args, **kwargs):    print(type(args), args)    print(type(kwargs), kwargs)    print(&#x27;-&#x27; * 30)func()func(1, 2, 3)  # 数据都给argsfunc(a=1, b=2, c=3)  # 关键字传参，数据都给kwargsfunc(1, 2, 3, a=4, b=5, c=6)  # 不定长传参,前面数据都给args，后面kwargs\n\n\n函数的返回值函数整体执行的结果，函数中得到的数据在后续的代码中还要使用，这时需要将数据作为返回值返回\nreturn之后的代码不会执行\ndef functname():   # 返回值None    passdef functname():    return     # 返回值Nonedef functname():    return xx  # 返回值xx\n\n变量引用\n变量和数据都是保存在内存中的\n在python中函数的参数传递以及返回值都是靠引用传递的\n\n1. 在定义变量的时候 变量=数据值，Python解释器会在内存中开辟两块空间2. 变量和数据都有自己的空间3. 本质：数据的地址保存到变量对应的内存中4. 变量中储存数据地址的行为就是引用（变量引用了数据的地址，简单说就是变量中储存了数据）存储的地址称为引用地址5. 可以使用id()，获取变量中的引用地址，即数据的地址。如果两个变量的id()获取的引用地址一样，代表着两个变量引用了同一个数据6. 只有赋值运算符=可以改变变量的引用\n\na = 1b = 2c = 1print(id(a))print(id(b))print(id(c))\n\n\n可变类型和不可变类型数据类型：int float bool str list tuple dict set可变类型：数据所在的内存允许修改不可变类型：数据所在的内存不允许修改不使用=，变量引用的数据中的内容是否会变化，会变化是可变的，不会变化是不可变的可变类型：list,dict,set不可变类型：int，float，bool，str，tuple\n\nlist1=[1,2,3]print(&#x27;list1&#x27;,id(list1))list2=[1,2,3]print(&#x27;list2&#x27;,id(list2))print(&#x27;list1[0]&#x27;,id(list1[0]))print(&#x27;list1[1]&#x27;,id(list1[1]))print(&#x27;list1[2]&#x27;,id(list1[2]))print(&#x27;list2[0]&#x27;,id(list2[0]))print(&#x27;list2[1]&#x27;,id(list2[1]))print(&#x27;list2[2]&#x27;,id(list2[2]))list1[1]=10print(&#x27;list1&#x27;,id(list1))print(&#x27;list1[0]&#x27;,id(list1[0]))print(&#x27;list1[1]&#x27;,id(list1[1]))print(&#x27;list1[2]&#x27;,id(list1[2]))\n\n\nmytuple = (1, 2, [3, 4])# 元组中的数据不能改变，指的是这三个地址不能改变print(id(mytuple[-1]))mytuple[-1][0] = 10  # 修改的是列表中下标为0的位置的引用地址，列表的地址没有变，元组中的内容没有变化(元组的内容是引用地址)print(mytuple)print(id(mytuple[-1]))\n\n\n\n可变类型做参数使，不使用&#x3D;改变形参的引用，对形参的数据修改会同步到实参中\nlist中+&#x3D;操作的本质是extend的操作\n\n交换两个变量的值# 数学方法a = 10b = 20a = a + bb = a - ba = a - b# Python特有a, b = b, a #先组包，后拆包\n\n组包(pack)和拆包(unpack)\n组包：将多个数据值使用逗号连接的过程，组成元组\n\n拆包：将容器中数据值使用多个变量分别保存的过程，注意：变量的个数和容器中数据的个数要保持一致\n\n赋值运算符先执行&#x3D;右边的内容，执行的结果保存到等号左边的变量中\n\n注意：对字典进行拆包得到的是字典的键\ndict1=&#123;&#x27;name&#x27;:&#x27;Ana&#x27;,&#x27;age&#x27;:18,&#x27;height&#x27;:12&#125;a,b,c=dict1print(a,b,c)print(dict1[a])print(dict1[b])print(dict1[c])\n\n\n\n\na = 10b = 20c = a, b# 组包print(&#x27;组包结果：&#x27;, type(c), c)# 拆包a, b = c  # a,b等于c容器中的两个数据print(&#x27;拆包结果是&#x27;, a, b)# 先组包后拆包x, y, z = [1, 2, 3] #将1,2,3组起来，然后存入x,y,zprint(x, y, z)\n\n\n局部变量和全局变量\n根据变量定义的位置进行区分\n\n局部变量在函数内部定义的变量，称为局部变量。形参属于局部变量\n特点：\n\n局部变量只能在当前函数内部使用，不能在其他函数和函数外部使用\n在不同函数中，可以定义名字相同的局部变量，两者之间没有明显\n局部变量生存周期（生命周期，作用范围）：在函数被调用的时候，局部变量被创建；函数调用结束，局部变量的值被销毁，不能使用\n\n函数局部变量的值想要被函数外部使用，需要使用return关键字\n全局变量在函数外部定义的变量，称为全局变量\n特点：\n\n可以在任何函数中读取全局变量的值\n如果在函数中存在和全局变量名字相同的局部变量，在函数中使用的是局部变量的值\n在函数内部想要修改全局变量的引用（数据值），需要添加global关键字对变量进行声明为全局变量。类似列表的.append()操作不改变引用不需要globa&#96;的操作\n代码执行的时候全局变量被创建，代码执行结束全局变量被销毁\n\nnum=10def func1():    print(num)def func2():    num=20    print(num)def func3():    global num    num=30    print(num)func1()func2()func3()func1()\n\n\n函数返回值# 返回多个数据值，将多个数据值组包进行返回return a,b\n\n匿名函数（lambda表达式）Python 使用 lambda 来创建匿名函数。\nlambda 函数是一种小型、匿名的、内联函数，它可以具有任意数量的参数，但只能有一个表达式。\n匿名函数不需要使用 def 关键字定义完整函数。\nlambda 函数通常用于编写简单的、单行的函数，通常在需要函数作为参数传递的情况下使用，例如在 map()、filter()、reduce() 等函数中。\nlambda 函数特点：\n\nlambda 函数是匿名的，它们没有函数名称，只能通过赋值给变量或作为参数传递给其他函数来使用。返回值不需要return，一行代码（表达式）的结果就是返回值\nlambda 函数通常只包含一行代码，这使得它们适用于编写简单的函数。\n\nlambda 参数: 一行代码# 匿名函数一般作为函数的参数使用\n\n# 1. 无参无返回值def func1():    print(&#x27;hello world&#x27;)func1()a = lambda: print(&#x27;hello lambda&#x27;)a()# 2. 无参有返回值def func2():    return 10print(func2())b = lambda: 22print(b())# 3. 有参无返回值def mysum(a, b):    print(a + b)mysum(1, 2)c = lambda a, b: print(a + b)c(10, 22)# 4. 有参有返回值def sum1(a, b):    return a + bprint(sum1(2, 4))d = lambda a, b: a + bprint(d(5, 6))\n\n\n# 定义一个匿名函数，参数为字典，返回字典中键为age的值# 参数只是占位作用，定义的时候没有具体值，形参的值是在调用的时候进行传递，此时形参才具有数据值# 形参的类型就是由实参决定，在函数定义的时候形参只是一个函数符号。想要形参是字典类型，实参是字典类型就可b = lambda x: x.get(&#x27;age&#x27;)print(b(&#123;&#x27;name&#x27;: &#x27;ann&#x27;, &#x27;age&#x27;: 18&#125;))\n\n\n匿名函数作为参数列表中的字典排序sort()列表的排序默认是对列表的数据进行比大小，可以对数据类型和字符串比大小。对字典来说，比大小需要使用sort()中的key参数。key参数需要传递一个函数，一般是匿名函数。\n字典的排序需要指定依照字典的什么键进行排序，需要使用匿名函数返回字典的键对应的值\nuser_list = [&#123;&#x27;name&#x27;: &#x27;lisi&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 17&#125;]user_list.sort(key=lambda x: x.get(&#x27;name&#x27;), reverse=True)  # 降序排序# 匿名函数的参数是列表中的数据。在sort()函数内部，会调用key函数，将列表中的每个数据作为实参传递给形参，从列表中获取函数的返回值，对返回值进行比大小print(user_list)user_list.sort(key=lambda x: x.get(&#x27;age&#x27;), reverse=True)print(user_list)\n\n\nord()可以获取字符对应的ASCII码\nchr(ASCII)可以获取ASCII码对应的字符\n面向对象面向对象是一种编程思想\n类和对象\n类\n多个特征和行为相同或相似事物的统称\n泛指的（指代多个，而不是一个）\n\n\n对象\n具体存在的一个事物，看得见摸得着的\n特指的（指一个）\n由类创建的\n\n\n\n苹果   -----&gt;类红苹果  -----&gt;类张三嘴里吃的苹果 ----&gt;对象\n\n类的组成\n类名：给多个事物起的名称，在代码中要满足大驼峰命名法\n属性：事物的特征\n方法：事物的行为，类中定义的函数。\n\n类的抽象（类的设计）：找到类的类名，属性和方法\n1. 小明 今年18岁，身高1.75，每天早上跑完步会去吃东西2. 小红 今年177岁，身高1.72，不跑步，喜欢吃吃东西类名：人类（Person）属性：名字（name）、年龄（age）、身高（height）方法：跑步（run）、吃（eat）一只黄颜色的狗狗叫大黄，看见生人汪汪叫，看见熟人摇尾巴类名：狗类（dog）属性：颜色（color）、名字（name）方法：汪汪叫（bark），摇尾巴（shake）\n\n对象python中一切都是对象，即用class定义的类也是对象\n\n属性：对对象的特征的描述\n方法：对象具有的行为\n\n对象的划分实例对象（实例）通过类名()创建的对象即实例对象，简称实例\n创建对象的过程称作类的实例化\n我们平时说的对象就是实例对象\n每个实例都有自己的内存空间，在自己的内存空间中保存自己的属性（实例属性）\n类对象（类名）类对象就是类，可以认为是类名（类名包含了整个类）\n类对象是python解释器在执行代码的过程中创建的\n类对象的作用：使用类对象创建实例，类对象也有自己的内存空间，可以保存一些属性值（类属性）信息\n在一个代码中，一个类只有一份内存空间\n属性的划分实例属性概念：是实例对象具有的属性\n定义和使用：\n在init方法中，使用self.属性名= 属性值定义\n在方法中使用self.属性名来调用\n在每个实例当中都存在一份内存空间\n使用时机：基本上99%都是实例属性，通过self定义。找多个对象判断这个值是不是一样的，如果都是一样的，同时变化，一般定义为类属性，否则定义为实例属性\n类属性概念：是类对象具有的属性\n定义和使用：\n在类内部，方法外部定义的变量\n类对象.属性名=属性值或类名.属性名=属性值\n使用类对象.属性名或类名.属性名调用\n只有类对象中存在一份内存空间\nclass Dog:    # 定义类属性count，记录创建对象的个数    count = 0    def __init__(self, name):        # 定义实例属性，实例属性在init方法中定义        self.name = name;        # 每创建一个对象就会调用init方法        Dog.count += 1dog1 = Dog(&#x27;小花&#x27;)print(Dog.count)dog2 = Dog(&#x27;大黄&#x27;)print(Dog.count)dog2 = Dog(&#x27;小白&#x27;)print(Dog.count)# 可以用 实例对象.类属性名 来获取类属性的值（原因：实例对象属性的查找现在实例属性中找，找到直接使用，没有找到会去类属性里寻找）print(dog1.count)print(dog2.count)print(dog3.count)\n\n\n方法的划分实例方法（最常用）\n定义：在类中直接定义的方法\nclass Demo:    def func(self): # self一般表示实例对象        pass\n\n\n\n定义时机：如果在方法中需要使用实例属性（需要使用self），则这个方法必须定义为实例方法\n\n调用：对象.方法名()\n\n\n类方法\n定义：在方法名字的上方书写@classmethod 装饰器\nclass Demo:    @classmethod    def func(cls): # cls表示的是类对象（类名）class        pass\n\n定义时机：方法中不需要使用实例属性（即self），用到了类属性，可以将这个方法定义为类方法，也可以定义为实例方法\n\n调用：通过类对象调用：类名.方法名()，通过实例对象调用：实例.方法名()cls不需要传参\n\n\n静态方法\n定义：在方法名字的上方书写@staticmethod 装饰器\nclass Demo:    @staticmethod    def func(): # 一般没有参数        pass\n\n\n\n使用时机：方法中不需要使用实例属性，也不使用类属性，可以将这个方法定义为静态方法\n\n调用：通过类对象调用：类名.方法名()，通过实例对象调用：实例.方法名()\n\n\nimport randomclass Game:    top_score = 0    def __init__(self, name):        self.name = name    @classmethod    def start_game(cls):        cls.score = random.randint(10, 100)        print(f&#x27;本次游戏得分&#123;cls.score&#125;&#x27;)    @classmethod    def show_top_score(cls):        if cls.score &gt; Game.top_score:            Game.top_score = cls.score            print(f&#x27;现在的最高分是&#123;Game.top_score&#125;&#x27;)        else:            print(f&#x27;现在的最高分是&#123;Game.top_score&#125;&#x27;)    @staticmethod    def show_help():        print(&quot;这场游戏的得分都是随机的&quot;)player1 = Game(&#x27;小王&#x27;)player1.start_game()Game.show_top_score()player1.start_game()Game.show_top_score()Game.show_help()\n\n\nimport randomclass Game:    top_score = 0    top_score_player=&#x27;&#x27;    def __init__(self, name):        self.name = name        self.score = 0    def start_game(self):        self.score = random.randint(10, 100)        print(f&#x27;本次&#123;self.name&#125;游戏得分&#123;self.score&#125;&#x27;)    def show_top_score(self):        if self.score &gt; Game.top_score:            Game.top_score = self.score            Game.top_score_player = self.name            print(f&#x27;现在的最高分是&#123;Game.top_score&#125;,得主是&#123;Game.top_score_player&#125;&#x27;)        else:            print(f&#x27;现在的最高分是&#123;Game.top_score&#125;,得主是&#123;Game.top_score_player&#125;&#x27;)    @staticmethod    def show_help():        print(&quot;这场游戏的得分都是随机的&quot;)player1 = Game(&#x27;小王&#x27;)player1.start_game()player1.show_top_score()player2 = Game(&#x27;小李&#x27;)player2.start_game()player2.show_top_score()player3 = Game(&#x27;小张&#x27;)player3.start_game()player3.show_top_score()player4 = Game(&#x27;小红&#x27;)player4.start_game()player4.show_top_score()Game.show_help()\n\n\n面向对象的代码步骤\n定义类，在定义类之前先设计类\n先定义简单的类，不包含属性，在python中定义类需要使用关键字class\n方法：在类中定义的函数，第一个函数是self\nclass 类名:\tdef 方法名(self):        pass\n\n创建对象，使用第一步定义的类创建对象\n创建对象使用类名()进行创建\n变量=类名() #变量中保存的是对象的地址，一般直接称为对象# 一个类可以创建多个对象\n\n通过对象调用方法\n对象.方法名()\n\n案例实现\n# 需求：小猫爱吃鱼，小猫要喝水# 类名：猫类Cat# 属性：暂无# 方法：吃鱼eat(),喝水drink()# 类的定义class Cat:    def eat(self):        print(&quot;小猫爱吃鱼&quot;)    def drink(self):        print(&quot;小猫要喝水&quot;)# 创建对象bluecat = Cat()bluecat.eat()bluecat.drink()redcat = Cat()redcat.eat()redcat.drink()    \n\n\n\n\nself的说明   class Cat:    def eat(self):        print(&quot;小猫爱吃鱼&quot;)\n\n\n从函数的语法上讲，self是形参，就可以是任意的变量名，只不过我们习惯性将这个形参写成self\nself是普通的形参，但是调用的时候没有传递实参值，原因是python解释器在执行代码的时候，自动**调用这个方法的对象传递给了self**，即self的本质是对象\n验证，只需要确定通过哪个对象调用，对象的引用和self的引用一样\n\n# 类的定义class Cat:    def eat(self):        print(f&#x27;&#123;id(self)&#125;,self&#x27;)        print(&quot;小猫爱吃鱼&quot;)# 创建对象bluecat = Cat()bluecat.eat()# bluecat调用eat()方法，解释器就会将bluecat对象传给selfprint(id(bluecat), &#x27;bluecat&#x27;)a = bluecat # 不是创建对象a.eat()print(id(a), &#x27;a&#x27;)redcat = Cat()redcat.eat()print(id(redcat), &#x27;redcat&#x27;)# self是函数局部变量，创建的对象是全局变量\n\n\n对象的属性操作添加属性对象.属性名 = 属性值\n\n类内部添加\nself.属性名 = 属性值# 在类中添加属性一般写在__init__方法中\n\n\n\n类外部添加\n对象.属性名 = 属性值 # 一般不使用\n\n魔法方法python中有一类方法，以两个下划线开头，两个下划线结尾，并且在满足某个条件的情况下会自动调用，这类方法称为魔法方法\n__init__方法\n创建对象后会自动调用\n应用场景：给对象添加属性的（初始方法，构造方法）。某些代码，在每次创建对象后都要执行，可以写在__init__方法中\n如果__init__函数有除了self之外的参数，要记得传参\n\nclass Cat:    def __init__(self): # 创建对象才调用        self.name = &#x27;蓝猫&#x27;        self.age = 2        # 下方代码只是为了验证该方法被调用，实际代码中不要书写        print(&quot;我是__init__,我被调用了&quot;)    def show_info(self):        print(f&#x27;小猫的名字是&#123;self.name&#125;，年龄是&#123;self.age&#125;&#x27;)# 创建对象Cat()  # 创建了对象，但是没有保存bluecat = Cat()a = bluecatbluecat.show_info()\n\n\n带参数的_init_:\nclass Cat:    # 定义添加书属性的方法    def __init__(self, name, age):  # 创建对象才调用        self.name = name        self.age = age        # 下方代码只是为了验证该方法被调用，实际代码中不要书写        print(&quot;我是__init__,我被调用了&quot;)    def show_info(self):        print(f&#x27;小猫的名字是&#123;self.name&#125;，年龄是&#123;self.age&#125;&#x27;)# 创建对象bluecat = Cat(&#x27;蓝猫&#x27;, 2)bluecat.show_info()redcat = Cat(&#x27;红猫&#x27;, 3)redcat.show_info()\n\n__str__方法\n使用print()打印对象后会自动调用\n应用场景：在这个方法中一般书写对象的属性信息，即打印对象的时候想要查看的信息在此方法中定义。如果类中没有定义此方法，print(对象)输出对象的引用地址\n这个方法必须返回一个字符串\n\nclass Cat:    # 定义添加书属性的方法    def __init__(self, name, age):  # 创建对象才调用        self.name = name        self.age = age    def __str__(self):        return f&#x27;小猫的名字是&#123;self.name&#125;，年龄是&#123;self.age&#125;&#x27;# 创建对象bluecat = Cat(&#x27;蓝猫&#x27;, 2)print(bluecat)redcat = Cat(&#x27;红猫&#x27;, 3)print(redcat)\n\n\n__del__方法__del__方法（析构方法），对象被删除销毁时，自动调用。一种是程序运行结束，所有对象被销毁；一种是使用del删除对象（如果对象有多个名字即多个变量引用同个对象，需要把所有的对象都删除）\nclass Demo:    def __init__(self, name):        print(&#x27;__init__被调用了&#x27;)        self.name = name    def __del__(self):        print(f&#x27;&#123;self.name&#125;没了&#x27;)a = Demo(&#x27;a&#x27;)b = Demo(&#x27;b&#x27;)c = Demo(&#x27;c&#x27;)del aprint(&#x27;代码运行结束&#x27;)\n\n\n小明跑步class Person:    def __init__(self, name, weight):        self.name = name        self.weight = weight    def __str__(self):        return f&#x27;姓名：&#123;self.name&#125;，体重是&#123;self.weight&#125;公斤&#x27;    def run(self):        # 跑步减少0.5公斤        print(f&#x27;&#123;self.name&#125;跑了5km，体重减少了&#x27;)        self.weight -= 0.5    def eat(self):        print(f&#x27;&#123;self.name&#125;大餐一顿，体重增加了&#x27;)        self.weight += 1.0xm = Person(&#x27;小明&#x27;, 75.0) # 调用__init__print(xm) #调用__str__xm.run()print(xm) #调用__str__xm.eat()print(xm) #调用__str__\n\n\n摆放家具class House:    def __init__(self, housetype, square):        self.housetype = housetype  # 房子的户型        self.square = square  # 房子的总面积        self.leftsquare = square  # 房子剩余的面积，初始值等于总面积        self.furniture = []  # 房子有的家具    def __str__(self):        return (f&#x27;房子的户型是&#123;self.housetype&#125;,房子的总面积是&#123;self.square&#125;平方米,&#x27;                f&#x27;房子的剩余面积是&#123;self.leftsquare&#125;平方米,家具有&#123;self.furniture&#125;&#x27;)    def add_item(self, item):  # 添加家具        if self.leftsquare &gt; item.square:            self.furniture.append(item.name)  # 将家具加入列表            self.leftsquare -= item.square  # 剩余面积计算        else:            print(&#x27;剩余面积不够了！添加失败！&#x27;)class HouseItem:    def __init__(self, name, square):        self.name = name  # 家具的名字        self.square = square  # 家具的占据面积    def __str__(self):        return f&#x27;家具是&#123;self.name&#125;,占据面积是&#123;self.square&#125;平方米&#x27;bed = HouseItem(&#x27;席梦思&#x27;, 4)print(bed)chest = HouseItem(&#x27;衣柜&#x27;, 2)print(chest)table = HouseItem(&#x27;餐桌&#x27;, 1.5)print(table)newhouse = House(&#x27;一室一厅&#x27;, 98)newhouse.add_item(bed)print(newhouse)newhouse.add_item(bed)print(newhouse)newhouse.add_item(chest)print(newhouse)newhouse.add_item(table)print(newhouse)\n\n\n登录案例class LoginPage:    def __init__(self, username, password, code):        self.name = username        self.password = password        self.code = code        self.btn = &#x27;登录&#x27;    def login(self):        print(f&#x27;1. 输入用户名&#123;self.name&#125;&#x27;)        print(f&#x27;2. 输入密码&#123;self.password&#125;&#x27;)        print(f&#x27;3. 输入验证码&#123;self.code&#125;&#x27;)        print(f&#x27;4. 点击按钮&#123;self.btn&#125;&#x27;)login = LoginPage(&#x27;admin&#x27;, &#x27;123456&#x27;, &#x27;8888&#x27;)login.login()\n\n\n获取属性对象.属性名\n\n类内部添加：self.属性名\n类外部添加：对象.属性名，一般很少使用\n\nclass Cat:    def eat(self):        print(f&#x27;&#123;id(self)&#125;,self&#x27;)        print(f&quot;小猫&#123;self.name&#125;爱吃鱼&quot;)# 创建对象bluecat = Cat()# 给蓝猫添加 name属性print(f&#x27;&#123;id(bluecat)&#125;,bluecat&#x27;)bluecat.name = &#x27;蓝猫&#x27;bluecat.eat()redcat = Cat()print(f&#x27;&#123;id(redcat)&#125;,redcat&#x27;)redcat.name = &#x27;红猫&#x27;redcat.eat()\n\n\n私有和公有在Python中定义的方法和属性，可以添加访问控制权限（即在什么地方可以使用这个属性和方法）\n\n公有权限\n直接书写的方法和属性都是公有的\n公有的方法和属性可以在任意地方访问和使用\n\n\n私有权限\n在类内部，属性名或者方法名前面加上两个下划线，就变为私有\n私有方法和属性只能在当前类内部使用\n在类外部操作私有属性，在类内部定义公有方法去操作私有属性\n\n\n什么时候定义私有？\n\n某个属性或者方法不写在类外部被访问和使用，将其定义为私有\n测试中一般不怎么使用，直接公有\n开发中根据需求文档去确定什么作为私有\n\n\n\n\n\nclass Person:    def __init__(self, name, age):        self.name = name        self.__age = age    def __str__(self):        return f&#x27;名字：&#123;self.name&#125;,年龄&#123;self.__age&#125;&#x27;xm = Person(&#x27;小明&#x27;, 18)# 类内部可以使用__ageprint(xm)# 类外部不能直接使用私有属性print(xm.__age) \n\n\nclass Person:    def __init__(self, name, age):        self.name = name        # 私有的本质：解释器执行代码，发现属性名或者方法前有两个__，会将这个名字重名名        # 会在这个名字前面加上_类名前缀，即self.__age=self._Person__age        self.__age = age    def __str__(self):        return f&#x27;名字：&#123;self.name&#125;,年龄&#123;self.__age&#125;&#x27;xm = Person(&#x27;小明&#x27;, 18)# 类内部可以使用__ageprint(xm)xm.__age = 20 #不是修改私有属性，是添加了一个公有属性__ageprint(xm)print(xm._Person__age)xm._Person__age=19print(xm._Person__age)\n\n\n__dict__魔法属性可以将对象具有的属性组成字典返回\nxm = Person(&#x27;小明&#x27;, 18)# 类内部可以使用__ageprint(xm.__dict__)xm.__age = 20 #不是修改私有属性，是添加了一个公有属性__ageprint(xm.__dict__)\n\n\n继承继承描述的是类与类之间的关系，可以减少代码的冗余，实现代码的重用。\n子类继承父类之后，子类的对象可以直接使用父类中定义的公有属性和方法。\n单继承：一个类只继承一个父类\nclass 类名(父类名):    passclass A: #没有写父类，但是有父类object，object类是python中最原始的类    passclass B(A): #类B继承类A，A类是父类（基类），B类为子类（派生类）    pass\n\nclass Animal:    def eat(self):        print(&#x27;哐哐吃&#x27;)class Dog(Animal):    def bark(self):        print(&#x27;汪汪叫&#x27;)class XiaoTianQuan(Dog):    passani = Animal()ani.eat()dog = Dog()dog.eat()  # 调用父类的方法dog.bark()  # 调用自己的方法xiaotian = XiaoTianQuan()xiaotian.eat()xiaotian.bark()\n\n\n重写在子类中定义了和父类中名字相同的方法就是重写。\n当父类中的方法不能满足子类对象的需求，所以重写。\n重写之后，调用子类自己的方法，不调用父类中的方法\n重写的方式\n覆盖：父类中的功能完全抛弃，重新书写\nclass Dog:    def bark(self):        print(&#x27;汪汪叫&#x27;)class XiaoTianQuan(Dog):    # 覆盖重写    def bark(self):        print(&#x27;嗷嗷嗷&#x27;)dog = Dog()dog.bark()  # 调用自己的方法xiaotian = XiaoTianQuan()xiaotian.bark()\n\n\n\n扩展：父类中的功能还调用，只是添加新的功能（使用多）。直接在子类中定义和父类中名字相同的方法，在合适的地方调用父类中的方法 super().方法()。然后书写添加的新功能\nclass Dog:    def bark(self):        print(&#x27;汪汪叫&#x27;)        print(&#x27;汪汪叫&#x27;)class XiaoTianQuan(Dog):    # 覆盖重写    def bark(self):        print(&#x27;嗷嗷嗷&#x27;)        super().bark()        print(&#x27;嗷嗷嗷&#x27;)dog = Dog()dog.bark()  # 调用自己的方法xiaotian = XiaoTianQuan()xiaotian.bark()\n\n\n多态写代码时调用的技巧。同一个方法传入不同的对象，执行得到不同的结果即为多态\n文件计算机中的文件就是存储在某种长期存储设备上的一段数据。文件中的数据都是以二进制的形式去存储的。文件分为文本文件（可以转换为文字）和二进制文件\n文本文件：能使用记事本软件打开，能使用记事本转换为文字。txt、md、py\n二进制文件：不能使用记事本打开的。exe、mp3、mp4、png、jpg\n文件操作的步骤打开文件将文件从磁盘中读取到内存中（CPU只能对内存执行操作）\n文件流一般写入try中，因为文件流容易报错\nopen(file,mode=&#x27;r&#x27;,encoding=None)&gt; 参数file:打开的文件，类型是字符串，文件路径可以是相对路径（推荐），也可以是绝对路径&gt; 参数mode:默认参数（缺省参数），表示打开文件的方式\t&gt; r:read 只读打开    &gt; w:write 只写打开    &gt; a:append 追加打开，在文件的末尾写入内容&gt; 参数encoding:编码方式,文字和二进制如何转换\t&gt;gbk:将一个汉字转换为两个字节二进制    &gt;utf-8:将一个汉字转换为三个字节二进制&gt; 返回值:返回的是文件对象，后续对文件的操作都需要这个对象\n\n读写文件写文件向文件中写入指定的内容。\n前提：文件的打开方式是 w 或者 a\n文件对象.write(&#x27;写入文件的内容&#x27;)# 返回值：写入文件的字符数，一般不关注# 注意w方式打开文件：1. 文件不存在会直接创建2. 文件存在会覆盖原文件# 注意a方式打开文件：1. 文件不存在会直接创建2. 文件存在会在末尾写入内容\n\nf = open(&#x27;a.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)f.write(&#x27;good good&#x27;)f.close()\n\n\n读文件将文件中的内容读取出来\n前提：文件的打开方式是 r \n文件对象.read(n)# 参数n:表示读取多少个字符，一般不写表示读取全部内容# 返回值：读取到的文件内容，类型：字符串# 注意r方式打开文件，文件不存在会报错\n\nf = open(&#x27;a.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)buf = f.read()print(buf)f.close()\n\n\n关闭文件关闭文件:将文件占用的资源进行清理，同时会保存文件，文件关闭之后这个文件对象就不能使用了文件对象.close()\n\nwith open打开文件好处：不用自己去书写关闭文件的代码，会自动进行关闭\nwith open(file, mode, encoding=&#x27;utf-8&#x27;) as 变量:    # 缩进中读取/写入文件# 缩进中的代执行结束，出缩进之后文件会自动关闭\n\nwith open(&#x27;a.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:    f.write(&#x27;day day up&#x27;)\n\n\n按行读取一次读取一行内容，文件对象.readline()\nwith open(&#x27;a.txt&#x27;, encoding=&#x27;utf-8&#x27;) as f:    buf=f.readline()    print(buf)    print(f.readline())\n\n\nwith open(&#x27;a.txt&#x27;, encoding=&#x27;utf-8&#x27;) as f:    for i in f:  # 按行读取        print(i, end=&#x27;&#x27;)# read()和readling()读到文件末尾会返回空的字符串with open(&#x27;a.txt&#x27;, encoding=&#x27;utf-8&#x27;) as f:    while True:        buf = f.readline()        if len(buf) == 0: #if buf:容器中的数据个数为0为空            break        else:            print(buf,end=&#x27;&#x27;)\n\n\njson文件json&#x3D;’java script object notation’,是JavaScript对象表示法，是一种基于文本，独立于语言的轻量级数据交换格式。\n\n基于文本：是一个文本文件，不能包含图片，音视频等\n独立于语言：不是某个语言特有的，每种编程语言都可以使用\n轻量级：相同的数据和其他格式相比占用的大小比较小\n数据交换格式：后端程序员给前端的数据（json,html,xml）\n\njson文件也是一种文本文件，可以直接使用read()和write()操作，但是不方便。json文件有独特的读取和写入方法\n常用在做测试的时候，将测试数据定义为json文件格式，使用代码读取json文件，即读取测试数据，进行传参（参数化）\njson语法规则\njson文件的后缀是.json\njson文件中的主要数据类型是对象（{}类似Python中的字典）和数组（[]类似列表），对象和数组可以互相嵌套\n一个json文件是一个对象或者数组，即json文件的最外层要么是一个大括号{}，要么是一个数组[]\njson中的对象是由键值对组成的，每个数据之间使用,隔开，但是最后一个数据后面不要写逗号\njson中的字符串必须使用””双引号\njson中的其他数据类型：数字类型（int float）、字符串string（str）、布尔类型（true、false）、None（null）\n\n&#123;  &quot;name&quot;: &quot;小明&quot;,  &quot;age&quot;: 18,  &quot;gender&quot;: 1,  &quot;isFan&quot;: true,  &quot;hobbies&quot;: [    &quot;听歌&quot;,    &quot;游戏&quot;,    &quot;购物&quot;,    &quot;睡觉&quot;  ],  &quot;address&quot;: &#123;    &quot;country&quot;: &quot;China&quot;,    &quot;city&quot;: &quot;Shanghai&quot;  &#125;&#125;\n\n读取json文件1. 导包 import jason2. 读打开文件3. 读文件json.load(文件对象)# 返回的是字典（对象）或者列表（数组）\n\nimport jsonwith open(&#x27;info.json&#x27;, encoding=&#x27;utf-8&#x27;) as f:    # buf = f.read()    # print(type(buf), buf)    result = json.load(f)    print(type(result))    print(result.get(&#x27;name&#x27;))    print(result.get(&#x27;age&#x27;))    print(result.get(&#x27;address&#x27;).get(&#x27;city&#x27;))\n\n\n[&#123;  &quot;name&quot;: &quot;小明&quot;,  &quot;age&quot;: 18,  &quot;gender&quot;: 1,  &quot;isFan&quot;: true,  &quot;hobbies&quot;: [    &quot;听歌&quot;,    &quot;游戏&quot;,    &quot;购物&quot;,    &quot;睡觉&quot;  ],  &quot;address&quot;: &#123;    &quot;country&quot;: &quot;China&quot;,    &quot;city&quot;: &quot;Shanghai&quot;  &#125;&#125;, &#123;&quot;name&quot;: &quot;小红&quot;,  &quot;age&quot;: 17,  &quot;gender&quot;: 0,  &quot;isFan&quot;: false,  &quot;hobbies&quot;: [    &quot;听歌&quot;,    &quot;学习&quot;,    &quot;购物&quot;,    &quot;睡觉&quot;  ],  &quot;address&quot;: &#123;    &quot;country&quot;: &quot;China&quot;,    &quot;city&quot;: &quot;Beijing&quot;  &#125;&#125;]\n\nwith open(&#x27;info.json&#x27;, encoding=&#x27;utf-8&#x27;) as f:    # buf = f.read()    # print(type(buf), buf)    result = json.load(f)    print(type(result))    for info in result:        print(info.get(&#x27;name&#x27;), info.get(&#x27;age&#x27;), info.get(&#x27;address&#x27;).get(&#x27;city&#x27;))\n\n\n测试读取案例[  &#123;    &quot;desc&quot;: &quot;正确的用户名密码&quot;,    &quot;username&quot;: &quot;admin&quot;,    &quot;password&quot;: &quot;123456&quot;,    &quot;expect&quot;: &quot;登录成功&quot;  &#125;,  &#123;    &quot;desc&quot;: &quot;错误的用户名&quot;,    &quot;username&quot;: &quot;root&quot;,    &quot;password&quot;: &quot;123456&quot;,    &quot;expect&quot;: &quot;登录失败&quot;  &#125;,  &#123;    &quot;desc&quot;: &quot;错误的密码&quot;,    &quot;username&quot;: &quot;admin&quot;,    &quot;password&quot;: &quot;123123&quot;,    &quot;expect&quot;: &quot;登录失败&quot;  &#125;,  &#123;    &quot;desc&quot;: &quot;错误的用户名和密码&quot;,    &quot;username&quot;: &quot;aaa&quot;,    &quot;password&quot;: &quot;123123&quot;,    &quot;expect&quot;: &quot;登录失败&quot;  &#125;]\n\n# 获取用户名、密码和预期结果，组成[(),(),()]格式（自动化参数化需要的格式）with open(&#x27;test.json&#x27;, encoding=&#x27;utf-8&#x27;) as f:    # buf = f.read()    # print(type(buf), buf)    result = json.load(f)    test_list = []    for info in result:        test_tuple = (info.get(&#x27;username&#x27;), info.get(&#x27;password&#x27;), info.get(&#x27;expect&#x27;))        test_list.append(test_tuple)    print(test_list)\n\n\njson的写入文件对象.write(字符串)不能直接将python的列表和字典作为参数传递。想要将python中的数据类型存为json文件，需要使用json提供的方法，不再使用write\n1. 导包 import json 2. 写(w)方式打开文件3. 写入json.dump(python中的数据类型,文件对象)\n\nimport jsonmy_list = [(&#x27;admin&#x27;, &#x27;123456&#x27;, &#x27;登录成功&#x27;), (&#x27;root&#x27;, &#x27;123456&#x27;, &#x27;登录失败&#x27;), (&#x27;admin&#x27;, &#x27;123123&#x27;, &#x27;登录失败&#x27;),           (&#x27;aaa&#x27;, &#x27;123123&#x27;, &#x27;登录失败&#x27;)]with open(&#x27;info1.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    # json.dump(my_list, f, ensure_ascii=False) #单行显示    # 显示缩进    json.dump(my_list, f, ensure_ascii=False,indent=2)\n\n\ndef dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True,        allow_nan=True, cls=None, indent=None, separators=None,        default=None, sort_keys=False, **kw)\n\n函数参数列表里，*后面的参数只能以关键字的形式传参，不能使用位置传参\n异常程序运行时，python解释器遇到一个错误，会停止程序的执行，并且提示一些错误信息，这就是异常。\n程序停止执行并且提示错误信息，这个动作是抛出异常（raise）。程序遇到异常，默认动作是终止代码程序的执行。捕获异常可以使代码继续执行，不会终止运行\n异常捕获try:    可能发生异常的代码except: # 任何类型的异常都能去捕获    发生了异常执行的代码   try:    可能发生异常的代码except 异常类型: # 只能捕获特定类型及其子类的异常，如果不是这个异常还是会报错    发生了异常执行的代码\n\nwhile True:    try:        num=input(&#x27;请输入数字&#x27;)        num=int(num)        print(num)    except:        print(&#x27;请输入正确数字&#x27;)    print(&#x27;后续代码仍然运行&#x27;)\n\n\n可以针对不同的异常错误，运行单独的代码处理\ntry:    可能发生的异常的代码except 异常类型1:    发生异常类型1执行的代码# Exception是常见异常类的父类，这里书写Exception可以捕获常见的所有异常，as 变量，变量是一个异常类的对象，print(变量)可以打印异常信息except Exception as 变量:    发生其他类型的异常，执行的代码else:    没有发生异常执行的代码finally:    不论如何都会执行的代码\n\ntry:    可能发生的异常的代码except Exception as e:    发生异常执行的代码\n\n\n\ntry:    num=input(&#x27;请输入数字&#x27;)    num=int(num)    num=20/num    print(num)except ValueError:    print(&#x27;发生了异常，请输入正确数字&#x27;)except ZeroDivisionError:    print(&#x27;不要输入0&#x27;)\n\n\ntry:    num=input(&#x27;请输入数字&#x27;)    num=int(num)    num=20/num    print(num)except Exception as e:    print(f&#x27;错误信息为：&#123;e&#125;&#x27;)else:    print(&quot;没有发生异常&quot;)finally:    print(&#x27;我都会执行&#x27;)\n\n异常传递python会将异常进行传递。在函数嵌套调用的过程中，被调用的函数发生了异常，如果没有捕获，会将这个异常向外层传递。如果传到最外层还没有捕获，才报错\n抛出异常raise让代码报错\n模块和包每一个以扩展名py结尾的python源代码文件都是一个模块。\n模块名同样也是一个标识符，需要符合标识符的命名规则\n在模块中定义的全局变量、函数、类都是提供给外界直接使用的工具\n模块就好比是工具包，要使用这个工具包的工具需要先导入这个模块\n自己写的代码想要作为模块使用，代码的名字需要满足标识符的规则\n模块的导入import导入使用模块中的内容：模块名.工具名\nimport 模块1名,模块2名# 使用模块中的内容：模块名.工具名# 举例import randomimport jsonrandom.randint(a,b)json.loadjson.dump\n\nfrom 模块名 import 工具名# 使用工具名# 举例from random import randintfrom json import load,dumprandint(a, b)load()dump()\n\n# 可能存在多个模块之间有名字相同的工具，会造成冲突from 模块名 import * # 将模块中的所有内容都导入# 举例from random import *from json import *randint(a, b)load()dump()\n\n对于导入的模块和工具可以使用as起别名，如果起别名，原来的名字就不能使用了\n模块的查找顺序在导入模块的时候，会先在当前目录中找模块，如果找到，就直接使用。如果没有找到，就回去系统的目录中进行查找，找到就直接使用，没有找到会报错\n注意：在定义代码文件的时候，代码名字不能和要导入的模块名字相同。\n# tool.pydef func():    print(&#x27;我是tools模块中的func方法&#x27;)class Dog:    def __init__(self, name, age):        self.name = name        self.age = age    def play(self):        print(f&#x27;&#123;self.name&#125;在快乐的玩耍&#x27;)######import toolstools.func()dog1 = tools.Dog(&#x27;大黄&#x27;, 3)dog1.play()\n\n\n__name__作用每个代码文件都是一个模块，在导入模块的时候，会执行模块中的方法。\n__name__变量：\n\n是python解释器自动维护的变量\n__name__ 变量，如果代码直接运行，值是&quot;__main__&quot;\n__name__ 变量，如果代码是被导入运行，值是模块名（代码名）\n\n包package在python中，包是一个目录，这个目录存在一个文件_init_.py（可以是空的）\n将功能相近或相似的代码放在一起。\n在python使用的时候不需要可以区分是包还是模块，因为使用方式是一样的\nrandom是一个模块json是一个包\nUnitTest框架是python中自带的单元测试框架。pytest是第三方框架，需要安装。\n对于开发来说，单元测试框架主要用来做单元测试。对测试来说，unittest框架的作用是自动化脚本（用例代码）执行框架，管理运行多个测试用例\n\n为什么使用UnitTest框架？\n能够组织多个用例去执行\n提供丰富的断言方法（让程序代码替人工自动的判断预期结果和实际结果是否相符）\n能够生成测试报告\n\n\n\nUnitTest核心(组成)\nTestCase（最核心的模块）\nTestCase（测试用例），是Unittest框架的组成部分，不是手工和自动化中说的用例（Test case）。\n主要作用：每个TestCase都是一个代码文件，在这个代码文件中书写真正的用例代码\n\nTestSuite\nTestSuite（测试套件），用来管理多个TestCase的\n\nTestRunner\nTestRunner（测试执行，测试运行），用来执行TestSuite（测试套件）\n\nTestLoader\nTestLoader（测试加载），对TestSuite（测试套件）功能的补充。自动搜索加载的一种方式。可以自动搜索指定开头的模块和指定开头的方法。\n\nFixture\nFixture（测试夹具），书写在TestCase代码中，是一个代码结构，可以在每个方法执行前后都会执行的内容（前置代码）\n\n\nTestCase(测试用例)在这个代码文件中书写真正的用例代码，代码文件的名字必须按照标识符的规则来书写\n步骤：\n\n导包（unittest）\n自定义测试类，新建测试类必须继承unittest.TestCase。运行的时候主模块是TestCase\n在测试类中书写测试方法，测试方法名称必须以test开头。\n执行用例\n\n&quot;&quot;&quot;学习TestCase模块的书写方法&quot;&quot;&quot;# 1. 导包（unittest）import unittest# 2. 自定义测试类,需要继承UnitTest模块中的TestCase类class TestDemo(unittest.TestCase):    # 3. 在测试类中书写测试方法,即用例代码。目前用print代替    # 测试方法必须以test 开头，_连接    def test_method1(self):        print(&#x27;测试方法1&#x27;)    def test_method2(self):        print(&#x27;测试方法2&#x27;)# 4. 执行用例# 4.1 将光标放在类名后边运行，会执行类中的所有测试方法# 4.2 将光标放在方法名后边运行，只执行当前的方法\n\n\nTestSuite&amp;TestRunnerTestSuite（测试套件）:管理、打包、组装TestCase（测试用例）文件\nTestRunner（测试执行，测试运行）:执行TestSuite（测试套件）\n步骤：\n\n导包（unittest）\n实例化（创建对象）套件对象\n使用套件对象添加用例方法\n实例化运行对象\n使用运行对象去执行套件对象\n\n&quot;&quot;&quot;用来学习testsuite和testrunner&quot;&quot;&quot;# 1. 导包（unittest）import unittestfrom day1.testcase1 import TestDemo1from day1.testcase2 import TestDemo2# 2. 实例化（创建对象）套件对象suite=unittest.TestSuite()# 3. 使用套件对象添加用例方法# 方式一：套件对象.addtest(测试类名(&#x27;方法名&#x27;)),建议直接复制相关名字suite.addTest(TestDemo1(&#x27;test_method1&#x27;))suite.addTest(TestDemo1(&#x27;test_method2&#x27;))suite.addTest(TestDemo2(&#x27;test_method1&#x27;))suite.addTest(TestDemo2(&#x27;test_method2&#x27;))# 方法二：添加一个类里所有以test开头的方法suite.addTest(unittest.makeSuite(ClassName))# 4. 实例化运行对象runner=unittest.TextTestRunner()# 5. 使用运行对象去执行套件对象# 运行对象.run(套件对象)runner.run(suite)\n\n\n&quot;&quot;&quot;用来学习testsuite和testrunner&quot;&quot;&quot;# 1. 导包（unittest）import unittestfrom day1.testcase1 import TestDemo1from day1.testcase2 import TestDemo2# 2. 实例化（创建对象）套件对象suite = unittest.TestSuite()# 3. 使用套件对象添加用例方法# 方法二：将一个测试类中的所有方法添加，套件对象.addTest(unittest.makeSuite(测试类名)))# 缺点：makeSuite()不会提示suite.addTest(unittest.makeSuite(TestDemo1))suite.addTest(unittest.makeSuite(TestDemo2))# 4. 执行测试套件runner = unittest.TextTestRunner()# 5. 使用运行对象去执行套件对象# 运行对象.run(套件对象)runner.run(suite)\n\n\n运行结果中的.表示用例通过，F表示用例不通过（运行结果和预期结果不符合），E代表用例代码有问题\n\nTestLoader（测试加载）TestLoader（测试加载）和TestSuite作用是一样的，对TestSuite功能的补充，用来组装测试用例。如果TestCase的代码文件有很多，可以使用TestLoader\n步骤\n\n导包\n实例化测试加载对象并添加用例，得到的是Suite对象\n实例化运行对象\n运行对象执行套件对象\n\n在一个项目中TestCase的代码一般放在一个单独的目录（case）\n# 1. 导包import unittest# 2. 实例化加载对象并添加用例# unittest.TestLoader().discover(&#x27;用例所在的路径&#x27;,&#x27;用例的代码文件名&#x27;)# 用例所在的路径建议使用相对路径，用例的代码文件名可以使用*（任意多个任意字符）通配符。defaultTestLoader = unittest.TestLoader()suite = unittest.TestLoader().discover(&#x27;./case&#x27;, &#x27;*.py&#x27;)# 3. 实例化运行对象runner = unittest.TextTestRunner()# 4. 执行runner.run(suite)# 可以将3、4步变为1步unittest.TextTestRunner().run(suite)\n\n\n\nTestLoader与TestSuite区别\n\nTestSuite需要手动添加测试用例（可以添加测试类，也可以添加测试类中的某个方法\nTestLoader搜索指定目录下指定开头.py文件并添加测试类中的以test开头的所有的测试方法，不能指定添加方法\n\n\nFixture（测试夹具）是一个概述，对一个测试用例环境的初始化和销毁就是一个Fixture。在某些特点的情况下会自动去执行\n方法级别在每个测试方法（用例代码）执行前后都会自动调用的结构\n# 方法执行之前def setup(self):    # 每个测试方法执行之前都会执行    pass# 方法执行之后def teardown(self):    # 每个测试方法执行之后都会执行    pass\n\n\n\n类级别在每个测试类中所有方法执行前后都会自动调用的结构（整个类中前后各一次）\n类级别的Fixture方法是一个类方法\n# 类中所有方法之前@classmethoddef setupClass(cls):    pass# 类中所有方法之后@classmethoddef teardownClass(cls):    pass\n\n\n\n模块级别在每个代码文件执行前后执行的代码结构，需要写在类的外面，直接定义函数即可\n# 代码文件之前def setupModule():    pass# 代码文件之后def teardownModule():    pass\n\n方法级别和类级别的前后方法不需要同时出现，根据用例代码的需要自行的选择使用\n登录案例import unittestfrom day1.login_1 import loginclass LoginTest(unittest.TestCase):    def setUp(self):        &quot;&quot;&quot;每个测试方法执行之前都会先调用的方法&quot;&quot;&quot;        print(&#x27;输入网址...&#x27;)    def tearDown(self):        &quot;&quot;&quot;每个测试方法执行之后都会先调用的方法&quot;&quot;&quot;        print(&#x27;关闭网站...&#x27;)    def test_username_password_ok(self):        print(&#x27;输入正确用户名和密码点击登录1&#x27;)        if login(&#x27;admin&#x27;, &#x27;123456&#x27;) == &#x27;登录成功&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    @classmethod    def setUpClass(cls):        print(&#x27;1. 打开浏览器&#x27;)    @classmethod    def tearDownClass(cls):        print(&#x27;5. 关闭浏览器&#x27;)    def test_username_error(self):        print(&#x27;输入错误用户名和密码点击登录2&#x27;)        if login(&#x27;root&#x27;, &#x27;123456&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_password_error(self):        if login(&#x27;admin&#x27;, &#x27;123123&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_username_password_error(self):        if login(&#x27;aaa&#x27;, &#x27;123123&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)\n\n\n测试add&quot;&quot;&quot;学习TestCase模块的书写方法&quot;&quot;&quot;# 1. 导包（unittest）import unittestimport tools# 2. 自定义测试类,需要继承UnitTest模块中的TestCase类class TestAdd(unittest.TestCase):    def test_method1(self):        if tools.add(1, 2)==3:            print(&#x27;测试通过&#x27;)        else:            print(&#x27;测试不通过&#x27;)    def test_method2(self):        if tools.add(10,20)==30:            print(&#x27;测试通过&#x27;)        else:            print(&#x27;测试不通过&#x27;)    def test_method3(self):        if tools.add(2, 3)==5:            print(&#x27;测试通过&#x27;)        else:            print(&#x27;测试不通过&#x27;)\n\n\nlogin函数测试def login(username,password):    if username ==&#x27;admin&#x27; and password==&#x27;123456&#x27;:        return &#x27;登录成功&#x27;    else:        return &#x27;登录失败&#x27;\n\nimport unittestfrom day1.login_1 import loginclass LoginTest(unittest.TestCase):    def test_username_password_ok(self):        if login(&#x27;admin&#x27;, &#x27;123456&#x27;) == &#x27;登录成功&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_username_error(self):        if login(&#x27;root&#x27;, &#x27;123456&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_password_error(self):        if login(&#x27;admin&#x27;, &#x27;123123&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)    def test_username_password_error(self):        if login(&#x27;aaa&#x27;, &#x27;123123&#x27;) == &#x27;登录失败&#x27;:            print(&#x27;pass&#x27;)        else:            print(&#x27;fail&#x27;)\n\n\n断言让程序代替人工自动判断预期结果和实际结果是否相符\n断言的结果：True-&gt;用例通过，False-&gt;代码抛出异常，用例不通过\npython自带的断言，判断两个字符串是否相等assert &quot;hello&quot; == &quot;hello&quot; assert &quot;hello&quot;==&quot;hello1&quot; &quot;出错啦&quot;\n判断是否包含assert &quot;h&quot; in &quot;hello&quot;\n判断是否为True、False assertTrue assert1 assertFalse assert0\n在unittest中使用断言，都需要通过self.断言方法来试验\nassertEqualassertEqual(预期结果,实际结果)，判断预期结果和实际结果是否相等\n如果相等，用例通过；如果不相等，用例不通过，抛出异常\nimport unittestfrom day1.login_1 import loginclass LoginTest(unittest.TestCase):    def test_username_password_ok(self):        self.assertEqual(&#x27;登录成功&#x27;,login(&#x27;admin&#x27;, &#x27;123456&#x27;))    def test_username_error(self):        self.assertEqual(&#x27;登录失败&#x27;,login(&#x27;root&#x27;, &#x27;123456&#x27;) )    def test_password_error(self):        self.assertEqual(&#x27;登录失败&#x27;, login(&#x27;admin&#x27;, &#x27;123123&#x27;))    def test_username_password_error(self):        self.assertEqual(&#x27;登录失败&#x27;, login(&#x27;aaa&#x27;, &#x27;123123&#x27;))\n\n\n失败：\n\nassertInassertIn(预期结果,实际结果)判断预期结果是否包含于实际结果\n如果包含，用例通过；如果不不包含，用例不通过，抛出异常\nassertTrueassertTrue(ex)判断ex是否为True\n参数化解决相同业务逻辑，不同业务数据\n在测试方法中，使用变量代替具体的测试数据，使用传参的方法将测试数据传递给方法的变量，可以减少相似代码的书写。测试数据一般放在json文件中，使用代码读取json文件，提取要的数据[(),(),()],[[],[]]\nunittest框架本身不支持参数化，需要安装插件完成\n1. 导包 unittest/parameterized2. 定义测试类3. 书写测试方法(用到的测试数据使用变量来代替)4. 组织测试数据并传参\n\nlogin_1代码:\ndef login(username,password):    if username ==&#x27;admin&#x27; and password==&#x27;123456&#x27;:        return &#x27;登录成功&#x27;    else:        return &#x27;登录失败&#x27;\n\n# 1. 导包 unittest/parameterizedimport unittestfrom parameterized import parameterizedfrom day1.login_1 import login# 组织测试数据,按位置传参data = [    (&#x27;admin&#x27;, &#x27;123456&#x27;, &#x27;登录成功&#x27;),    (&#x27;root&#x27;, &#x27;123456&#x27;, &#x27;登录失败&#x27;),    (&#x27;admin&#x27;, &#x27;123123&#x27;, &#x27;登录失败&#x27;),    (&#x27;root&#x27;, &#x27;123123&#x27;, &#x27;登录失败&#x27;)]  # 几组数据就有几组用例# 2. 定义测试类class TestLogin(unittest.TestCase, ):    # 4. （装饰器@修饰方法）组织测试数据并传参（列表类型,多个参数为列表嵌套元组）    @parameterized.expand(data)    # 3. 书写测试方法(用到的测试数据使用变量来代替)按位置传参    def test_login(self, username, password, expect):        self.assertEqual(expect, login(username, password))\n\n\n通过json导入# 1. 导包 unittest/parameterizedimport unittestfrom parameterized import parameterizedimport jsonfrom day1.login_1 import login# 组织测试数据,按位置传参def build_data():    with open(&#x27;test.json&#x27;, encoding=&#x27;utf-8&#x27;) as f:        res = json.load(f)        data = []        for i in res:            testtuple = (i.get(&#x27;username&#x27;), i.get(&#x27;password&#x27;), i.get(&#x27;expect&#x27;))            data.append(testtuple)        return data# 2. 定义测试类class TestLogin(unittest.TestCase, ):    # 4. 组织测试数据并传参（装饰器@）    @parameterized.expand(build_data())    # 3. 书写测试方法(用到的测试数据使用变量来代替)    def test_login(self, username, password, expect):        self.assertEqual(expect, login(username, password))\n\n\n跳过对于一些未完成的或者不满足测试条件的测试函数和测试类可以跳过执行，使用装饰器完成。代码书写在TestCase中\n# 直接将测试函数标记为跳过@unittest.skip(&#x27;跳过原因&#x27;)# 根据条件判断测试函数是否跳过，判断条件成立跳过@unittest.skipIf(condition, reason)# 跳过可以用来修饰类\n\nimport unittestversion = 30class TestDemo(unittest.TestCase):    @unittest.skip(&#x27;没有什么原因就是不想执行&#x27;)    def test_1(self):        print(&#x27;method 1&#x27;)    @unittest.skipIf(version &gt;= 30, &#x27;版本号新，不用测试&#x27;)    def test_2(self):        print(&#x27;method 2&#x27;)    def test_3(self):        print(&#x27;method 3&#x27;)\n\n\n测试报告自带的测试报告：只有单独运行TestCase的代码才能生成测试报告，组装打包的测试用例不能生成\nHTMLTestRunner是一个类库，生成第三方的的测试报告需要用到。\n\n获取第三方的测试运行模块，将其放在代码的目录中\n导包\n使用套件对象，加载对象添加用例方法\n实例化第三方的运行对象并运行套件\n\n组织用例文件（TestCase），书写参数化，书写断言，书写Fixture，书写跳过，如果单个测试文件直接运行，得到测试报告，如果有多个测试文件需要使用套件对象组装、加载对象组装运行生成测试报告。接下来要运行对象，使用第三方运行类进行运行。运行对象.run(套件对象)\n# 1. 获取第三方的测试运行模块，将其放在代码的目录中# 2. 导包import unittestfrom HtmlTestRunner import HTMLTestRunner# 3. 使用套件对象，加载对象添加用例方法suite = unittest.defaultTestLoader.discover(&#x27;.&#x27;, &#x27;parametertest.py&#x27;)# 4. 实例化第三方的运行对象并运行套件  # 测试报告的文件对象（open）要使用wb打开（二进制方法书写）HTMLTestRunner().run(suite)  # 运行对象\n\nunittest自带报告：\n\nhtml报告：\n\n","categories":["Python Learning"],"tags":["Python"]},{"title":"Web自动化","url":"/2024/03/12/Web%E8%87%AA%E5%8A%A8%E5%8C%96/","content":"自动化测试解决的问题：回归测试、压力测试、兼容性测试。\n自动化测试的误区：自动化测试可以完全代替手工测试，自动化测试一定比手工测试更厉害，自动化测试可以捕获更多的bug，自动化测试适用于所有功能\n\n什么样的web项目适合做自动化测试？\n\n需求变动不频繁\n项目周期长\n项目需要回归测试\n\n\n自动化测试在什么阶段开始–&gt;功能测试完毕（手工测试）\n\nweb自动化属于黑盒测试（功能测试）\n\n元素定位元素定位就是通过元素的信息或元素层级结构来定义结构\nselenium提供的吧主定位元素方式\n1. id2. name3. class_name4. tag_name(&lt;标签名.../&gt;)5. link_text(定位超链接a标签)6. partial_link_text(定位超链接a标签 模糊)7. XPath(基于元素路径)8. CSS(元素选择器)\n\nid定位html规定id属性在整个html文档中必须是唯一的\nel=driver.find_element(by=By.ID, value=&#39;id值&#39;)\n打开百度输入内容进行查询\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()# 打开urlbrowser.get(&quot;https://www.baidu.com&quot;)# 通过id定位搜索框el = browser.find_element(by=By.ID, value=&#x27;kw&#x27;)# 搜索框输入内容el.send_keys(&#x27;怪物猎人&#x27;)# 通过id查找搜索按钮并点击browser.find_element(by=By.ID, value=&#x27;su&#x27;).click()time.sleep(20)browser.quit()\n\n\nname定位html中name属性值是可以重复的\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get(&quot;https://www.baidu.com&quot;)browser.find_element(by=By.NAME,value=&#x27;wd&#x27;).clear()el = browser.find_element(by=By.NAME, value=&#x27;wd&#x27;)el.send_keys(&#x27;索尼&#x27;)browser.find_element(by=By.ID, value=&#x27;su&#x27;).click()time.sleep(20)browser.quit()\n\n\nclass name定位根据元素class属性值定位元素，html通过class来定义元素的样式。如果class有多个属性值，只使用其中一个\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get(&quot;https://www.bilibili.com/&quot;)browser.find_element(by=By.CLASS_NAME, value=&#x27;channel-link&#x27;).click()time.sleep(20)browser.quit()\n\n\n\n查找第二个\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get(&quot;https://www.bilibili.com/&quot;)browser.find_elements(by=By.CLASS_NAME, value=&#x27;channel-link&#x27;)[2].click()time.sleep(20)browser.quit()\n\n\ntag_name定位通过标签名来定位，一般有多个。如果存在多个相同标签则返回第一个\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bydr = webdriver.Chrome()dr.get(&#x27;https://www.csdn.net/&#x27;)dr.find_elements(By.TAG_NAME, &#x27;dl&#x27;)[0].click()time.sleep(20)\n\n\nlink_text定位a标签，link_text定位元素的内容必须全部匹配（不然会报错）\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Byimport timebrowser = webdriver.Chrome()browser.get(&#x27;https://rinta.top/&#x27;)browser.find_element(By.LINK_TEXT,&#x27;Python&#x27;).click()time.sleep(20)\n\n\npartial_link_text模糊匹配linktext定位找到元素，但是要保证唯一性\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Byimport timebrowser = webdriver.Chrome()browser.get(&#x27;https://rinta.top/&#x27;)browser.find_element(By.LINK_TEXT,&#x27;Python&#x27;).click()time.sleep(5)browser.find_element(By.PARTIAL_LINK_TEXT,&#x27;AR&#x27;).click()time.sleep(20)\n\n\nXpathxpath是XML路径定位器，HTML与XML相似，所以也可以用xpath来定位。针对定位到多个元素时也可以下标取值，下标从1开始\n//*[text()=&quot;xxx&quot;]     # 文本内容是xxx的元素//*[contains(@attribute,&#x27;xxx&#x27;)] # 属性中含有xxx的元素//*[starts-with(@attribute,&#x27;xxx&#x27;)] # 属性以xxx开头的元素\n\n\n\n\n\n\n表达式\n描述\n\n\n\nnodename\n选取此节点的所有子节点\n\n\n&#x2F;\n从当前节点选取直接子节点\n\n\n&#x2F;&#x2F;\n从当前节点选取子孙节点\n\n\n.\n选取当前节点\n\n\n. .\n选取当前节点的父节点\n\n\n@\n选取属性\n\n\n*\n任何元素\n\n\n通过路径定位绝对路径：以&#x2F;开头，不能跳级\n相对路径：以&#x2F;&#x2F;开头，后跟元素名称，不知道名称可以用*代替（*代表所有元素）\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Bydr = webdriver.Chrome()dr.get(&#x27;https://www.bilibili.com/&#x27;)dr.find_element(By.XPATH, value=&#x27;//*[@id=&quot;i_cecream&quot;]/div[2]/div[1]/div[3]/div[2]/div[1]/a[8]&#x27;).click()# @为添加属性,//开头为相对路径time.sleep(20)\n\n\n\n利用元素属性dr.find_element(By.XPATH, value=&#39;//*[@id=&quot;i_cecream&quot;]/div[2]/div[1]/div[3]/div[2]/div[1]/a[8]&#39;).click()# @修饰属性\n属性和逻辑结合通过and连接两个属性\n//*[@id=&#39;id值&#39; and @属性=&#39;属性值&#39;]\n层级与属性结合//*[@id=&#39;父级id值&#39; ]/input\ncss选择器css用来描述html元素的显示样式，在css中，选择题是一种模式用于选择需要添加样式的元素。\ncss定位常用策略：id选择器、class选择器、元素选择器、属性选择器、层级选择器\n符号.代表class, 符号 # 代表id\n# id选择器# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()# 打开urlbrowser.get(&quot;https://www.baidu.com&quot;)# 通过css定位搜索框,#代表idel = browser.find_element(by=By.CSS_SELECTOR, value=&#x27;#kw&#x27;)# 搜索框输入内容el.send_keys(&#x27;怪物猎人&#x27;)time.sleep(20)browser.quit()\n\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()# 打开urlbrowser.get(&quot;https://www.bilibili.com/&quot;)# 通过css定位搜索框,#代表idel = browser.find_element(by=By.CSS_SELECTOR, value=&#x27;#i_cecream &gt; div.bili-feed4 &gt; div.bili-header.large-header &gt; div.bili-header__channel &gt; div.right-channel-container &gt; div.channel-items__left &gt; a:nth-child(6)&#x27;)# 搜索框输入内容el.click()time.sleep(20)browser.quit()\n\n\n\n定位下拉框通过css定位# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()browser.implicitly_wait(10)browser.get(&quot;https://www.ke.com/city/&quot;)time.sleep(5)time.sleep(3)# 找到下拉框元素el = browser.find_elements(By.CSS_SELECTOR, value=&#x27;.chang-city&#x27;)[0]el.click()# []来指定属性值time.sleep(3)browser.find_element(By.CSS_SELECTOR, &#x27;[data-province_id=&quot;130000&quot;]&#x27;).click()time.sleep(10)browser.quit()\n\n\n通过select类定位# value# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()browser.implicitly_wait(10)browser.get(    &quot;https://signup.live.com/signup?lcid=1033&amp;wa=wsignin1.0&amp;rpsnv=13&amp;ct=1667977589&amp;rver=7.0.6737.0&amp;wp=MBI_SSL&amp;wreply=https%3a%2f%2foutlook.live.com%2fowa%2f%3fnlp%3d1%26signup%3d1%26RpsCsrfState%3d03e6f63b-7b44-e3a7-1cec-67445341a6de&amp;id=292841&amp;CBCXT=out&amp;lw=1&amp;fl=dob%2cflname%2cwld&amp;cobrandid=90015&amp;lic=1&amp;uaid=5cd6f6e2004b4d5f96bcb3f20e670a07&quot;)time.sleep(5)browser.find_element(By.CSS_SELECTOR, value=&#x27;#iSignupAction&#x27;).click()time.sleep(3)# # 找到下拉框元素el = browser.find_element(By.CSS_SELECTOR, value=&#x27;#LiveDomainBoxList&#x27;)# 使用value属性定位下拉框Select(el).select_by_value(&#x27;hotmail.com&#x27;)time.sleep(10)browser.quit()\n\n\n# index# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()browser.implicitly_wait(10)browser.get(    &quot;https://signup.live.com/signup?lcid=1033&amp;wa=wsignin1.0&amp;rpsnv=13&amp;ct=1667977589&amp;rver=7.0.6737.0&amp;wp=MBI_SSL&amp;wreply=https%3a%2f%2foutlook.live.com%2fowa%2f%3fnlp%3d1%26signup%3d1%26RpsCsrfState%3d03e6f63b-7b44-e3a7-1cec-67445341a6de&amp;id=292841&amp;CBCXT=out&amp;lw=1&amp;fl=dob%2cflname%2cwld&amp;cobrandid=90015&amp;lic=1&amp;uaid=5cd6f6e2004b4d5f96bcb3f20e670a07&quot;)time.sleep(5)browser.find_element(By.CSS_SELECTOR, value=&#x27;#iSignupAction&#x27;).click()time.sleep(3)# # 找到下拉框元素el = browser.find_element(By.CSS_SELECTOR, value=&#x27;#LiveDomainBoxList&#x27;)# 使用index属性定位下拉框Select(el).select_by_index(1)time.sleep(10)browser.quit()\n\n# visible_text# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()browser.implicitly_wait(10)browser.get(    &quot;https://signup.live.com/signup?lcid=1033&amp;wa=wsignin1.0&amp;rpsnv=13&amp;ct=1667977589&amp;rver=7.0.6737.0&amp;wp=MBI_SSL&amp;wreply=https%3a%2f%2foutlook.live.com%2fowa%2f%3fnlp%3d1%26signup%3d1%26RpsCsrfState%3d03e6f63b-7b44-e3a7-1cec-67445341a6de&amp;id=292841&amp;CBCXT=out&amp;lw=1&amp;fl=dob%2cflname%2cwld&amp;cobrandid=90015&amp;lic=1&amp;uaid=5cd6f6e2004b4d5f96bcb3f20e670a07&quot;)time.sleep(5)browser.find_element(By.CSS_SELECTOR, value=&#x27;#iSignupAction&#x27;).click()time.sleep(3)# # 找到下拉框元素el = browser.find_element(By.CSS_SELECTOR, value=&#x27;#LiveDomainBoxList&#x27;)# 使用visible_text属性定位下拉框Select(el).select_by_visible_text(&#x27;hotmail.com&#x27;)time.sleep(3)Select(el).select_by_visible_text(&#x27;outlook.com&#x27;)time.sleep(10)browser.quit()\n\n警告框处理Selenium中对处理弹出框的操作，有专用的处理方法，并且处理方式都一样\n1. 获取弹出框对象alert=driver.switch_to.alert2. 调用alert.txt                ---&gt; 返回alert/confirm/prompt中文字信息alert.accept()           ---&gt;接受对话框选项alert.dismiss()          ---&gt;取消对话框选项\n\naler警告框# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()browser.implicitly_wait(20)# 访问urlbrowser.get(&quot;https://www.runoob.com/try/try.php?filename=tryjs_alert&quot;)time.sleep(5)# 点击运行按钮browser.switch_to.frame(&quot;iframeResult&quot;)browser.find_element(By.CSS_SELECTOR, &#x27;[value=&quot;显示警告框&quot;]&#x27;).click()time.sleep(3)# 切换到alert框内alert = browser.switch_to.alert  # 返回alert对话框对象# 获取文本print(alert.text)# 点击确定alert.accept()time.sleep(10)browser.quit()\n\n\nconfirm确认框prompt提示框元素操作.click()单机输入\nclear()清楚文本\nsendkeys()模拟输入，如果要上传本地文件也使用这个\n获取元素信息的常用方法size 返回元素大小\ntext 获取元素文本\nget_attribute(&quot;xxx&quot;) 获取属性值，传递到参数为元素的属性名\nis_displayed() 判断元素是否可见\nis_enabled() 判断元素是否可用\nis_selected() 判断元素是否选择，用来检查复选框或者单选按钮是否被选中\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.bilibili.com/&quot;)#200x32# print(browser.find_element(By.CSS_SELECTOR,value=&#x27;nav-search-content&#x27;).size)time.sleep(2)el1=browser.find_element(By.CSS_SELECTOR,value=&#x27;.nav-search-input&#x27;)el1.send_keys(&#x27;python&#x27;)time.sleep(3)browser.refresh()el=browser.find_elements(By.CSS_SELECTOR,value=&#x27;.channel-link&#x27;)[0]print(el.text)time.sleep(3)# 打印a元素的href属性print(el.get_attribute(&#x27;href&#x27;))el.click()time.sleep(3)# 判断元素是否可见el2=browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[3]print(el2.is_displayed())time.sleep(3)if el2.is_displayed():    el2.click()time.sleep(3)# 判断元素是否可用el3=browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[4]print(el3.is_enabled())if el3.is_enabled():    el3.click()time.sleep(3)# 关闭主窗口browser.close()time.sleep(5)browser.quit()\n\n\n浏览器常用操作APImaximize_window()最大化浏览器窗口\nset_window_size(width,height)设置浏览器窗口大小\nset_window_position设置浏览器窗口位置\nback()模拟浏览器后退\nforward()前进\nrefresh()刷新，在cookie中使用到\nclose()关闭当前窗口\nquit()关闭浏览器驱动对象（会关闭所有窗口）\ntitle获取页面title\ncurrent_url获取当前页面url\n# 实现前进后退# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()# 设置窗口位置browser.set_window_position(320,150)time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.baidu.com/&quot;)browser.get(&quot;https://www.bilibili.com/&quot;)time.sleep(2)# 执行后退browser.back()time.sleep(2)# 执行前进browser.forward()time.sleep(2)browser.quit()\n\n关闭的窗口是创建的主窗口\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.bilibili.com/&quot;)#200x32# print(browser.find_element(By.CSS_SELECTOR,value=&#x27;nav-search-content&#x27;).size)time.sleep(2)el1=browser.find_element(By.CSS_SELECTOR,value=&#x27;.nav-search-input&#x27;)el1.send_keys(&#x27;python&#x27;)time.sleep(3)browser.refresh()el=browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[1]time.sleep(2)el.click()print(browser.current_url)time.sleep(2)browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[3].click()time.sleep(3)browser.find_elements(By.CLASS_NAME,value=&#x27;channel-link&#x27;)[4].click()time.sleep(3)# 关闭主窗口browser.close()time.sleep(5)browser.quit()\n\n\n\n\n\n鼠标和键盘操作鼠标操作click()是元素的事件，不是鼠标的事件。在selenium中操作鼠标的方法封装在ActionChains类中\n实例化对象：action=ActionChains(driver)\n方法：\ncontext_click(element) 右击\ndouble_click(element)双击\ndrag_and_drop(source,target) 拖动\nmove_to_element悬停\nperform()执行以上所有鼠标操作，所有的方法都需要执行才生效\nel1 = browser.find_element(By.CSS_SELECTOR, value=&#x27;.nav-search-input&#x27;)# 右击鼠标action.context_click(el1).perform()el1.send_keys(&#x27;python&#x27;)time.sleep(3)# 双击action.double_click(el1).perform()time.sleep(3)browser.refresh()el2 = browser.find_element(By.CSS_SELECTOR, value=&#x27;.download-client-trigger__icon&#x27;)# 悬停time.sleep(3)action.move_to_element(el2).perform()time.sleep(5)browser.quit()\n\n拖拽：\n# 导包from selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlaction = ActionChains(browser)browser.get(&quot;https://www.baidu.com/&quot;)time.sleep(2)el1 = browser.find_element(By.CSS_SELECTOR, value=&#x27;.title-content-title&#x27;)el2=browser.find_element(By.CSS_SELECTOR,value=&#x27;#kw&#x27;)time.sleep(3)action.drag_and_drop(el1,el2).perform()time.sleep(3)browser.find_element(By.CSS_SELECTOR,value=&#x27;#su&#x27;).click()time.sleep(5)browser.quit()\n\n\ndrag_and_drop_by_offset(source,xoffset,yoffset)通过坐标偏移量执行拖拽\n实例化匿名：ActionChains(driver).double_click(element).perform()\n实名：action=ActionChains(driver)\n键盘操作常用的键盘操作：\nsend_keys(Keys.BACK_SPACE)  删除键\nsend_keys(Keys.SPACE)  空格键\nsend_keys(Keys.TAB)  制表键\nsend_keys(keys.ESCAPE) 回退键\nsend_keys(keys.ENTER)  回车键\nsend_keys(keys.CONTROL,&#39;a&#39;) ctrl+a\nsend_keys(keys.CONTROL,&#39;c&#39;) ctrl+c\nimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlaction = ActionChains(browser)browser.get(&quot;https://www.baidu.com/&quot;)time.sleep(2)el1 = browser.find_element(By.CSS_SELECTOR, value=&#x27;#kw&#x27;)time.sleep(3)el1.send_keys(&#x27;Python1&#x27;)time.sleep(3)el1.send_keys(Keys.BACK_SPACE)time.sleep(3)el1.send_keys(Keys.CONTROL, &#x27;a&#x27;)time.sleep(3)el1.send_keys(Keys.CONTROL, &#x27;c&#x27;)time.sleep(3)# 粘贴el1.send_keys(Keys.CONTROL, &#x27;v&#x27;)el1.send_keys(Keys.CONTROL, &#x27;v&#x27;)browser.find_element(By.CSS_SELECTOR, value=&#x27;#su&#x27;).click()time.sleep(5)browser.quit()\n\n\n元素等待在定位页面元素如果未找到，会在指定时间内一直等待的过程。在设置的时长内加载出来，会执行代码；没有加载出来则抛出异常\n为什么要设置元素等待？网络速度慢、电脑配置低、服务器处理请求慢\n隐式等待隐式等待为全局设置，设置一次，对作用于所有元素。一般为前置必写代码\n定位元素时，如果能定位到元素则直接返回该元素，不触发等待；如果不能定位到该元素，则间隔一段时间后再去定位元素；如果在达到最大时长时还没有找到指定元素，则抛出元素不存在的异常NoSuchElementException\n方法：driver.implicitly_wait(timeout),timeout为等待最大时长，单位秒。\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.baidu.com/&quot;)# 设置隐式等待10sbrowser.implicitly_wait(10)time.sleep(2)# 正确id为kwel1 = browser.find_element(By.CSS_SELECTOR, value=&#x27;#kj&#x27;)el1.send_keys(&#x27;python&#x27;)\n\n\n显式等待对单个的元素有效\n定位元素时，如果能定位到元素则直接返回该元素，不触发等待；如果不能定位到该元素，则间隔一段时间后再去定位元素；如果在达到最大时长时还没有找到指定元素，则抛出超时异常TimeoutException\n1. 导包2. webDriverWait(driver, timeout, poll_frequency=0.5) 1) driver: 浏览器驱动对象 2) timeout: 超时的时长单位秒 3) poll_frequency: 检测间隔时间，默认0.5s3. 调用方法 until(method):直到...时 1) method: 函数名称，该函数用来实现对元素的定位 2) 一般使用匿名函数来实现：lambda x: x.find_element(By.,value)4. element = WebDriverWait(driver, 10, 1).util(lambda x: x.find_element(By.,value))\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.wait import WebDriverWait# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 打开urlbrowser.get(&quot;https://www.baidu.com/&quot;)# 设置显式等待10s# 正确id为kwel = WebDriverWait(browser, 10, poll_frequency=0.5).until(lambda x: x.find_element(By.CSS_SELECTOR, value=&#x27;#kj&#x27;))# 此时el还不是元素，代码运行起来才是el.send_keys(&#x27;python&#x27;)\n\n\n区别\n显示等待针对单个元素生效，隐式等待针对全局元素生效\n\n滚动条操作html页面元素为动态显示，元素根据滚动条的下拉而加载。\nSelenium没有提供操作滚动条的方法，但是提供了可执行JS脚本的方法，我们通过JS脚本来达到操作滚动条的目的\n1. 设置JS脚本控制滚动条\tjs = &quot;window.scrpllTo(0,1000)&quot;\t(0:左边距;1000:上边距 单位:像素)2. selenium调用JS脚本的方法\tdriver.execute_scrip(js)\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.support.select import Select# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https:rinta.top&quot;)time.sleep(5)# 设置js控制语句js = &quot;window.scrollTo(0,10000)&quot;# 滚动条下拉browser.execute_script(js)time.sleep(3)time.sleep(10)browser.quit()\n\n\nframe切换frame是html页面中的一种框架，主要作用是在当前页面的指定区域显示零一页面元素\n形式一：&lt;frameset cols=&quot;25%,75%&quot;&gt;    &lt;frame src=&quot;frame_a.htm&quot;&gt;&lt;/frame&gt;\t&lt;fram src=&quot;frame_.htm&quot;&gt;&lt;/fram&gt;&lt;/frameset&gt;形式二：&lt;iframe name=&quot;iframe_a&quot; src=&quot;demo_iframe.htm&quot; width=&quot;200&quot;,height=&quot;200&quot;&gt;&lt;/iframe&gt;\n\nframe切换方法1. 切换到指定frame的方法，frame_reference可以为frame框架的name、id或者定位到的frame元素driver.switch_to.frame(frame_reference)   2. 恢复默认页面,在frame中操作其他页面一定要切换到默认页面driver.switch_to.default_content()\n\n窗口切换Selenium的默认焦点是在主窗口。在selenium中封装了获取当前窗口的句柄、获取所有窗口句柄和切换到指定句柄窗口的方法\n句柄：handle，窗口的唯一识别码\n# 获取当前窗口句柄driver.current_window_handle  # 获取所有窗口句柄driver.window_handles# 切换指定句柄窗口driver.switch_to.window(handle)\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https://www.baidu.com/&quot;)time.sleep(5)# 输入内容并查询browser.find_element(By.CSS_SELECTOR, &#x27;#kw&#x27;).send_keys(&#x27;小润&#x27;)browser.find_element(By.CSS_SELECTOR, &#x27;#su&#x27;).click()time.sleep(3)ch = browser.current_window_handleprint(ch)# 点击词条browser.find_element(By.CSS_SELECTOR, &#x27;._around-mask_bo7t2_14&#x27;).click()# 获取所有窗口句柄handles = browser.window_handlesprint(handles)time.sleep(3)for handle in handles:    # 切换窗口    if handle != ch:        browser.switch_to.window(handle)        browser.find_elements(By.CSS_SELECTOR, &#x27;.innerLink_UCdov&#x27;)[1].click()time.sleep(10)browser.quit()\n\n\n\n窗口截图与验证码窗口截图在执行出错的时候对当前窗口截图保存，可以通过图片直观地看到出错的原因\ndriver.get_screenshot_as_file(imgpath)\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https://www.baidu.com/&quot;)time.sleep(5)# 输入内容并查询browser.find_element(By.CSS_SELECTOR, &#x27;#kw&#x27;).send_keys(&#x27;小润&#x27;)browser.find_element(By.CSS_SELECTOR, &#x27;#su&#x27;).click()time.sleep(3)# 截图browser.get_screenshot_as_file(&#x27;./screenshot.png&#x27;)time.sleep(10)browser.quit()\n\n\n根据时间戳获取截图：\nbrowser.get_screenshot_as_file(&#39;./&#123;&#125;.png&#39;.format(time.strftime(&quot;%Y_%m_%d_%H_%M_%S&quot;)))\n\n验证码selenium中没有对验证码处理的方式\n\n去掉验证码（测试环境下采用）\n设置万能验证码（生产环境和测试环境下采用）\n验证码识别技术（通过Python-tesseract来识别图片类型验证码，识别率很难达到100%）\n记录cookie（通过cookie进行跳过登录）\n\ncookie\ncookie是由web服务器生成的，并且保存至用户浏览器上的小文本文件，可以包含用户相关信息。\ncookie数据格式：键值对组成（python中的字典）\ncookie产生：客户端请求服务器。如果服务器需要记录该用户状态，就向客户端颁发一个cookie数据\ncookie使用：当浏览器再次请求该网站时，浏览器把请求的数据和cookie数据一同提交给服务器检查该cookie，以此来辨认用户状态\nselenium操作cookie# 1. 获取指定cookie，name为cookie的名称。底层是get_cookies()gey_cookie(name)# 2. 获取本网站所有本地cookiesget_cookies()# 3. 添加coockie。cookie_dict:一个字典对象，必选的键包括&#x27;name&#x27; and &#x27;value&#x27;add_cookie(cookie_dict)\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https://www.baidu.com/&quot;)time.sleep(3)# 添加cookiebrowser.add_cookie(&#123;&quot;name&quot;: &quot;BDUSS&quot;,                    &quot;value&quot;: &quot;JwZG4zOUpyQU1RbXI2Z0VmbXVlU0ZuWmY0MUotcVZqcER-N3RqV0l-WUZveHRtSVFBQUFBJCQAAAAAAAAAAAEAAABZR~-XUmlubnQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUW9GUFFvRlSF&quot;&#125;)time.sleep(5)browser.refresh()time.sleep(10)browser.quit()\n\n\n# 导包from selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 获取浏览器对象browser = webdriver.Chrome()time.sleep(2)browser.maximize_window()# 访问urlbrowser.get(&quot;https://www.baidu.com/&quot;)time.sleep(3)# 添加cookiebrowser.add_cookie(&#123;&quot;name&quot;: &quot;BDUSS&quot;,                    &quot;value&quot;: &quot;JwZG4zOUpyQU1RbXI2Z0VmbXVlU0ZuWmY0MUotcVZqcER-N3RqV0l-WUZveHRtSVFBQUFBJCQAAAAAAAAAAAEAAABZR~-XUmlubnQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUW9GUFFvRlSF&quot;&#125;)# 获取所有的cookies信息cookies=browser.get_cookies()for co in cookies:    print(co)# 获取单个cookiecookie=browser.get_cookie(&quot;name&quot;)print(cookie)print(browser.get_cookie(&#x27;BDUSS&#x27;))time.sleep(5)browser.refresh()time.sleep(10)browser.quit()\n\n\n登录测试案例import timeimport unittestfrom selenium import webdriverfrom selenium.webdriver.common.by import By# 定义测试类class TestJDShop(unittest.TestCase):    # 定义初始化方法    def setUp(self):        url = &#x27;https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F%3Fcu%3Dtrue%26utm_source%3Dbaidu-pinzhuan%26utm_medium%3Dcpc%26utm_campaign%3Dt_288551095_baidupinzhuan%26utm_term%3D0f3d30c8dba7459bb52f2eb5eba8ac7d_0_40173755626041979e00a100eec87380&#x27;        self.driver = webdriver.Chrome()        self.driver.maximize_window()        self.driver.get(url)        self.driver.implicitly_wait(10)    # 定义teardown    def tearDown(self):        # 关闭浏览器对象        time.sleep(2)        self.driver.close()    def test_code_null(self):        driver = self.driver        # 切换至短信登录        driver.find_element(By.CSS_SELECTOR, &#x27;#sms-login&#x27;).click()        # 输入账号        el1 = driver.find_element(By.CSS_SELECTOR, &#x27;#mobile-number&#x27;)        time.sleep(3)        el1.send_keys(&#x27;12345678901&#x27;)        # 点击发送验证码        time.sleep(3)        el2 = driver.find_element(By.CSS_SELECTOR, &#x27;#send-sms-code-btn&#x27;)        el2.click()        # 输入验证码        time.sleep(3)        el3 = driver.find_element(By.CSS_SELECTOR, &#x27;#sms-code&#x27;)        el3.send_keys(&#x27;324678&#x27;)        # 点击登录        time.sleep(3)        driver.find_element(By.CSS_SELECTOR, &#x27;#sms-login-submit&#x27;).click()        # 获取错误提示信息        text = driver.find_element(By.CSS_SELECTOR, &#x27;.sms-box-error-msg&#x27;).text        expect_text = &#x27;验证码为空&#x27;        print(text)        try:            self.assertEqual(text, expect_text)        except AssertionError:            driver.get_screenshot_as_file(&#x27;./&#123;&#125;.png&#x27;.format(time.strftime(&quot;%Y_%m_%d_%H_%M_%S&quot;)))            # 抛异常，有异常捕获不抛出会显示test pass            raise\n\n\n\nPO模式PO：page（页面），objecr（对象）\nv1：不采用任何模型（线性模型）\nv2：采用unittest框架\nv3：业务代码和页面对象进行分离\nv4：实际中的PO模式编写\nv1不能实现批量执行\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import By# 测试之前的前置工作# 实例化对象browser=webdriver.Chrome()# 窗口最大化browser.maximize_window()# 获取urlbrowser.get(&#x27;https://login.taobao.com/member/login.jhtml?spm=a21bo.jianhua.754894437.1.5af92a89NKrwFE&amp;f=top&amp;redirectURL=https%3A%2F%2Fwww.taobao.com%2F&#x27;)browser.implicitly_wait(10)# 切换至短信登录# 点击切换按钮time.sleep(3)browser.find_element(By.XPATH,&#x27;//*[@id=&quot;login&quot;]/div[2]/div/div[2]/a[1]&#x27;).click()time.sleep(3)# 输入错误的usernameel1=browser.find_element(By.CSS_SELECTOR,&#x27;#fm-login-id&#x27;)el1.send_keys(&#x27;15234567888&#x27;)# 输入正确的密码time.sleep(2)el2=browser.find_element(By.CSS_SELECTOR,&#x27;#fm-login-password&#x27;)el2.send_keys(&#x27;Rinta1343&#x27;)# 点击登录time.sleep(10)browser.find_element(By.CSS_SELECTOR,&#x27;.class=&quot;fm-button fm-submit password-login&#x27;).click()# 获取错误提示信息time.sleep(1)msg=browser.find_element(By.CSS_SELECTOR,&#x27;.login-error-msg&#x27;)assert msg == &#x27;账号名或登录密码不正确&#x27;# 结束工作，关闭对象time.sleep(5)browser.quit()\n\nv2可以批量运行，代码冗余量大。没有实现页面对象与业务脚本的分离\nimport timeimport unittestfrom selenium import webdriverfrom selenium.webdriver.common.by import By# 新建测试类class TestLogin(unittest.TestCase):    browser=None    # 测试之前的前置工作    @classmethod    def setUpClass(cls):        # 实例化对象        cls.browser=webdriver.Chrome()        # 窗口最大化        cls.browser.maximize_window()        # 获取url        cls.browser.get(&#x27;https://login.taobao.com/member/login.jhtml?spm=a21bo.jianhua.754894437.1.5af92a89NKrwFE&amp;f=top&amp;redirectURL=https%3A%2F%2Fwww.taobao.com%2F&#x27;)        cls.browser.implicitly_wait(10)    @classmethod    def tearDownClass(cls):        # 结束工作，关闭对象        time.sleep(5)        cls.browser.quit()    def test_login_username_not_exist(self):        browser=self.browser        # 切换至短信登录        # 点击切换按钮        time.sleep(3)        browser.find_element(By.XPATH,&#x27;//*[@id=&quot;login&quot;]/div[2]/div/div[2]/a[1]&#x27;).click()        time.sleep(3)        # 输入错误的username        el1=browser.find_element(By.CSS_SELECTOR,&#x27;#fm-login-id&#x27;)        el1.clear()        el1.send_keys(&#x27;13945671234&#x27;)        # 输入正确的密码        time.sleep(2)        el2=browser.find_element(By.CSS_SELECTOR,&#x27;#fm-login-password&#x27;)        el2.clear()        el2.send_keys(&#x27;Rinta1314&#x27;)        # 点击登录        time.sleep(10)        browser.find_element(By.CSS_SELECTOR,&#x27;.class=&quot;fm-button fm-submit password-login&#x27;).click()        # 获取错误提示信息        time.sleep(1)        msg=browser.find_element(By.CSS_SELECTOR,&#x27;.login-error-msg&#x27;)        try:            self.assertEqual(msg,&#x27;账号名或登录密码不正确&#x27;)        except AssertionError:            browser.get_screenshot_as_file(&#x27;../reports/failusername.png&#x27;)    def test_login_password_err(self):        browser = self.browser        # 切换至短信登录        # 点击切换按钮        time.sleep(3)        browser.find_element(By.XPATH, &#x27;//*[@id=&quot;login&quot;]/div[2]/div/div[2]/a[1]&#x27;).click()        time.sleep(3)        # 输入错误的username        el1 = browser.find_element(By.CSS_SELECTOR, &#x27;#fm-login-id&#x27;)        el1.clear()        el1.send_keys(&#x27;13945671234&#x27;)        # 输入正确的密码        time.sleep(2)        el2 = browser.find_element(By.CSS_SELECTOR, &#x27;#fm-login-password&#x27;)        el2.clear()        el2.send_keys(&#x27;Rinta1314&#x27;)        # 点击登录        time.sleep(10)        browser.find_element(By.CSS_SELECTOR, &#x27;.class=&quot;fm-button fm-submit password-login&#x27;).click()        # 获取错误提示信息        time.sleep(1)        msg = browser.find_element(By.CSS_SELECTOR, &#x27;.login-error-msg&#x27;)        try:            self.assertEqual(msg, &#x27;账号名或登录密码不正确&#x27;)        except AssertionError:            browser.get_screenshot_as_file(&#x27;../reports/failpassword.png&#x27;)\n\nv3页面层以page开头，业务层以test开头\n\n页面层级清晰，但是代码冗余量大\n页面层代码page_login.py:\n&quot;&quot;&quot;页面对象层    页面对象编写技巧：        类名：使用大驼峰将模块名称抄进来，有下划线去掉下划线        方法：根据业务需求每个操作步骤单独封装一个方法            方法名：page_XXX&quot;&quot;&quot;from selenium import webdriverfrom selenium.webdriver.common.by import Byclass PageLogin:    def __init__(self):        # 获取driver对象        self.driver = webdriver.Chrome()        # 最大化浏览器        self.driver.maximize_window()        # 隐式等待        self.driver.implicitly_wait(10)        # 打开url        self.driver.get(&#x27;https://www.taobao.com/&#x27;)    # 点击登录链接    def page_click_login(self):        self.driver.find_element(By.PARTIAL_LINK_TEXT, &#x27;请登录&#x27;).click()    # 切换至短信登录    def page_switch_to_text(self):        self.driver.find_element(By.XPATH, &#x27;//*[@id=&quot;login&quot;]/div[2]/div/div[2]/a[1]&#x27;).click()    # 输入用户名    def page_input_username(self, username):        self.driver.find_element(By.CSS_SELECTOR, &#x27;#fm-login-id&#x27;).send_keys(username)    # 输入密码    def page_input_pwd(self, pwd):        self.driver.find_element(By.CSS_SELECTOR, &#x27;#fm-login-password&#x27;).send_keys(pwd)    # 点击登录    def page_click_login_btn(self):        self.driver.find_element(By.CSS_SELECTOR, &#x27;.class=&quot;fm-button fm-submit password-login&#x27;).click()    # 获取异常提示    def page_get_text(self):        return self.driver.find_element(By.CSS_SELECTOR, &#x27;.login-error-msg&#x27;)    # 组装登录业务方法给业务层调用    def page_login(self, username, pwd):        self.page_click_login()        self.page_switch_to_text()        self.page_input_username(username)        self.page_input_pwd(pwd)        self.page_click_login_btn()\n\n业务层代码test_login：\n# 导包import unittestfrom parameterized import parameterizedfrom po.v3.page.page_login import PageLogin# 新建测试类class TestLogin(unittest.TestCase):    # 初始化方法    def setUp(self):        # 获取登录页面对象        self.login = PageLogin()        pass    # 结束方法    def tearDown(self):        # 关闭驱动对象        self.login.driver.quit()    # 新建测试方法    # 参数化    @parameterized.expand([(&#x27;13345678899&#x27;, &#x27;123456&#x27;, &#x27;账号不存在&#x27;), (&#x27;15945678899&#x27;, &#x27;123123&#x27;, &#x27;密码错误&#x27;)])    def test_login(self, username, pwd, expect):        # 调用测试登录方法        self.login.page_login(username, pwd)        # 获取登录信息        msg = self.login.page_get_text()        try:            # 断言            self.assertEqual(msg, expect)        except AssertionError:            self.login.driver.get_screenshot_as_file(&#x27;../report.png&#x27;)\n\nv4抽取v3版本的page页面公共方法—&gt;base（基类&#x2F;工具层）\npage（页面对象）：一个页面封装成一个对象，继承base\nscripts（业务层）：导包调用page页面\n\n数据驱动以数据来驱动整个测试用例的执行，也就是测试数据决定测试结果，可以将用户的关注点放在测试数据的构建和维护上，而不是直接维护脚本，可以利用同样的过程对不同的数据进行测试，实现要依赖参数化。\n数据驱动常用的格式：json、xml、excel、csv、txt\njson的底层是字符串，和字典有区别\npython字典和json之间的转换python字典–&gt;json字符串dumps()\ndata = &#123;    &#x27;id&#x27;:1,    &#x27;name&#x27;:&#x27;Tom&#x27;,    &#x27;address&#x27;:&#x27;北京市海淀区&#x27;,    &#x27;school&#x27;:None&#125;json_str=json.dumps(data) #jump()是写\n\nimport jsondata = &#123;    &#x27;id&#x27;: 1,    &#x27;name&#x27;: &#x27;Tom&#x27;,    &#x27;address&#x27;: &#x27;北京市海淀区&#x27;,    &#x27;school&#x27;: None&#125;print(type(data))json_str = json.dumps(data)print(json_str)print(type(json_str))\n\n\njson字符串–&gt;dict键名必须是””起来\nloads()\njson_str = &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;,&quot;address&quot;:&quot;北京市海淀&quot;,&quot;school&quot;:null&#125;&#x27;dict_data=json.loads(json_str)# loads()为读取json\n\nimport jsonjson_str = &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;,&quot;address&quot;:&quot;北京市海淀&quot;,&quot;school&quot;:null&#125;&#x27;dict_data=json.loads(json_str)print(type(json_str))print(dict_data)print(type(dict_data))\n\n\njson读写读jsonload()\nimport jsonparam = &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;,&quot;address&quot;:&quot;北京市&quot;,&quot;school&quot;:null&#125;&#x27;with open(&#x27;../test_write.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    json.dump(param, f, ensure_ascii=False)\n\n写jsondump()\nimport jsonwith open(&#x27;../test_write.json&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:    data = json.load(f)    print(data)\n\n网页计算器案例base: 查找元素、点击、获取value属性、截图\n","tags":["test"]},{"title":"测试点设计","url":"/2024/03/25/%E6%B5%8B%E8%AF%95%E7%82%B9%E8%AE%BE%E8%AE%A1/","content":"对穷举场景设计测试点等价类划分法说明|分类|步骤一种典型的、重要的黑盒测试方法，是指某个输入域的子集合，在该子集合中，所有的输入数据对于揭露软件中的错误都是等效的。\n\n\n有效等价只取其一，每个无效集合取1个\n设计一个新的测试用例，使其尽可能多的覆盖尚未被覆盖的有效等价类，重复这一步直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步直到所有的无效等价类都被覆盖为止\n\n适用场景\n通过等价类把穷尽测试转化为有限的有效测试\n举例\n用户名长度6~18，必须以字母数字下划线两者或两者以上组合\n微信红包\n按数据范围划分：不超过两位小数的值\n\n\n\n对限定边界规则设计测试点边界值分析法边界范围节点内点一般取居中的点最多7条\n边界值法设计用例步骤\n案例优化\n适用场景单个输入框，常用的方式：边界+等效类\n对多条件依赖关系设计测试点因果图法使用场景：当需求中存在多个条件，不同条件中存在不同的结果，就会使用因果图法。\n分别列出需求中的因子（条件）和结果\n判定表法\n等价类边界值分析法主要关注单个输入类条件的测试\n并未考虑输入条件之间的各种组合、输入条件于输出结果之间有相互制约关系的测试\n判定表法要求多个条件之间有依赖或制约关系\n\n判定表定义及组成部分判定表&#x3D;条件桩（需求中的因子）+动作桩（需求中的结果）+条件项（不同因子的组合）+动作项（不同因子造成结果的组合） \n\n判定表法设计用例步骤\n使用场景如果条件超过4个，就不适合覆盖所有条件，应采用正交法来解决。\n正交实验法利用因果图设计测试用例时，作为输入条件的原因和输出结果之间的因果关系，有时候很难从软件需求规格说明中得到。往往因果关系非常庞大，提取的用例数目多的惊人，则可以采用正交实验设计方法。\n正交表$$L_n(m^k)$$\n\nn是表的行数，也就是需要测试组合的次数\n\nk是表的列数，表示控件的个数（因素的割舍，或因子个数）\n\nm是每个控件包含的取值个数（各因素的水平数，即各因素的状态数）\n\n如$$L_9(3^4)$$有4个控件\n每个控件有3个取值\n9为需要测试的组合个数\n\n\n\n对于项目业务设计测试点场景法对项目的业务流程功能用例的设计基于场景法来进行设计\n通过场景描述的业务流程（业务逻辑），也包括代码实现逻辑，设计用例来遍历场景（路径），验证软件系统功能的正确性\n正常流&#x2F;基本流：从起点开始，通过各个路径，在最后的节点结束。模拟用户正常操作的流程\n异常流&#x2F;错误流&#x2F;备选流：从起点开始，可能在某个节点结束或者会返回上一节点，模拟用户错误的操作的流程。\n流程图业务流程图是基于场景法设计测试用例的依据，由产品去提供业务流程图\n\n\n覆盖业务测试需要使用流程图法\n先测试业务、再测试单功能、单模块、单页面\n\n使用场景业务用例必须先测案例3-1：\n错误推测法（反推法）\n通过经验推测程序中所有可能出现的问题，主要依靠经验、知识、直觉\n根据经验列举出可能出现问题的清单，根据清单分析问题可能原因，推测发现缺陷。\n探索性测试\n\n\n场景\n\n当项目用例都执行完毕且BUG修复完成，离上线还有一段时间，在这段时间中可以使用错误推测法复测主要业务或未测试的功能\n\n用例评审设计完用例后要进行用例评审，评审要检测用例的覆盖率和检查是否错写测试用例。评审分为组内和组外评审用例评审通过之后进行用例归档，再进入用例执行阶段。\n笔试面试题\n用例需要评审么？紧急情况用例也需要评审么？\n需要评审，紧急情况也需要评审，可能不通过会议进行评审，会通过右键发给相关人员\n\n如果被测项目很紧急，来不及写用例，怎么办？\ncheck list，使用xmind列出测试点，根据检查点进行测试，测试完之后时间足够的时候补充用例——后期要进行回归测试，也可以知道当时是怎么覆盖的\n\n遇到隐形需求如何写用例（需求不明确）\n熟悉当前的功能，参考成熟产品，站在用户角度挖掘需求，去和产品沟通\n\n用例有没有优先级？如果一定要有优先级，依据什么来确定呢？\n有，根据功能，使用的场景是不是重要的，核心的\n\n如何去编写测试用例？（以项目为基础来讲一个小模块用例设计，手机号）\n\n编写测试用例会用到什么方法？\n先去了解项目的业务流程，对于业务流程的用例使用场景法写，针对某些输入功能用等价类边界值来进行设计，需求里面存在多个条件多个组合，使用因果图判定表设计\n\n\nweb测试测试点：前端页面发布上线之前需要检查（描述不恰当的文字出现）所有注释或去除注释img图片必须要有title属性（悬停和未加载显示）按钮测试点：统一使用value赋值\n","categories":["sofetware test"]},{"title":"用例执行及缺陷","url":"/2024/03/25/%E7%94%A8%E4%BE%8B%E6%89%A7%E8%A1%8C%E5%8F%8A%E7%BC%BA%E9%99%B7/","content":"用例执行执行结果与用例的期望结果不一致（含义），为缺陷，需要进行缺陷管理\n测试计划一份描述测试工作计划的测试文档，对测试工作进行统筹计划安排\n测试计划编写者：测试主管&#x2F;leader\n测试计划的查阅者：测试人员、测试主管&#x2F;leader、产品、开发、销售人员\n面试题\n测试计划包含哪些内容？（测试人员会查阅评审测试计划）\n5W1H—&gt;目的（why）、测试范围（what）、时间安排（when）、测试环境（where）、测试人员（who），怎么去测试（how 测试方法、测试工具）\n测试风险评估，一般存在风险（需求变更&#x2F;需求做增加），测试的时间会增加—&gt;方案：测试时间拉长，人员调配，协调，加班，做计划的时候，时间安排做一些需求变更的预留。测试人员的变动—&gt;人员调配、协调、加班\n\n在测试阶段，如何保证用例的覆盖率？\n先做测试需求分析，进行评审，防止错测和漏测。进行用例设计的时候结合不同的设计，用到不同的设计方法，尽可能的去模拟用户所有的测试数据及测试场景，把对应的测试点全部进行覆盖。写完用例之后也会进行评审。\n\n测试的工作量占整个项目的时间比例多少\n测试30%40%,开发70%60%\n\n\n缺陷\n软件在使用过程中存在的任何问题都叫软件的缺陷，简称bug。广义概念除此之外还包括测试工程师或用户所发现和提出软件可改进的细节、或与需求文档存在差异的功能实现\n\n缺陷的判定标准 \nbug的类型\n代码（功能）错误：功能错误、性能、安全\n界面优化：界面、易用性测试\n设计缺陷：建议优化的bug\n\nbug的等级bug等级越高，修复的优先级也越高，问题越严重数字越小\n（1）致命错误（blocker）：\n\n常规操作引起的系统崩溃、死机、死循环、闪退\n造成数据泄露的安全性问题，比如恶意攻击造成的账户私密信息泄露\n涉及金钱计算（延时不算致命）\n阻断性测试，所有测试工作进行不下去（冒烟测试）\n\n（2）严重错误（critical）：\n\n重要功能不能实现\n错误的波及面广，影响到其他重要功能正常实现（次要功能影响到关联的核心功能）\n非常规操作导致的程序崩溃、死机、死循环、闪退\n外观（界面）难以接受的缺陷\n密码明文显示（界面+数据库）\n偶现的致命性bug（记录复现率）\n\n（3）一般错误（major）：\n不影响产品的运行、不会成为故障起因，但对产品外观和下道工序影响较大的缺陷\n\n次要功能不能正常实现\n操作界面的错误（包括数据窗口内列名定义、含义不一致）\n查询错误，数据显示错误\n简单的输入限制未放在前端进行控制\n删除操作未给出提示\n偶先的严重性bug\n\n（4）细微错误（minor）：\n\n界面方面的问题\n描述错误、错别字\n\n（5）改进建议（enhancement）\n缺陷产生的原因\n\n需求文档\n架构设计\n编码实现\n环境（硬件、软件）\n\n软件缺陷生命周期\n软件缺陷的核心内容\n缺陷提交要素\n测试报告内容包括测试范围、测试环境、数据统计（bug数据、bug状态、bug类型统计、按功能模块统计）、测试总结（测试用例数、执行率、成功率【用例通过率】、缺陷的关闭率、遗留bug情况【一二级修复情况，遗留bug等级，及情况说明】，结论是ST测试通过&#x2F;不通过）\n软件缺陷类型\n\n工作流程\n\n\n设计用例-&gt;执行用例（执行测试）-&gt;缺陷（提交、验证、关闭）\n缺陷定义：任何问题Bug\n缺陷标准；多功能、少功能、错误、缺少隐形功能、易用性\n项目中缺陷管理流程：提交、验证、关闭\n描述缺陷：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注\n提交缺陷信息：指派人、缺陷等级、修复优先级、类型、状态（统计）\n\n缺陷编写缺陷编写示例\n缺陷的跟踪流程\n提交缺陷注意事项当发现缺陷后，首先应该保证缺陷的可复现，确定是bug再提交。提交时，要检查缺陷是否已存在\n缺陷编写规范\n缺陷标题分析\n描述测试数据+实际结果（预期结果）：标题15位纯数字结果合法（期望：不合法）\n测试数据描述+预期结果（实际结果）：标题15位纯数字预期不合法（实际：合法）\n测试数据描述+实际结果（需求）：标题15位纯数字结果合法（需求：标题为1位字符串）\n\n项目管理流程\n","categories":["software test"]},{"title":"认识软件及测试","url":"/2024/03/25/%E8%AE%A4%E8%AF%86%E8%BD%AF%E4%BB%B6%E5%8F%8A%E6%B5%8B%E8%AF%95/","content":"什么是软件测试什么是软件？控制计算机硬件工作的工具，分为：\n\n应用软件：计算机用户为了解决某些具体问题而购买、开发或研制的各种程序或软件包\n\nC&#x2F;S架构：client-server，需要安装客户端才能够使用的软件，每次更新都需要更新服务端和客户端\nB&#x2F;S架构：browser-server，只需要更新服务器，通过浏览器访问\n\n\n系统软件：生成、准备和执行其他程序所需要的一组文件和程序。\n\n\n软件基本组成软件是计算机程序、程序所用的数据及相关文档资料。\n软件&#x3D;程序+数据+文档\n\n软件的产生过程：\n\n什么是软件测试？使用人工和自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。\n\n软件测试的目的\n为了发型程序（软件）存在的代码或业务逻辑错误（找到bug）\n为了检验产品是否符合用户需求（提升质量）\n为了提供用户的体验（提高用户体验）\n\n\n测试的主流技能\n功能测试：根据文档执行，将反馈结果与预期结果比较。功能测试主要验证程序的功能是否满足需求\n自动化测试：使用代码或工具代替手工，对项目进行测试\n接口测试：使用代码或工具对服务端提供的接口进行测试，验证程序中的接口是否访问正常。\n性能测试-工具实现：模拟多人使用软件，查找服务器缺陷\n\n常见的测试分类按测试阶段划分\n\n单元测试：为了确保各单元模块被正确的编译，比如有具体到模块的测试，也有具体到类、函数、方法的测试。bug太多，修复率太低，开发人员自测\n集成测试（接口测试）：单元测试后，将各单元组合成完整的体系，测试单位之间的接口是否正确、数据能否正常传递。\n系统测试：把软件系统搭建起来，按照软件规格说明书中所要求，测试软件其性能功能是否和用户需求相符合，在系统运行中是否存在漏洞。看做整体进行测试，除功能以外，需求、兼容性也需要考虑。\n验收测试：主要是用户在拿到软件的时候，在使用现场，会根据前边所提到的需求，以及规格说明书来做相应测试，以确定软件达到符合效果的。针对有的项目有这种测试，即内测、公测\nα测试：把用户请到开发方对软件进行的测试，测试环境受开发方控制，测试人员不多，测试时间比较集中。执行者：测试人员、用户、公司内部人员\nβ测试：测试环境不受开发方控制，测试人比较多，测试时间不集中\n一般先做α测试再做β测试\n\n\n\n按代码可见度划分\n\n黑盒测试：针对功能、兼容性进行测试。对应系统测试\n灰盒测试：对应集成测试\n白盒测试：对应单元测试\n\n被测对象是否运行\n动态测试：运行被测试系统而进行的测试\n静态测试：不需要运行被测试系统而进行的测试（界面检查、文档检查、代码走查）\n\n包含内容划分\n功能测试\n界面测试\n易用性测试\n性能测试（负载测试、压力测试）\n安全测试\n\n其他测试\n冒烟测试：硬件测试中产生的概念。在进行正式测试前对主要核心功能进行的测试，一般由开发或者测试主管来负责。不通过会发回给开发\n回归测试：开发对存在问题的功能进行修改后再一次进行的测试，也需要验证相关功能\n探索性测试&#x2F;自由测试：根据项目经验进行的随意测试\n\n软件的生命周期SDLCSystems Development Life Cycle是软件开始研制到最终被废弃不用所经历的各个阶段\n瀑布型生命周期\n特点：自上而下、有顺序性\n缺点：回测成本比较高、测试周期比较长\nV模型\n需求分析阶段会产生需求规格说明书（SRS），测试根据这个编写测试用例。\nV模型，测试在需求阶段就已经介入了，可以降低测试成本，缩短开发周期。\n传统、周期长的项目使用V模型\n敏捷模型强调以人文本，把一个大项目分为多个相互联系但也可以独立运行的小项目并分别完成，在这个过程中软件一直处于可使用状态。\n特点：快，迭代周期短。弱化文档，通过人与人的沟通实现需求\n\n软件生命周期的各阶段问题的定义及规划主要确定软件的开发目的及其可行性，制定项目总体开发计划\n需求分析在确定软件开发可行的情况下，对软件需要实现的各个功能进行详细分析，明确客户的需求，输出需求规格说明书终版（原型图），提交评审\n设计把需求分析得到的结果转换为软件结构和数据结构，形成系统架构\n概要设计：主要是架构的实现，指搭建架构、表述各模块功能、模块接口连接和数据传递的实现等项事务\n详细设计：对概要设计中表述的各模块进行深入分析等，其中需要包含数据库设计说明\n编码按照详细设计好的模块功能表，编程人员编写出计算机可运行的程序代码\n测试单元测试、集成测试、系统测试、验收测试\n运行维护是软件生命周期中持续时间最长的阶段，在软件开发完成并投入使用之后，由于多方面的原因，软件不能继续适应用户的需求。要延续软件的使用寿命，就必须对软件进行维护。软件的维护主要包括纠错性维护和改进性维护两方面。\n质量模型衡量一个优秀软件的纬度\n\n功能性：\n性能：\n兼容性：\n易用性：\n安全：\n可靠性：\n可维护性：核心代码要有说明，该独立的要独立\n可移植性：\n\n软件测试流程\n在什么条件下可以发布？剩余bug数量很少，达到一定的用例执行覆盖率\n发布流程：开发打包—&gt;运维&#x2F;运营&#x2F;开发—&gt;部署到生产环境（用户的使用环境）\n开发环境：开发人员写代码的环境\n测试环境：测试人员进行测试的环境（1个或一个以上）\n预发布环境（UAT环境）：验收测试（UAT测试）进行的环境。\n生产环境：真实用户使用环境\n灰度测试：先发布部分功能，看用户的反馈，再去发布另外一部分的功能更新。\nA&#x2F;B测试：先发布的功能先让A部分的用户进行更新，再根据用户的反馈更新B用户的功能\n流程\n各个阶段的输出需求分析——根据需求规格说明书输出项目需求分析测试点列表\n用例设计——测试用例文档\n执行测试——bug\n评估测试——测试报告的输出\n\n\n需求评审\n\n\n参与角色：产品经理、开发、测试\n目的：需求一致、在各角度对需求进行查漏补缺、知道被测项目有哪些功能模块\n\n\n测试计划\n\n\n测什么、谁来测、怎么测\n\n\n用例设计 针对穷举进行设计\n用例执行\n缺陷管理\n测试报告\n\n测试需求分析解决测什么的问题，一般来自需求规格说明书中原始需求。测试需求应全部覆盖已定义的业务流程，以及功能和非功能方面的需求。\n功能：业务流程\n非功能：界面、文档、兼容性、易用性、性能、安全性\n根据需求规格说明书明确的测试的内容提取测试点，测试点是软件的最小单元\n测试需求分析的目的\n测试需求分析是编写测试用例的依据\n有助于保证测试的质量与进度\n测试需求是衡量测试覆盖率的重要指标\n\n需求分析的步骤\n查阅需求规格说明书（原型图），初步熟悉被测软件的核心的业务流程\n针对某个功能，细化需求，列出测试点\n根据业务逻辑的先后顺序来进行分析按钮，一般按钮存在（什么条件）操作成功，（什么条件）操作失败，验证操作结果（验证交互功能、即关联功能），验证当前操作的结果的功能\n\n一个页面进行测试需求分析\n进行页面检查，参考原型图，查看界面是否一致\n依次分析每个输入项，从上到下从左到右的顺序进行分析约束限制、是否必填、是否重复、隐形需求（如手机号码的格式验证）。\n\n案例\n\n\n面试题\n遇到隐形需求怎么办？\n要充分熟悉产品，参考成熟的同类产品，站在用户的角度去考虑，从而挖掘需求\n\n给你一个带logo的水杯，你会如何去测试？先明确测试的对象，什么样的杯子\n对应功能：能否装水，是否漏水，能否装热水冰水饮料，是否保温\n对应非功能：logo是否与原型图一致，美观，是否掉色，材质是否环保安全\n对应易用性：防滑，防烫，是否带手把，边缘是否光滑，携带是否方便\n兼容性：是否能装其他液体\n安全性：装热水的时候会有毒素吗\n性能：（如果是保温杯的化可以保温多久），是否防摔，挤压被子会不会坏，容不容易被水泡软\n\n你会如何测试朋友圈，购物车等熟知的软件产品（支付，优惠券，二维码）\n\n\n需求评审需求分析完成后要对需求进行评审，评审是否存在漏测和错测的测试点。\n参与人员：测试人员、组内人员、测试主管&#x2F;组长、产品、开发\n测试用例什么是用例？用例：用户使用的案例\n什么是测试用例？测试用例：为项目需求而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序是否满足客户需求。每一个测试点的数据设计和步骤设计\n测试用例的作用\n防止漏测\n实施测试的标准\n\n用例格式标准用例执行的八大要素| 用例编号 | 项目&#x2F;模块  | 用例标题 | 优先级 | 前置条件 | 测试步骤 | 测试数据 | 预期结果 |\n\n用例编号：项目简称_模块简称_编号，产品名-测试阶段（it、st、uat）-测试项-xxx（英文）或者项目+编号\n\n项目&#x2F;模块：所属项目或模块\n\n用例标题：主要描述测试的目的，输入内容＋结果，用例标题不要重复\n\n优先级：表示用例重要程度或者影响力P0~P4（P0最高，用户使用频率最高为核心功能）。高（主要核心业务功能，冒烟用例）中（错误异常的测试点，如注册失败）低（兼容性、界面错误）\n\n前置条件&#x2F;预置条件：要执行此条用例，有哪些前置操作。可以用来简化步骤。如果用例不需要其他条件，可以无条件\n\n测试步骤：执行用例步骤\n\n\n路径\n具体数据\n操作动作\n\n\n\n\n测试数据：操作的数据，没有的话可以为空（可以和操作步骤分开）\n\n预期结果：按照操作步骤，应该有什么结果，分为一对一（一个步骤对一个结果）和多对一（多个步骤对一个结果）用例执行结果+不同角色隐形结果\n\n实际结果：通过、不通过、阻塞（当前用例无法执行）\n\n（备注）：bugid&#x2F;测试无法执行原因\n\n（测试版本）\n\n（用例设计者）\n\n（测试时间）\n\n\n用例是根据测试点进行编辑，但并不是针对每个测试点编辑一条用例，否则会造成重复测试\n","categories":["software test"]}]